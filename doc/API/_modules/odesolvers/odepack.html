

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>odesolvers.odepack &mdash; odesolver API 0.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="odesolver API 0.1 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">odesolver API 0.1 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for odesolvers.odepack</h1><div class="highlight"><pre>
<span class="kn">from</span> <span class="nn">ODE</span> <span class="kn">import</span> <span class="n">Solver</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">inspect</span>

<span class="n">_parameters_Odepack</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>

    <span class="c"># Note that ODEPACK has its own convention for the</span>
    <span class="c"># arguments to the f and jac functions</span>

    <span class="n">f_f77</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Intend to supply a Fortran subroutine as f.      &#39;</span>\
             <span class="s">&#39;This subroutine should be defined in form::      &#39;</span>\
             <span class="s">&#39;                                                 &#39;</span>\
             <span class="s">&#39;        subroutine f_f77(neq,t,u,udot)           &#39;</span>\
             <span class="s">&#39;  Cf2py intent(hide)   neq                       &#39;</span>\
             <span class="s">&#39;  Cf2py intent(out)    udot                      &#39;</span>\
             <span class="s">&#39;        integer neq                              &#39;</span>\
             <span class="s">&#39;        double precision t,u(neq),udot(neq)      &#39;</span>\
             <span class="s">&#39;        udot = ...                               &#39;</span>\
             <span class="s">&#39;        return                                   &#39;</span>\
             <span class="s">&#39;        end                                      &#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">jac_f77</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Intend to supply a Fortran subroutine as jac.    &#39;</span>\
             <span class="s">&#39;This subroutine should be defined in form::      &#39;</span>\
             <span class="s">&#39;                                                 &#39;</span>\
             <span class="s">&#39;       subroutine jac_f77(neq,t,u,ml,mu,pd,      &#39;</span>\
             <span class="s">&#39;      1      nrowpd)                             &#39;</span>\
             <span class="s">&#39; Cf2py intent(hide) neq,ml,mu,nrowpd             &#39;</span>\
             <span class="s">&#39; Cf2py intent(out) pd                            &#39;</span>\
             <span class="s">&#39;       integer neq,ml,mu,nrowpd                  &#39;</span>\
             <span class="s">&#39;       double precision t,u,pd                   &#39;</span>\
             <span class="s">&#39;       dimension u(neq),pd(neq,neq)              &#39;</span>\
             <span class="s">&#39;       pd = ...                                  &#39;</span>\
             <span class="s">&#39;       return                                    &#39;</span>\
             <span class="s">&#39;       end                                       &#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">jac_banded</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;A callable object to define the banded Jacobian  &#39;</span>\
             <span class="s">&#39;matrix(df/du) of right-hand side function f.     &#39;</span>\
             <span class="s">&#39;Used in Lsode, Lsoda, Lsodar.                    &#39;</span>\
             <span class="s">&#39; jac_banded(u,t,ml,mu) returns df/du             &#39;</span>\
             <span class="s">&#39; vector * float * int * int --&gt;   2d-array       &#39;</span><span class="p">,</span>
        <span class="n">paralist_old</span><span class="o">=</span><span class="s">&#39;u,t,ml,mu&#39;</span><span class="p">,</span>
        <span class="n">paralist_new</span><span class="o">=</span><span class="s">&#39;t,u,ml,mu&#39;</span><span class="p">,</span>
        <span class="n">returnArrayOrder</span><span class="o">=</span><span class="s">&#39;Fortran&#39;</span><span class="p">,</span>
        <span class="n">name_wrapped</span><span class="o">=</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">jac_banded_f77</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Intend to supply a Fortran subroutine as jac_band  &#39;</span>\
             <span class="s">&#39;jac_banded.                                        &#39;</span>\
             <span class="s">&#39;This subroutine should be defined in form::        &#39;</span>\
             <span class="s">&#39;                                                   &#39;</span>\
             <span class="s">&#39;        subroutine jac_banded_f77(neq,t,u,ml,      &#39;</span>\
             <span class="s">&#39;       1                          mu,pd,nrowpd)    &#39;</span>\
             <span class="s">&#39;  Cf2py intent(hide) neq,ml,mu,nrowpd              &#39;</span>\
             <span class="s">&#39;  Cf2py intent(out) pd                             &#39;</span>\
             <span class="s">&#39;        integer neq,ml,mu,nrowpd                   &#39;</span>\
             <span class="s">&#39;        double precision t,u,pd                    &#39;</span>\
             <span class="s">&#39;        dimension u(neq),pd(nrowpd,neq)            &#39;</span>\
             <span class="s">&#39;        pd = ...                                   &#39;</span>\
             <span class="s">&#39;        return                                     &#39;</span>\
             <span class="s">&#39;        end                                        &#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">g</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Callable object to define constraint functions,  &#39;</span>\
             <span class="s">&#39;whose roots are desired during the integration.  &#39;</span>\
             <span class="s">&#39; g(u, t) --&gt; values of constraint functions      &#39;</span>\
             <span class="s">&#39; scalar/vector * float --&gt; scalar/vector         &#39;</span><span class="p">,</span>
        <span class="n">paralist_old</span><span class="o">=</span><span class="s">&#39;u,t&#39;</span><span class="p">,</span>
        <span class="n">paralist_new</span><span class="o">=</span><span class="s">&#39;t,u&#39;</span><span class="p">,</span>
        <span class="n">name_wrapped</span><span class="o">=</span><span class="s">&#39;g_f77&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">g_f77</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Intend to supply a Fortran subroutine as g.      &#39;</span>\
             <span class="s">&#39;This subroutine should be defined in form::       &#39;</span>\
             <span class="s">&#39;                                                 &#39;</span>\
             <span class="s">&#39;        subroutine g_f77(neq, t, u, ng, groot)   &#39;</span>\
             <span class="s">&#39;  Cf2py intent(hide) neq                         &#39;</span>\
             <span class="s">&#39;  Cf2py optional, intent(hide) ng                &#39;</span>\
             <span class="s">&#39;  Cf2py intent(in) t, u                          &#39;</span>\
             <span class="s">&#39;  Cf2py intent(out) groot                        &#39;</span>\
             <span class="s">&#39;        integer neq, ng                          &#39;</span>\
             <span class="s">&#39;        double precision t, u, groot             &#39;</span>\
             <span class="s">&#39;        dimension u(neq), groot(ng)              &#39;</span>\
             <span class="s">&#39;        groot = ...                              &#39;</span>\
             <span class="s">&#39;        return                                   &#39;</span>\
             <span class="s">&#39;        end                                      &#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">jac_column</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;A callable object to specify a column of Jacobian&#39;</span>\
             <span class="s">&#39; (df/du) matrix.                                 &#39;</span>\
             <span class="s">&#39;jac(u,t,j,ia,ja): jth column of Jacobian (df/du) &#39;</span>\
             <span class="s">&#39; vector * float * integer * integer vector       &#39;</span>\
             <span class="s">&#39; * integer vector    ---&gt;  vector                &#39;</span><span class="p">,</span>
        <span class="n">paralist_old</span><span class="o">=</span><span class="s">&#39;u,t,j&#39;</span><span class="p">,</span>
        <span class="n">paralist_new</span><span class="o">=</span><span class="s">&#39;t,u,j&#39;</span><span class="p">,</span>
        <span class="n">name_wrapped</span><span class="o">=</span><span class="s">&#39;jac_column_f77&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">jac_column_f77</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Intend to supply a Fortran subroutine as         &#39;</span>\
             <span class="s">&#39;jac_column.                                      &#39;</span>\
             <span class="s">&#39;This subroutine should be defined in form::      &#39;</span>\
             <span class="s">&#39;                                                 &#39;</span>\
             <span class="s">&#39;        subroutine jac_column_f77(neq, t, u, j,  &#39;</span>\
             <span class="s">&#39;       1       ia, ja, pd)                       &#39;</span>\
             <span class="s">&#39;  Cf2py intent(hide) neq, ia, ja                 &#39;</span>\
             <span class="s">&#39;  Cf2py intent(out) pd                           &#39;</span>\
             <span class="s">&#39;        integer neq, j, ia, ja                   &#39;</span>\
             <span class="s">&#39;        double precision t, u, pd                &#39;</span>\
             <span class="s">&#39;        dimension u(neq), pd(neq), ia(neq + 1),  &#39;</span>\
             <span class="s">&#39;       1       ja(*)                             &#39;</span>\
             <span class="s">&#39;        pd = ...                                 &#39;</span>\
             <span class="s">&#39;        return                                   &#39;</span>\
             <span class="s">&#39;        end                                      &#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="c"># parameters for linearly implicit ODE solvers: Lsodi, Lsoibt, Lsodis</span>
    <span class="n">res</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;User-supplied function to calculate the residual &#39;</span>\
             <span class="s">&#39;vector, defined by r =  g(u,t) - A(u,t) * s.     &#39;</span>\
             <span class="s">&#39;Used in the linearly implicit solvers: Lsodi,    &#39;</span>\
             <span class="s">&#39;Lsodis, Lsoibt.                                  &#39;</span>\
             <span class="s">&#39;res(u,t,s,ires)   --&gt;   (r,ires)                 &#39;</span>\
             <span class="s">&#39;vector * float * vector * int --&gt;  vector * int  &#39;</span>\
             <span class="s">&#39; &quot;ires&quot; is a flag both for input and output.     &#39;</span>\
             <span class="s">&#39;On input, ires indicates how ODEPACK would use   &#39;</span>\
             <span class="s">&#39;the returned array &quot;r&quot;:                          &#39;</span>\
             <span class="s">&#39;ires == 1: the full residual exactly.            &#39;</span>\
             <span class="s">&#39;ires == 2: &quot;r&quot; is used only to computejacobian   &#39;</span>\
             <span class="s">&#39;           dr/du by difference quotients.        &#39;</span>\
             <span class="s">&#39;&quot;res&quot; should set flag &quot;ires&quot; if it encounters a  &#39;</span>\
             <span class="s">&#39;halt condition or illegal input. Otherwise, it   &#39;</span>\
             <span class="s">&#39;should not be reset. On output, value 1 or -1    &#39;</span>\
             <span class="s">&#39;represents a normal return.                      &#39;</span><span class="p">,</span>
        <span class="n">paralist_old</span><span class="o">=</span><span class="s">&#39;u,t,s,ires&#39;</span><span class="p">,</span>
        <span class="n">paralist_new</span><span class="o">=</span><span class="s">&#39;t,u,s,ires&#39;</span><span class="p">,</span>
        <span class="n">name_wrapped</span><span class="o">=</span><span class="s">&#39;res_f77&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">res_f77</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Intend to supply a Fortran subroutine as res.    &#39;</span>\
             <span class="s">&#39;This subroutine should be defined in form::      &#39;</span>\
             <span class="s">&#39;                                                 &#39;</span>\
             <span class="s">&#39;      subroutine res_f77(neq, t, u, s, r, ires)  &#39;</span>\
             <span class="s">&#39; Cf2py intent(hide) neq                          &#39;</span>\
             <span class="s">&#39; Cf2py intent(out) r                             &#39;</span>\
             <span class="s">&#39; Cf2py intent(in,out) ires                       &#39;</span>\
             <span class="s">&#39;      double precision t, u, s, r                &#39;</span>\
             <span class="s">&#39;      dimension u(neq, s(neq), r(neq)            &#39;</span>\
             <span class="s">&#39;      ...                                        &#39;</span>\
             <span class="s">&#39;      return                                     &#39;</span>\
             <span class="s">&#39;      end                                        &#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">jac_lsodi</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Callable object to define the full Jacobian      &#39;</span>\
             <span class="s">&#39;matrix dr/du where r = g - A*s.                  &#39;</span>\
             <span class="s">&#39;jac(u,t,s)    --&gt; dr/du                          &#39;</span>\
             <span class="s">&#39;vector * float * vector                          &#39;</span>\
             <span class="s">&#39;   ----&gt;  2d-array with dimension (neq,neq)      &#39;</span><span class="p">,</span>
        <span class="n">paralist_old</span><span class="o">=</span><span class="s">&#39;u,t,s&#39;</span><span class="p">,</span>
        <span class="n">paralist_new</span><span class="o">=</span><span class="s">&#39;t,u,s&#39;</span><span class="p">,</span>
        <span class="n">name_wrapped</span><span class="o">=</span><span class="s">&#39;jac_lsodi_f77&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">jac_lsodi_f77</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Intend to supply Fortran subroutine as jac_lsodi.&#39;</span>\
             <span class="s">&#39;This subroutine should be defined in form::      &#39;</span>\
             <span class="s">&#39;                                                 &#39;</span>\
             <span class="s">&#39;       subroutine jac_lsodi_f77(neq, t, u, s, ml,&#39;</span>\
             <span class="s">&#39;      1           mu, pd, nrowpd)                &#39;</span>\
             <span class="s">&#39; Cf2py intent(in, hide) neq, ml, mu, nrowpd      &#39;</span>\
             <span class="s">&#39; Cf2py intent(out) pd                            &#39;</span>\
             <span class="s">&#39;       integer neq, ml, mu, nrowpd               &#39;</span>\
             <span class="s">&#39;       double precision t, u, pd, s              &#39;</span>\
             <span class="s">&#39;       dimension u(neq), s(neq), pd(nrowpd, neq) &#39;</span>\
             <span class="s">&#39;       pd = ...                                  &#39;</span>\
             <span class="s">&#39;       return                                    &#39;</span>\
             <span class="s">&#39;       end                                       &#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">jac_banded_lsodi</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Callable object to define the banded Jacobian    &#39;</span>\
             <span class="s">&#39;matrix dr/du where r = g - A*s.                  &#39;</span>\
             <span class="s">&#39;jac(u,t,s,ml,mu), where ml &amp; mu are lower &amp; upper&#39;</span>\
             <span class="s">&#39;half-bandwidth of banded matrix.                 &#39;</span>\
             <span class="s">&#39;vector * float * vector * int * int              &#39;</span>\
             <span class="s">&#39;   ---&gt;  2d-array with dimension (*,neq)         &#39;</span><span class="p">,</span>
        <span class="n">paralist_old</span><span class="o">=</span><span class="s">&#39;u,t,s,ml,mu&#39;</span><span class="p">,</span>
        <span class="n">paralist_new</span><span class="o">=</span><span class="s">&#39;t,u,s,ml,mu&#39;</span><span class="p">,</span>
        <span class="n">name_wrapped</span><span class="o">=</span><span class="s">&#39;jac_banded_lsodi_f77&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">jac_banded_lsodi_f77</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Intend to supply a Fortran subroutine as         &#39;</span>\
             <span class="s">&#39;jac_banded_lsodi.                                &#39;</span>\
             <span class="s">&#39;This subroutine should be defined in form::      &#39;</span>\
             <span class="s">&#39;                                                 &#39;</span>\
             <span class="s">&#39;       subroutine jac_banded_lsodi_f77(neq, t, u,&#39;</span>\
             <span class="s">&#39;      1      s, ml, mu, pd, nrowpd)              &#39;</span>\
             <span class="s">&#39; Cf2py intent(in, hide) neq, ml, mu, nrowpd      &#39;</span>\
             <span class="s">&#39; Cf2py intent(out) pd                            &#39;</span>\
             <span class="s">&#39;       integer neq, ml, mu, nrowpd               &#39;</span>\
             <span class="s">&#39;       double precision t, u, pd, s              &#39;</span>\
             <span class="s">&#39;       dimension u(neq), s(neq), pd(nrowpd, neq) &#39;</span>\
             <span class="s">&#39;       pd = ...                                  &#39;</span>\
             <span class="s">&#39;       return                                    &#39;</span>\
             <span class="s">&#39;       end                                       &#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">adda_lsodi</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Callable object to add the matrix A = A(u,t) to  &#39;</span>\
             <span class="s">&#39;another matrix p stored in the same form as A.   &#39;</span>\
             <span class="s">&#39;addaName(u,t,p)  :   vector * float * 2d-array   &#39;</span>\
             <span class="s">&#39;  ----&gt;  2d-array with dimension (neq,neq)       &#39;</span><span class="p">,</span>
        <span class="n">paralist_old</span><span class="o">=</span><span class="s">&#39;u,t,p&#39;</span><span class="p">,</span>
        <span class="n">paralist_new</span><span class="o">=</span><span class="s">&#39;t,u,p&#39;</span><span class="p">,</span>
        <span class="n">returnArrayOrder</span><span class="o">=</span><span class="s">&#39;Fortran&#39;</span><span class="p">,</span>
        <span class="n">name_wrapped</span><span class="o">=</span><span class="s">&#39;adda_lsodi_f77&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">adda_lsodi_f77</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Intend to supply a Fortran subroutine as         &#39;</span>\
             <span class="s">&#39;adda_lsodi.                                      &#39;</span>\
             <span class="s">&#39;This subroutine should be defined in form::      &#39;</span>\
             <span class="s">&#39;                                                 &#39;</span>\
             <span class="s">&#39;        subroutine adda_lsodi_f77(neq, t, u, ml, &#39;</span>\
             <span class="s">&#39;       1       mu, pd, nrowpd)                   &#39;</span>\
             <span class="s">&#39;  Cf2py intent(in, hide) neq, ml, mu             &#39;</span>\
             <span class="s">&#39;  Cf2py intent(in, hide), depend(pd) nrowpd      &#39;</span>\
             <span class="s">&#39;  Cf2py intent(in, out) pd                       &#39;</span>\
             <span class="s">&#39;        integer neq, ml, mu, nrowpd              &#39;</span>\
             <span class="s">&#39;        double precision t, u, pd                &#39;</span>\
             <span class="s">&#39;        dimension u(neq), pd(nrowpd, neq)        &#39;</span>\
             <span class="s">&#39;        pd = ...                                 &#39;</span>\
             <span class="s">&#39;        return                                   &#39;</span>\
             <span class="s">&#39;        end                                      &#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">adda_banded_lsodi</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Callable object to add the banded matrix         &#39;</span>\
             <span class="s">&#39;A = A(u,t) to another matrix stored P in the     &#39;</span>\
             <span class="s">&#39;same form as A, i.e. add A(i,j)to P(i-j+MU+1,j)  &#39;</span>\
             <span class="s">&#39;addaName(u,t,p,ml,mu):                           &#39;</span>\
             <span class="s">&#39;vector * float * 2d-array * int * int            &#39;</span>\
             <span class="s">&#39;    ---&gt;  2d-array with dimension (*,neq)        &#39;</span><span class="p">,</span>
        <span class="n">paralist_old</span><span class="o">=</span><span class="s">&#39;u,t,p,ml,mu&#39;</span><span class="p">,</span>
        <span class="n">paralist_new</span><span class="o">=</span><span class="s">&#39;t,u,p,ml,mu&#39;</span><span class="p">,</span>
        <span class="n">name_wrapped</span><span class="o">=</span><span class="s">&#39;adda_banded_lsodi_f77&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">adda_banded_lsodi_f77</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Intend to supply a Fortran subroutine as         &#39;</span>\
             <span class="s">&#39;adda_banded.                                     &#39;</span>\
             <span class="s">&#39;This subroutine should be defined in form::      &#39;</span>\
             <span class="s">&#39;                                                 &#39;</span>\
             <span class="s">&#39;       subroutine adda_banded_lsodi_f77(neq, t,  &#39;</span>\
             <span class="s">&#39;      1         u, ml, mu, pd, nrowpd)           &#39;</span>\
             <span class="s">&#39; Cf2py intent(in, hide) neq, ml, mu              &#39;</span>\
             <span class="s">&#39; Cf2py intent(in, hide), depend(pd) nrowpd       &#39;</span>\
             <span class="s">&#39; Cf2py intent(in, out) pd                        &#39;</span>\
             <span class="s">&#39;       integer neq, ml, mu, nrowpd               &#39;</span>\
             <span class="s">&#39;       double precision t, u, pd                 &#39;</span>\
             <span class="s">&#39;       dimension u(neq), pd(nrowpd, neq)         &#39;</span>\
             <span class="s">&#39;       pd = ...                                  &#39;</span>\
             <span class="s">&#39;       return                                    &#39;</span>\
             <span class="s">&#39;       end                                       &#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">jac_lsodis</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Callable object to supply the jth column of      &#39;</span>\
             <span class="s">&#39;the sparse Jacobian matrix dr/du where           &#39;</span>\
             <span class="s">&#39;r = g - A*s.                                     &#39;</span>\
             <span class="s">&#39;jac(u,t,s,j,ia,ja)   -----&gt;   p                  &#39;</span>\
             <span class="s">&#39;vector * float * vector * int * int vector       &#39;</span>\
             <span class="s">&#39;  * int vector      ------&gt;   vector             &#39;</span><span class="p">,</span>
        <span class="n">paralist_old</span><span class="o">=</span><span class="s">&#39;u,t,s,j-1,ia,ja&#39;</span><span class="p">,</span>
        <span class="n">paralist_new</span><span class="o">=</span><span class="s">&#39;t,u,s,j,ia,ja&#39;</span><span class="p">,</span>
        <span class="n">name_wrapped</span><span class="o">=</span><span class="s">&#39;jac_lsodis_f77&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">adda_lsodis</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Callable object to add j-th column of matrix     &#39;</span>\
             <span class="s">&#39;A = A(u,t) to another matrix stored in sparse    &#39;</span>\
             <span class="s">&#39;form.                                            &#39;</span>\
             <span class="s">&#39;adda(u,t,j,ia,ja,p)  :   --&gt; p                   &#39;</span>\
             <span class="s">&#39;vector * float * int * int vector * int vector   &#39;</span>\
             <span class="s">&#39;   * vector      ---&gt;  vector                    &#39;</span><span class="p">,</span>
        <span class="n">paralist_old</span><span class="o">=</span><span class="s">&#39;u,t,j-1,ia,ja,p&#39;</span><span class="p">,</span>
        <span class="n">paralist_new</span><span class="o">=</span><span class="s">&#39;t,u,j,ia,ja,p&#39;</span><span class="p">,</span>
        <span class="n">name_wrapped</span><span class="o">=</span><span class="s">&#39;adda_lsodis_f77&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">jac_lsoibt</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Callable object to supply the jth column of      &#39;</span>\
             <span class="s">&#39;the Jacobian matrix dr/du where r = g - A*s,     &#39;</span>\
             <span class="s">&#39;stored in block-tridiagonal form.                &#39;</span>\
             <span class="s">&#39;The argument list should in form of (u,t,s).     &#39;</span>\
             <span class="s">&#39; jac(u,t,s)   -----&gt;   (pa,pb,pc)                &#39;</span>\
             <span class="s">&#39; vector * float * vector   ------&gt;  (mb*mb*nb)   &#39;</span>\
             <span class="s">&#39;  array * (mb*mb*nb) array * (mb*mb*nb) array    &#39;</span>\
             <span class="s">&#39; pa, pb, and pc are to be loaded with partial    &#39;</span>\
             <span class="s">&#39; derivatives (elements of the Jacobian matrix)   &#39;</span>\
             <span class="s">&#39; on output, in terms of the block-tridiagonal    &#39;</span>\
             <span class="s">&#39; structure assumed. That is, load the diagonal   &#39;</span>\
             <span class="s">&#39; blocks into pa, the superdiagonal blocks (and   &#39;</span>\
             <span class="s">&#39; block (nb,nb-2)) into pb, and the subdiagonal   &#39;</span>\
             <span class="s">&#39; blocks (and block (1,3)) into pc.               &#39;</span>\
             <span class="s">&#39; The blocks in block-row k of dr/du are to be    &#39;</span>\
             <span class="s">&#39; loaded into pa(*,*,k), pb(*,*,k), and           &#39;</span>\
             <span class="s">&#39; pc(*,*,k).                                      &#39;</span>\
             <span class="s">&#39; Thus the affect of this function should be:     &#39;</span>\
             <span class="s">&#39; pa(i,j,k) = ( (i.j) element of k-th diagonal    &#39;</span>\
             <span class="s">&#39;             block of dr/du)                     &#39;</span>\
             <span class="s">&#39; pb(i,j,k) = ( (i,j) element of block (k,k+1)    &#39;</span>\
             <span class="s">&#39;             of dr/du, or block (nb,nb-2) if     &#39;</span>\
             <span class="s">&#39;             k == nb)                            &#39;</span>\
             <span class="s">&#39; pc(i,j,k) = ( (i,j) element of block (k,k-1)    &#39;</span>\
             <span class="s">&#39;             of dr/du, or block (1,3) if k==1)   &#39;</span><span class="p">,</span>
        <span class="n">paralist_old</span><span class="o">=</span><span class="s">&#39;u,t,s&#39;</span><span class="p">,</span>
        <span class="n">paralist_new</span><span class="o">=</span><span class="s">&#39;t,u,s&#39;</span><span class="p">,</span>
        <span class="n">name_wrapped</span><span class="o">=</span><span class="s">&#39;jac_lsoibt_f77&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">adda_lsoibt</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Callable object to add matrix A = A(u,t) to      &#39;</span>\
             <span class="s">&#39;another matrix P, stored in block-tridiagonal    &#39;</span>\
             <span class="s">&#39;form.                                            &#39;</span>\
             <span class="s">&#39; adda(u,t,pa,pb,pc)    -----&gt;  (pa,pb,pc)        &#39;</span>\
             <span class="s">&#39;vector * float * (mb*mb*nb) array * (mb*mb*nb)   &#39;</span>\
             <span class="s">&#39;array * (mb*mb*nb) array                         &#39;</span>\
             <span class="s">&#39;  --&gt;  (mb*mb*nb) array * (mb*mb*nb) array *     &#39;</span>\
             <span class="s">&#39;       (mb*mb*nb) array                          &#39;</span><span class="p">,</span>
        <span class="n">paralist_old</span><span class="o">=</span><span class="s">&#39;u,t,pa,pb,pc&#39;</span><span class="p">,</span>
        <span class="n">paralist_new</span><span class="o">=</span><span class="s">&#39;t,u,pa,pb,pc&#39;</span><span class="p">,</span>
        <span class="n">name_wrapped</span><span class="o">=</span><span class="s">&#39;adda_lsoibt_f77&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="c"># ja, ia, ja, ic are used to describe sparse structure of</span>
    <span class="c"># matrices in Lsodes and Lsodis.</span>
    <span class="n">ja</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Integer array containing the row indices where   &#39;</span>\
             <span class="s">&#39;nonzero elements occur, reading in columnwise    &#39;</span>\
             <span class="s">&#39;order.                                           &#39;</span>\
             <span class="s">&#39;Describes the sparsity matrix structure          &#39;</span>\
             <span class="s">&#39;together with ia.                                &#39;</span>\
             <span class="s">&#39;In Lsodes, ia &amp; ja describe the structure of     &#39;</span>\
             <span class="s">&#39;Jacobian matrix; while in Lsodis, ia &amp; ja are    &#39;</span>\
             <span class="s">&#39;used to describe the structure of matrix A.      &#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span>
        <span class="c"># integer sequence</span>
        <span class="n">extra_check</span><span class="o">=</span><span class="k">lambda</span> <span class="n">int_seq</span><span class="p">:</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span><span class="n">int_seq</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()),</span>

    <span class="n">ia</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Integer array with length neq+1 which contains   &#39;</span>\
             <span class="s">&#39;starting locations in ja of the descriptions     &#39;</span>\
             <span class="s">&#39;for columns 1...neq, in that order, with ia(1)   &#39;</span>\
             <span class="s">&#39;== 1. The last element ia[neq+1] should equal    &#39;</span>\
             <span class="s">&#39;to the total number of nonzero locations assumed.&#39;</span>\
             <span class="s">&#39;For each column j = 1...neq, the values of the   &#39;</span>\
             <span class="s">&#39;row index i in column j, where a nonzero element &#39;</span>\
             <span class="s">&#39;may occur, are given by i == ja(k) where ia(j) &lt;=&#39;</span>\
             <span class="s">&#39;k &lt; ia(j+1).                                     &#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span>
        <span class="c"># integer sequence</span>
        <span class="n">extra_check</span><span class="o">=</span><span class="k">lambda</span> <span class="n">int_seq</span><span class="p">:</span> \
             <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span><span class="n">int_seq</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()),</span>

    <span class="n">jc</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Integer array which describes the sparsity       &#39;</span>\
             <span class="s">&#39;Jacobian structure together with ic, like ia     &#39;</span>\
             <span class="s">&#39;and ja.                                          &#39;</span>\
             <span class="s">&#39;In Lsodis, ia and ja describe the sparse         &#39;</span>\
             <span class="s">&#39;structure of matrix A, while ic &amp; jc describe    &#39;</span>\
             <span class="s">&#39;the sparse structure of Jacobian matrix.         &#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span>
        <span class="c"># integer sequence</span>
        <span class="n">extra_check</span><span class="o">=</span><span class="k">lambda</span> <span class="n">int_seq</span><span class="p">:</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span><span class="n">int_seq</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()),</span>

    <span class="n">ic</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Array which contains starting locations in jc.&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span>
        <span class="c"># integer sequence</span>
        <span class="n">extra_check</span><span class="o">=</span><span class="k">lambda</span> <span class="n">int_seq</span><span class="p">:</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span><span class="n">int_seq</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()),</span>

    <span class="c"># mb, nb describe the block-tridiagonal form of matrix.</span>
    <span class="n">mb</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Block size. Describe the block-tridiagonal form  &#39;</span>\
             <span class="s">&#39;of matrix A together with nb.                    &#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
        <span class="n">extra_check</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">),</span>

    <span class="n">nb</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Number of blocks in the main diagonal.           &#39;</span>\
             <span class="s">&#39;In each of the NB block-rows of the matrix P     &#39;</span>\
             <span class="s">&#39;(each consisting of MB consecutive rows), the    &#39;</span>\
             <span class="s">&#39;nonzero elements are to lie in three             &#39;</span>\
             <span class="s">&#39;consecutive MB by MB blocks.  In block-rows 2    &#39;</span>\
             <span class="s">&#39;through NB - 1, these are centered about the     &#39;</span>\
             <span class="s">&#39;main diagonal. In block-rows 1 and NB, they      &#39;</span>\
             <span class="s">&#39;are the diagonal blocks and the two blocks       &#39;</span>\
             <span class="s">&#39;adjacent to the diagonal block.  (Thus block     &#39;</span>\
             <span class="s">&#39;positions (1,3) and (NB,NB-2) can be nonzero.)   &#39;</span>\
             <span class="s">&#39;Require: mb&gt;=1, nb&gt;=4, mb*nb==neq.&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
        <span class="n">extra_check</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="o">&gt;=</span><span class="mi">4</span><span class="p">),</span>

    <span class="p">)</span>

<span class="kn">import</span> <span class="nn">ODE</span>
<span class="n">ODE</span><span class="o">.</span><span class="n">_parameters</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_parameters_Odepack</span><span class="p">)</span>


<div class="viewcode-block" id="Odepack"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Odepack">[docs]</a><span class="k">class</span> <span class="nc">Odepack</span><span class="p">(</span><span class="n">Solver</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a wrapper for seven solvers in Fortran package ODEPACK, which is</span>
<span class="sd">    available at netlib repository, www.netlib.org/odepack.</span>

<span class="sd">    Super class for the following set of solvers.</span>

<span class="sd">    *Solvers for explicitly given systems.*</span>
<span class="sd">    For each of the following solvers, it is assumed that the ODEs are</span>
<span class="sd">    given explicitly, so that the system can be written in the form</span>
<span class="sd">    du/dt = f(u,t), where u is a vector of dependent variables, and t</span>
<span class="sd">    is a scalar.</span>

<span class="sd">    ===============  ==========================================================</span>
<span class="sd">    Name             Description</span>
<span class="sd">    ===============  ==========================================================</span>
<span class="sd">       Lsode         A wrapper to dlsode, the basic solver in ODEPACK for</span>
<span class="sd">                     stiff and nonstiff systems of the form du/dt = f.</span>

<span class="sd">                     In the stiff case, it treats the Jacobian matrix df/du as</span>
<span class="sd">                     either a dense (full) or a banded matrix, and as either</span>
<span class="sd">                     user-supplied or internally approximated by difference</span>
<span class="sd">                     quotients.</span>

<span class="sd">                     It uses Adams methods (predictor-corrector) in the</span>
<span class="sd">                     nonstiff case, and Backward Differentiation Formula (BDF)</span>
<span class="sd">                     methods (the Gear methods) in the stiff case.  The linear</span>
<span class="sd">                     systems that arise are solved by direct methods (LU</span>
<span class="sd">                     factor/solve).</span>

<span class="sd">       Lsodes        solves systems du/dt = f, and in the stiff case</span>
<span class="sd">                     treats Jacobian matrix in general sparse form. It can</span>
<span class="sd">                     determine the sparsity structure on its own, or optionally</span>
<span class="sd">                     accepts this information from the user.</span>
<span class="sd">                     It then uses parts of the Yale Sparse Matrix Package (YSMP)</span>
<span class="sd">                     to solve the linear systems that arise, by a sparse</span>
<span class="sd">                     (direct) LU factorization/ backsolve method.</span>

<span class="sd">       Lsoda         solves systems du/dt = f, with a dense or banded</span>
<span class="sd">                     Jacobian when the problem is stiff, but it automatically</span>
<span class="sd">                     selects between nonstiff (Adams) and stiff (BDF)</span>
<span class="sd">                     methods. It uses the nonstiff method initially, and</span>
<span class="sd">                     dynamically monitors data in order to decide which</span>
<span class="sd">                     method to use.</span>

<span class="sd">       Lsodar        a variant of Lsoda with a rootfinding capability added.</span>
<span class="sd">                     Thus it solves problems du/dt = f with dense or banded</span>
<span class="sd">                     Jacobian and automatic method selection, and at the same</span>
<span class="sd">                     time, it finds the roots of any of a set of given functions</span>
<span class="sd">                     of the form g(u,t).  This is often useful for finding stop</span>
<span class="sd">                     conditions, or for finding points at which a switch</span>
<span class="sd">                     is to be made in the function f.</span>
<span class="sd">    ===============  ==========================================================</span>

<span class="sd">     *Solvers for linearly implicit systems.*</span>
<span class="sd">     The following solvers treat systems in the linearly implicit form::</span>

<span class="sd">            A(u,t) du/dt = g(u,t),</span>

<span class="sd">     where A is a square matrix, i.e., with the derivative</span>
<span class="sd">     du/dt implicit, but linearly so.</span>
<span class="sd">     These solvers allow A to be singular, in which case the system is a</span>
<span class="sd">     differential-algebraic equation (DAE) system.</span>
<span class="sd">     In that case, the user must be very careful to supply a well-posed</span>
<span class="sd">     problem with consistent initial conditions.</span>

<span class="sd">    ===============  ==========================================================</span>
<span class="sd">    Name             Description</span>
<span class="sd">    ===============  ==========================================================</span>
<span class="sd">       Lsodi         solves linearly implicit systems in which the</span>
<span class="sd">                     matrices involved (A, dg/du, and d(A du/dt)/du) are all</span>
<span class="sd">                     assumed to be either dense or banded.</span>

<span class="sd">       Lsodibt       solves linearly implicit systems in which the matrices</span>
<span class="sd">                     involved are all assumed to be block-tridiagonal.  Linear</span>
<span class="sd">                     systems are solved by the LU method.</span>

<span class="sd">       Lsodis        solves linearly implicit systems in which the</span>
<span class="sd">                     matrices involved are all assumed to be sparse.</span>
<span class="sd">                     Either determines the sparsity structure or accepts it from</span>
<span class="sd">                     the user, and uses parts of the Yale Sparse Matrix Package</span>
<span class="sd">                     to solve the linear systems that arise, by a direct method.</span>
<span class="sd">    ===============  ==========================================================</span>

<span class="sd">    *Note*: It is encouraged that users provide a F2PY-compiled Fortran</span>
<span class="sd">    subroutine or a multi-line string in Fortran code to define</span>
<span class="sd">    user-supplied function. This would help to improve efficiency.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Default parameter-list for all solvers in OdePack</span>
    <span class="c"># Note: f &amp; jac are not valid in some specific solvers.</span>

    <span class="n">_optional_parameters</span> <span class="o">=</span> <span class="n">Solver</span><span class="o">.</span><span class="n">_optional_parameters</span> <span class="o">+</span> \
        <span class="p">[</span><span class="s">&#39;atol&#39;</span><span class="p">,</span> <span class="s">&#39;rtol&#39;</span><span class="p">,</span> <span class="s">&#39;adams_or_bdf&#39;</span><span class="p">,</span> <span class="s">&#39;nsteps&#39;</span><span class="p">,</span> <span class="s">&#39;first_step&#39;</span><span class="p">,</span> <span class="s">&#39;min_step&#39;</span><span class="p">,</span>
         <span class="s">&#39;max_step&#39;</span><span class="p">,</span> <span class="s">&#39;iter_method&#39;</span><span class="p">,</span> <span class="s">&#39;lrw&#39;</span><span class="p">,</span> <span class="s">&#39;liw&#39;</span><span class="p">]</span>

    <span class="c"># Error messages to print out,</span>
    <span class="c"># corresponding to different values of return status-flag.</span>
    <span class="n">_error_messages</span> <span class="o">=</span> <span class="p">{</span>\
    <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    An excessive amount of work (more than &quot;max_step&quot; steps) was done on this</span>
<span class="s">    call, before completing the requested task, but the integration was</span>
<span class="s">    otherwise successful as far as &#39;&#39;&#39;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    Too much accuracy was requested for the precision of the machine being</span>
<span class="s">    used.  To continue, the tolerance parameters must be reset. This was</span>
<span class="s">    detected before completing the requested task, but the integration was</span>
<span class="s">    successful as far as &#39;&#39;&#39;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">3</span><span class="p">:</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    Illegal input was detected, before taking any integration steps.</span>
<span class="s">    Current T is &#39;&#39;&#39;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">4</span><span class="p">:</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    There were repeated error-test failures on one attempted step, before</span>
<span class="s">    completing the requested task. The problem may have a singularity, or the</span>
<span class="s">    input may be inappropriate, but integration was successful as far as &#39;&#39;&#39;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">5</span><span class="p">:</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    There were repeated convergence-test failures on one attempted step, before</span>
<span class="s">    completing the requested task. This may be caused by an inaccurate Jacobian</span>
<span class="s">    matrix, if one is being used. But integration was successful as far as&#39;&#39;&#39;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">6</span><span class="p">:</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    EWT(i) became zero for some i during the integration. Pure relative error</span>
<span class="s">    control (ATOL(i)=0.0) was requested on a variable which has now vanished.</span>
<span class="s">    The integration was successful as far as &#39;&#39;&#39;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">7</span><span class="p">:</span><span class="s">&#39;&#39;</span><span class="p">}</span>

    <span class="n">_extra_args_fortran</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c"># Dictionary for extra parameters in all external functions in Fortran</span>
    <span class="c"># package ODEPACK.</span>
    <span class="c"># For example, _extra_args_fortran[&#39;jac_extra_args&#39;] is defined as</span>
    <span class="c"># (&#39;self.ml&#39;,&#39;self.mu&#39;) when jac is a banded jacobian matrix.</span>

    <span class="n">_iwork_index</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">:</span><span class="s">&#39;order&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="s">&#39;nsteps&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span><span class="s">&#39;max_hnil&#39;</span><span class="p">}</span>
    <span class="c"># Index in iwork_in to supply optional inputs.</span>
    <span class="n">_rwork_index</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">:</span><span class="s">&#39;first_step&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="s">&#39;max_step&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span><span class="s">&#39;min_step&#39;</span><span class="p">}</span>
    <span class="c"># Index in rwork_in to supply optional inputs.</span>

<div class="viewcode-block" id="Odepack.adjust_parameters"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Odepack.adjust_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Special settings for properties of input parameters.&quot;&quot;&quot;</span>
        <span class="c"># If f is input in form of f(u,t), wrap f to f_f77 for Fortran code.</span>
        <span class="k">if</span> <span class="s">&#39;f&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;f&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;f&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;f&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;f_f77&#39;</span>
        <span class="c"># If f is input in form of f(t,u),</span>
        <span class="c"># wrap f_f77 to the general form f(u,t) for switch_to()</span>
        <span class="k">if</span> <span class="s">&#39;f_f77&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;f_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;f_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;f_f77&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;f&#39;</span>

        <span class="c"># These default values are unnecessary in ODEPACK.</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;order&#39;</span><span class="p">,</span> <span class="s">&#39;jac&#39;</span><span class="p">,</span> <span class="s">&#39;nsteps&#39;</span><span class="p">,</span> <span class="s">&#39;seth&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">:</span>
                <span class="k">if</span> <span class="s">&#39;default&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s">&#39;default&#39;</span><span class="p">]</span>

        <span class="c"># If jac is input in form of jac(u,t),</span>
        <span class="c"># wrap jac to jac_f77 for Fortran code.</span>
        <span class="k">if</span> <span class="s">&#39;jac&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac&#39;</span><span class="p">][</span><span class="s">&#39;returnArrayOrder&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;Fortran&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;jac_f77&#39;</span>
        <span class="c"># If jac is input in form of jac(t,u),</span>
        <span class="c"># wrap jac_f77 to the general form jac(u,t) for switch_to().</span>
        <span class="k">if</span> <span class="s">&#39;jac_f77&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_f77&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;jac&#39;</span>
        <span class="n">Solver</span><span class="o">.</span><span class="n">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="Odepack.initialize"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Odepack.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Import extension module _odesolver and check that it exists.&#39;&#39;&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">_odepack</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_odepack</span> <span class="o">=</span> <span class="n">_odepack</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s">&#39;Cannot find the extension module _odepack.</span><span class="se">\n</span><span class="s">Run setup.py again and investigate why _odepack.so was not successfully built.&#39;</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Odepack.check_liwlrw"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Odepack.check_liwlrw">[docs]</a>    <span class="k">def</span> <span class="nf">check_liwlrw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        If the lengths of work arrays are specified by users, check whether</span>
<span class="sd">        they are greater than the required lengths of Fortran solvers. &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;liw&#39;</span><span class="p">,</span> <span class="s">&#39;lrw&#39;</span><span class="p">):</span>
            <span class="n">min_value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">+</span><span class="s">&#39;_min&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">min_value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">min_value</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&#39;&#39;&#39;</span>
<span class="s">          Insufficient input! &quot;</span><span class="si">%s</span><span class="s">&quot;=</span><span class="si">%d</span><span class="s"> are reset to be the minimum size = </span><span class="si">%d</span><span class="s"> &#39;&#39;&#39;</span>\
                        <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">min_value</span><span class="p">)</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">min_value</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Odepack.check_tol"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Odepack.check_tol">[docs]</a>    <span class="k">def</span> <span class="nf">check_tol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        atol &amp; rtol should be defined as scalars or vectors with length neq.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;atol&#39;</span><span class="p">,</span> <span class="s">&#39;rtol&#39;</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">,</span> \
                    <span class="s">&#39;</span><span class="si">%s</span><span class="s"> has an illegal length = </span><span class="si">%d</span><span class="s">! Valid length is </span><span class="si">%d</span><span class="s"> or 1.&#39;</span> \
                    <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Odepack.check_pars"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Odepack.check_pars">[docs]</a>    <span class="k">def</span> <span class="nf">check_pars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Some pairs of parameters should be input simutaneously.&#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">pars</span> <span class="ow">in</span> <span class="p">((</span><span class="s">&#39;ia&#39;</span><span class="p">,</span> <span class="s">&#39;ja&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;ic&#39;</span><span class="p">,</span> <span class="s">&#39;jc&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;ml&#39;</span><span class="p">,</span> <span class="s">&#39;mu&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;mb&#39;</span><span class="p">,</span> <span class="s">&#39;nb&#39;</span><span class="p">)):</span>
            <span class="n">arg_a</span><span class="p">,</span> <span class="n">arg_b</span> <span class="o">=</span> <span class="n">pars</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_a</span><span class="p">)</span> <span class="o">+</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_b</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span><span class="s">&#39;</span><span class="se">\</span>
<span class="s">        Error! </span><span class="si">%s</span><span class="s"> and </span><span class="si">%s</span><span class="s"> have to be input simutaneously!&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">arg_a</span><span class="p">,</span> <span class="n">arg_b</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Odepack.check_iaja"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Odepack.check_iaja">[docs]</a>    <span class="k">def</span> <span class="nf">check_iaja</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        ia, ja, ic, jc are optional inputs to describe arbitrary sparse</span>
<span class="sd">        structure of matrix.</span>

<span class="sd">        ia &amp; ja are used in dlsodes,dlsodis.</span>
<span class="sd">        ic &amp; jc are used only in dlsodis.</span>

<span class="sd">        There are special requirements for their values.</span>
<span class="sd">        len(ia/ic) = neq + 1; (ia/ic)[0] = 1; (ia/ic)[-1] = 1 + len(ja/jc)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">pars</span> <span class="ow">in</span> <span class="p">((</span><span class="s">&#39;ia&#39;</span><span class="p">,</span><span class="s">&#39;ja&#39;</span><span class="p">),(</span><span class="s">&#39;ic&#39;</span><span class="p">,</span><span class="s">&#39;jc&#39;</span><span class="p">)):</span>
            <span class="n">arg_a</span><span class="p">,</span> <span class="n">arg_b</span> <span class="o">=</span> <span class="n">pars</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_a</span><span class="p">):</span>
                <span class="n">array_a</span><span class="p">,</span><span class="n">array_b</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_a</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_b</span><span class="p">)</span>
                <span class="n">err_messages</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">        Illegal input! </span><span class="si">%s</span><span class="s">(=</span><span class="si">%s</span><span class="s">) should have a length </span><span class="si">%d</span><span class="s"> (= neq+1)!</span><span class="se">\n\n</span><span class="s">&#39;&#39;&#39;</span>\
                   <span class="o">%</span> <span class="p">(</span><span class="n">arg_a</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">array_a</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
                                <span class="sd">&#39;&#39;&#39;\</span>
<span class="sd">        Illegal input! %s[0](=%d) should be equal to 1!\n\n&#39;&#39;&#39;</span>\
                   <span class="o">%</span> <span class="p">(</span><span class="n">arg_a</span><span class="p">,</span> <span class="n">array_a</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                <span class="sd">&#39;&#39;&#39;\</span>
<span class="sd">        Illegal input! %s[neq+1](=%d) should be equal to 1</span>
<span class="sd">        plus the length of %s(=%d), which represents the total</span>
<span class="sd">        number of nonzero locations assumed in the matrix.\n&#39;&#39;&#39;</span> \
                   <span class="o">%</span> <span class="p">(</span><span class="n">arg_a</span><span class="p">,</span> <span class="n">array_a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">arg_b</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">array_b</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
                <span class="n">iaja_check</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">array_a</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                              <span class="n">array_a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">,</span>
                              <span class="n">array_a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">array_b</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">error_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">iaja_check</span><span class="p">[</span><span class="n">error_index</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="n">err_messages</span><span class="p">[</span><span class="n">error_index</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Odepack.validate_data"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Odepack.validate_data">[docs]</a>    <span class="k">def</span> <span class="nf">validate_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Common validity check in Odepack.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c"># lower- &amp; upper-bound for banded jacobian in range [0,neq]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;ml&#39;</span><span class="p">,</span> <span class="s">&#39;mu&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s">&#39;range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">Solver</span><span class="o">.</span><span class="n">validate_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_tol</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_pars</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_iaja</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_liwlrw</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="Odepack.set_iwork_rwork"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Odepack.set_iwork_rwork">[docs]</a>    <span class="k">def</span> <span class="nf">set_iwork_rwork</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Initialize arrays for optional inputs, and calculate the</span>
<span class="sd">        required length of work arrays in Fortran code.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c"># calculate the required length of work arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_liw_min</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_lrw_min</span><span class="p">()</span>

        <span class="c"># Indices of optional inputs in work arrays</span>
        <span class="n">iwork_index</span><span class="p">,</span> <span class="n">rwork_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iwork_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rwork_index</span>

        <span class="c"># Initialize work arrays.</span>
        <span class="n">length_iwork_in</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">iwork_index</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">length_rwork_in</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">rwork_index</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iwork_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">length_iwork_in</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rwork_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">length_rwork_in</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="c"># Put optional inputs into work arrays with specified indices.</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">iwork_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iwork_in</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iwork_index</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">rwork_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rwork_in</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rwork_index</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="mf">0.</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Odepack.set_iopt"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Odepack.set_iopt">[docs]</a>    <span class="k">def</span> <span class="nf">set_iopt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Initialization for &quot;ipot&quot;, which is a flag to indicate whether optional</span>
<span class="sd">        parameters are specified in work arrays.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</div>
<div class="viewcode-block" id="Odepack.set_ydoti"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Odepack.set_ydoti">[docs]</a>    <span class="k">def</span> <span class="nf">set_ydoti</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        &quot;ydoti&quot; is an array used in linearly solvers.</span>
<span class="sd">        It has to be extended if its length is smaller than neq.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ydoti</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;ydoti&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="c"># flag to indicate whether ydoti is supplied</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ydoti_flag</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ydoti</span><span class="o">!=</span><span class="p">[])</span>
        <span class="c"># extend the length of &#39;ydoti&#39; to neq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ydoti</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ydoti</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">ydoti</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Odepack.set_liw_min"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Odepack.set_liw_min">[docs]</a>    <span class="k">def</span> <span class="nf">set_liw_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate the necessary length of integer work arrays when it is not</span>
<span class="sd">        specified explicitly by users.</span>
<span class="sd">        Different solvers have different formulas.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</div>
<div class="viewcode-block" id="Odepack.set_lrw_min"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Odepack.set_lrw_min">[docs]</a>    <span class="k">def</span> <span class="nf">set_lrw_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate the necessary length of real work arrays for Fortran code.</span>
<span class="sd">        Different solvers have different formulas.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</div>
<div class="viewcode-block" id="Odepack.set_extra_args"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Odepack.set_extra_args">[docs]</a>    <span class="k">def</span> <span class="nf">set_extra_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Setting for extra parameters of user-defined functions.&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="Odepack.set_jac"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Odepack.set_jac">[docs]</a>    <span class="k">def</span> <span class="nf">set_jac</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Set values for Jacobian matrix. In several solvers like Lsode,</span>
<span class="sd">        jacobian matrix could be supplied either in full form or in banded form.</span>

<span class="sd">        This function intends to tell from which kind of Jacobian matrix</span>
<span class="sd">        is specified.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="Odepack.set_dummy_functions"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Odepack.set_dummy_functions">[docs]</a>    <span class="k">def</span> <span class="nf">set_dummy_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Functions have to get dummy values before they are passed to extension</span>
<span class="sd">        module even if they are not involved in current solver.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;jac_f77&#39;</span><span class="p">,</span> <span class="s">&#39;f_f77&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="mf">0.</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_column_f77&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jac_column_f77</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">:</span> <span class="mf">0.</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;g_f77&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">g_f77</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(())</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;ng&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ng</span> <span class="o">=</span> <span class="mi">0</span>

</div>
<div class="viewcode-block" id="Odepack.set_iter_method"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Odepack.set_iter_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_iter_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Set proper values for method-choices when it is not specified</span>
<span class="sd">        explicitly.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</div>
<div class="viewcode-block" id="Odepack.initialize_for_solve"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Odepack.initialize_for_solve">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_for_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        In the long parameter-lists for solvers in ODEPACK, quite a few</span>
<span class="sd">        parameters can be set automatically with proper values depending</span>
<span class="sd">        on values of other parameters.</span>
<span class="sd">        In this function, all the parameters of this kind are initialized</span>
<span class="sd">        with proper values.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_iter_method</span><span class="p">()</span>     <span class="c"># method choice</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_wrapper</span><span class="p">()</span>        <span class="c"># wrap function parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_jac</span><span class="p">()</span>             <span class="c"># tell from which kind of jacobian matrix</span>
                                   <span class="c"># are supplied:  banded, full or None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_dummy_functions</span><span class="p">()</span> <span class="c"># pass dummy values to extension module</span>
                                   <span class="c"># for functions that are not involved</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_extra_args</span><span class="p">()</span>      <span class="c"># Extra parameters for external functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adams_or_bdf</span> <span class="o">==</span> <span class="s">&#39;bdf&#39;</span><span class="p">))</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> \
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;moss&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_iwork_rwork</span><span class="p">()</span>     <span class="c"># work arrays initialization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_iopt</span><span class="p">()</span>            <span class="c"># Flag for optional inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ydoti</span><span class="p">()</span>           <span class="c"># Extend length of array ydoti</span>
        <span class="c"># itol is a flag to indicate whether tolerance parameters are input</span>
        <span class="c"># as scarlars or vectors.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">itol</span> <span class="o">=</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rtol</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)))</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> \
            <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atol</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">Solver</span><span class="o">.</span><span class="n">initialize_for_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>   <span class="c"># Common settings in super class</span>
</div>
<div class="viewcode-block" id="Odepack.new_stepnr"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Odepack.new_stepnr">[docs]</a>    <span class="k">def</span> <span class="nf">new_stepnr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        When Fortran code returns a status &quot;istate==-1&quot;, it indicates that</span>
<span class="sd">        there are excessive amount of steps detected.</span>
<span class="sd">        Then we could try to increase &quot;nsteps&quot; to avoid this error.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">nsteps</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;nsteps&#39;</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nsteps</span> <span class="o">==</span> <span class="mi">2000</span><span class="p">:</span>    <span class="c"># The maximum step-amount has been reached</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s">&#39;&#39;&#39;</span>
<span class="s">        Failed iteration although step number has been set to 2000.</span>
<span class="s">        Please check your input.&#39;&#39;&#39;</span>
        <span class="n">mx_new</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nsteps</span><span class="o">+</span><span class="mi">200</span><span class="p">,</span> <span class="mi">2000</span><span class="p">)</span>
        <span class="c"># maximum limitation is set to 2000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsteps</span> <span class="o">=</span> <span class="n">mx_new</span>  <span class="c"># valid for the following steps</span>
        <span class="k">print</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">        Excessive amount of work detected!</span>
<span class="s">        Input step amount &quot;nsteps&quot;=</span><span class="si">%d</span><span class="s"> is not enough for iteration!</span>
<span class="s">        nsteps has been reset to </span><span class="si">%d</span><span class="s"> to avoid this error!&#39;&#39;&#39;</span>\
        <span class="o">%</span> <span class="p">(</span><span class="n">nsteps</span><span class="p">,</span> <span class="n">mx_new</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mx_new</span>
</div>
<div class="viewcode-block" id="Odepack.tol_multiply"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Odepack.tol_multiply">[docs]</a>    <span class="k">def</span> <span class="nf">tol_multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolsf</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This function is used to adjust tolerance parameters for Fortran part.</span>
<span class="sd">        When extension module returns a status &quot;istate&quot; as -2 or -3, it often</span>
<span class="sd">        indicates that there are excessive amount of steps detected.</span>
<span class="sd">        Then we could try to adjust tolerance settings with suggested factor</span>
<span class="sd">        to avoid this error.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">print</span> <span class="s">&#39;Tolerance is scaled by suggested factor </span><span class="si">%.2g</span><span class="s">&#39;&#39;&#39;</span> <span class="o">%</span> <span class="n">tolsf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rtol</span> <span class="o">*=</span> <span class="n">tolsf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atol</span> <span class="o">*=</span> <span class="n">tolsf</span>
</div>
<div class="viewcode-block" id="Odepack.expand_rwork"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Odepack.expand_rwork">[docs]</a>    <span class="k">def</span> <span class="nf">expand_rwork</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_lrw</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Length of real work array is smaller than actually required length.</span>
<span class="sd">	Then we could expand work array to avoid this error.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">print</span> <span class="s">&#39;The length of real work array has been reset to </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">new_lrw</span>
        <span class="k">if</span> <span class="n">expand</span><span class="p">:</span>          <span class="c"># Expand real arrays for linearly solvers</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rwork</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rwork</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">new_lrw</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">lrw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lrw</span> <span class="o">=</span> <span class="n">new_lrw</span>
</div>
<div class="viewcode-block" id="Odepack.expand_iwork"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Odepack.expand_iwork">[docs]</a>    <span class="k">def</span> <span class="nf">expand_iwork</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_liw</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Extension module return an actually required length for</span>
<span class="sd">        integer work array when it is too short.</span>
<span class="sd">	Then we could expand work array to required length to avoid this error.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">print</span> <span class="s">&#39;The length of integer work array has been reset to </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">new_liw</span>
        <span class="k">if</span> <span class="n">expand</span><span class="p">:</span>          <span class="c"># Expand integer arrays for linearly solvers</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iwork</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iwork</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">new_liw</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">liw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">liw</span> <span class="o">=</span> <span class="n">new_liw</span>
</div>
<div class="viewcode-block" id="Odepack.adjust_atol"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Odepack.adjust_atol">[docs]</a>    <span class="k">def</span> <span class="nf">adjust_atol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u_current</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Error tolerance tol(i) became zero for some i during integration,</span>
<span class="sd">        where tol = rtol(i) * u(i) + atol(i).</span>
<span class="sd">        It indicates that pure absolute tolerance (atol(i)=0.0) was requested.</span>
<span class="sd">        In order to avoid possible divide-zero-error, we could find the indices</span>
<span class="sd">        of zero items and adjust atol.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">u_current</span><span class="p">))</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">rtol</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">atol</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atol</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="c"># atol is set as a scalar float</span>
            <span class="c"># Convert scalar &quot;atol&quot; to be an array</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atol</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">itol</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tol</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">item</span> <span class="o">==</span> <span class="mf">0.</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">atol</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
                    <span class="c"># Increase absolute error</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">atol</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1e-8</span>
</div>
<div class="viewcode-block" id="Odepack.print_roots"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Odepack.print_roots">[docs]</a>    <span class="k">def</span> <span class="nf">print_roots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jroot</span><span class="p">,</span> <span class="n">t_current</span><span class="p">,</span> <span class="n">u_current</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Roots found at current T for some constraint functions. &#39;&#39;&#39;</span>
        <span class="n">g</span><span class="p">,</span> <span class="n">ng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_f77</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ng</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s">&#39;_cpointer&#39;</span><span class="p">):</span>  <span class="c"># ng is required if g is in Fortran</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">t_current</span><span class="p">,</span> <span class="n">u_current</span><span class="p">,</span> <span class="n">ng</span><span class="o">=</span><span class="n">ng</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">t_current</span><span class="p">,</span> <span class="n">u_current</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ng</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">jroot</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>   <span class="c"># found root for i-th constraint equation</span>
                <span class="k">print</span> <span class="s">&#39;&#39;&#39;</span>
<span class="s">        Root found at t = </span><span class="si">%g</span><span class="s"> for </span><span class="si">%d</span><span class="s">th constraint function in g&#39;&#39;&#39;</span> \
                    <span class="o">%</span> <span class="p">(</span><span class="n">t_current</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">value_ith</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">ng</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">value</span>
                <span class="k">print</span> <span class="s">&#39;Error in location of root is </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">value_ith</span>

</div>
<div class="viewcode-block" id="Odepack.solve"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Odepack.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_points</span><span class="p">,</span> <span class="n">terminate</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This function is involved for non-linearly solvers in ODEPACK, i.e.</span>
<span class="sd">        Lsode, Lsoda, Lsodar, and Lsodes.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">itermin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">terminate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span>   <span class="c"># flag to indicate dummy function</span>
        <span class="c"># Logical value cannot be transferred with f2py.</span>
        <span class="k">if</span> <span class="n">terminate</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>    <span class="c"># Dummy function</span>
            <span class="n">terminate_int</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">step_no</span><span class="p">,</span><span class="n">nt</span><span class="p">,</span><span class="n">neq</span><span class="p">:</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">terminate_int</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">step_no</span><span class="p">,</span><span class="n">nt</span><span class="p">,</span><span class="n">neq</span><span class="p">:</span> \
                <span class="nb">int</span><span class="p">(</span><span class="n">terminate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">step_no</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">time_points</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_for_solve</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">validate_data</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Invalid data in &quot;</span><span class="si">%s</span><span class="s">&quot;:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> \
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span><span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)))</span>

        <span class="c"># Convert class-name to name of subroutine,</span>
        <span class="c"># e.g. Lsode -&gt; dlsode or slsode</span>
        <span class="n">solver_name</span> <span class="o">=</span> <span class="s">&#39;d&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="n">step_no</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">)</span>
        <span class="n">nstop</span><span class="p">,</span> <span class="n">istate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">finished</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">False</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">order</span><span class="o">=</span><span class="s">&quot;Fortran&quot;</span><span class="p">)</span>
        <span class="n">tried</span> <span class="o">=</span> <span class="mi">0</span>        <span class="c"># Number of attempts</span>

        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">finished</span><span class="p">:</span>
            <span class="n">istate</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="c"># Extract _cpointers if functions are compiled with F2PY.</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f_f77</span><span class="p">,</span> <span class="s">&#39;_cpointer&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_f77</span><span class="p">)</span>
            <span class="n">g</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g_f77</span><span class="p">,</span> <span class="s">&#39;_cpointer&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_f77</span><span class="p">)</span>
            <span class="n">jac</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jac_f77</span><span class="p">,</span> <span class="s">&#39;_cpointer&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">jac_f77</span><span class="p">)</span>
            <span class="n">jac_column</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jac_column_f77</span><span class="p">,</span> <span class="s">&#39;_cpointer&#39;</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">jac_column_f77</span><span class="p">)</span>
            <span class="c"># call extension module</span>
            <span class="n">nstop</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">istate</span><span class="p">,</span> <span class="n">rinfo</span><span class="p">,</span> <span class="n">iinfo</span> <span class="o">=</span> \
                <span class="nb">apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_odepack</span><span class="o">.</span><span class="n">solve</span><span class="p">,</span>
                      <span class="p">(</span><span class="n">terminate_int</span><span class="p">,</span> <span class="n">itermin</span><span class="p">,</span> <span class="n">nstop</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">itol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rtol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atol</span><span class="p">,</span>
                       <span class="n">istate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iopt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rwork_in</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lrw</span><span class="p">,</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">iwork_in</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">liw</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">jac_column</span><span class="p">,</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">mf</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ng</span><span class="p">,</span> <span class="n">solver_name</span><span class="p">),</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">_extra_args_fortran</span><span class="p">)</span>
            <span class="n">tried</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">nstop</span> <span class="o">==</span> <span class="n">step_no</span><span class="p">:</span>    <span class="c"># successful</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">finished</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">tried</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">istate</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>         <span class="c"># roots founded for constraint equations</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">print_roots</span><span class="p">(</span><span class="n">iinfo</span><span class="p">[</span><span class="mi">17</span><span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">nstop</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">nstop</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">tried</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">istate</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">finished</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">tried</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">istate</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;Iteration stops at step Nr.</span><span class="si">%d</span><span class="s">,&quot;</span> <span class="o">%</span> <span class="n">nstop</span>
                <span class="k">print</span> <span class="s">&quot; when function TERMINATE return with True.&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">finished</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="n">istate</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>                   <span class="c"># Error occurs!</span>
                <span class="k">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">_error_messages</span><span class="p">[</span><span class="n">istate</span><span class="p">]</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">rinfo</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">istate</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>    <span class="c"># Increase maximum step-number.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">iwork_in</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_stepnr</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">iopt</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">istate</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>  <span class="c"># Multiply tolerance with suggested factor</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tol_multiply</span><span class="p">(</span><span class="n">rinfo</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">istate</span> <span class="o">==</span> <span class="o">-</span><span class="mi">3</span><span class="p">:</span>
                    <span class="c"># Illegal input was detected,</span>
                    <span class="c"># before taking any integration steps.</span>
                    <span class="k">if</span> <span class="n">iinfo</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">lrw</span><span class="p">:</span>   <span class="c"># Real work array is too short.</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">expand_rwork</span><span class="p">(</span><span class="n">iinfo</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="n">iinfo</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">liw</span><span class="p">:</span> <span class="c"># Integer work array is too short.</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">expand_iwork</span><span class="p">(</span><span class="n">iinfo</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="n">rinfo</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>       <span class="c"># suggested factor for tolerance</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tol_multiply</span><span class="p">(</span><span class="n">rinfo</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c"># Other cases with istate returned as -3</span>
                        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># Interrupt</span>
                <span class="k">elif</span> <span class="n">istate</span> <span class="o">==</span> <span class="o">-</span><span class="mi">6</span><span class="p">:</span>
                    <span class="c"># divide-zero-error when error(i) became 0 for some i</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">adjust_atol</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">nstop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">istate</span> <span class="o">==</span> <span class="o">-</span><span class="mi">7</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">solver_name</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;dlsoda&quot;</span><span class="p">,</span><span class="s">&quot;dlsodar&quot;</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">iinfo</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">lrw</span><span class="p">:</span>
                            <span class="c"># Real work array is too short.</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">expand_rwork</span><span class="p">(</span><span class="n">iinfo</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>
                        <span class="k">elif</span> <span class="n">iinfo</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">liw</span><span class="p">:</span>
                            <span class="c"># Integer work array is too short.</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">expand_iwork</span><span class="p">(</span><span class="n">iinfo</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">tried</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>     <span class="c"># prevent endless loop</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">nstart</span><span class="p">,</span> <span class="n">istate</span> <span class="o">=</span> <span class="n">nstop</span><span class="p">,</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:</span><span class="n">nstop</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">[:</span><span class="n">nstop</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span>
</div>
<div class="viewcode-block" id="Odepack.advance"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Odepack.advance">[docs]</a>    <span class="k">def</span> <span class="nf">advance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This function intends to one step forward for linearly solvers</span>
<span class="sd">        (Lsodi, Lsodis, Lsoibt) in ODEPACK.</span>
<span class="sd">        For these linearly solvers, if extra wrappers are added in Fortran</span>
<span class="sd">        code, there are often memory errors. Besides, sometimes there</span>
<span class="sd">        are unavoidable errors caused by bugs in the Ubuntu/Linux libraries</span>
<span class="sd">        as libc.</span>
<span class="sd">        To make these solvers more reliable on all platforms, this function</span>
<span class="sd">        is used to call solvers in ODEPACK (dlsodi, dlsodis, dlsoibt) directly</span>
<span class="sd">        without any wrappers in Fortran. However, this would lead to efficiency</span>
<span class="sd">        lost with long work arrays as input parameters for Fortran code.</span>
<span class="sd">        In Lsodi, Lsodis and Lsoibt, Solver.solve() would be applied to get the</span>
<span class="sd">        desired solution, which will direct to this function to step forward.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">itask</span> <span class="o">=</span> <span class="mi">1</span>   <span class="c"># initial status</span>
        <span class="n">istate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ydoti_flag</span>

        <span class="n">solver_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="c"># Convert class-name to name of subroutine, for example Lsodi -&gt; lsodi</span>

        <span class="n">neq</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="n">t</span><span class="p">,</span> <span class="n">t_next</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">res</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_f77</span><span class="p">,</span> <span class="s">&#39;_cpointer&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_f77</span><span class="p">)</span>
        <span class="n">adda</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;adda_</span><span class="si">%s</span><span class="s">_f77&#39;</span> <span class="o">%</span> <span class="n">solver_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">adda</span><span class="p">,</span> <span class="s">&#39;_cpointer&#39;</span><span class="p">):</span>
            <span class="n">adda</span> <span class="o">=</span> <span class="n">adda</span><span class="o">.</span><span class="n">_cpointer</span>
        <span class="n">jac</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_</span><span class="si">%s</span><span class="s">_f77&#39;</span> <span class="o">%</span> <span class="n">solver_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">jac</span><span class="p">,</span> <span class="s">&#39;_cpointer&#39;</span><span class="p">):</span>
            <span class="n">jac</span> <span class="o">=</span> <span class="n">jac</span><span class="o">.</span><span class="n">_cpointer</span>

        <span class="n">tried</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">tried</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>       <span class="c"># prevent endless loop</span>
            <span class="n">unew</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">istate</span><span class="p">,</span> <span class="n">iwork</span> <span class="o">=</span> <span class="nb">apply</span><span class="p">(</span>\
                <span class="nb">eval</span><span class="p">(</span><span class="s">&#39;self._odepack.d</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">solver_name</span><span class="p">),</span>\
                <span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">adda</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">neq</span><span class="p">,</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ydoti</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">t_next</span><span class="p">,</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">itol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rtol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atol</span><span class="p">,</span> <span class="n">itask</span><span class="p">,</span> <span class="n">istate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iopt</span><span class="p">,</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">rwork</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lrw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iwork</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">liw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mf</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_extra_args_fortran</span><span class="p">)</span>
            <span class="n">tried</span> <span class="o">+=</span> <span class="mi">1</span>
	    <span class="c"># &quot;istate&quot; indicates the returned status</span>
            <span class="k">if</span> <span class="n">istate</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c"># successful return status</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>       <span class="c"># Error occurs!</span>
                <span class="k">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">_error_messages</span><span class="p">[</span><span class="n">istate</span><span class="p">]</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rwork</span><span class="p">[</span><span class="mi">12</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">istate</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>    <span class="c"># Increase maximum step-number.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">iwork</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">iopt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_stepnr</span><span class="p">(),</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">istate</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>  <span class="c"># Multiply tolerance with suggested factor</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tol_multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rwork</span><span class="p">[</span><span class="mi">13</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">istate</span> <span class="o">==</span> <span class="o">-</span><span class="mi">3</span><span class="p">:</span>
                    <span class="c"># Illegal input was detected,</span>
                    <span class="c"># before taking any integration steps.</span>
                    <span class="k">if</span> <span class="n">iwork</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">lrw</span><span class="p">:</span>   <span class="c"># Real work array is too short.</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">expand_rwork</span><span class="p">(</span><span class="n">iwork</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="n">expand</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">iwork</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">liw</span><span class="p">:</span> <span class="c"># Integer work array is too short</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">expand_iwork</span><span class="p">(</span><span class="n">iwork</span><span class="p">[</span><span class="mi">17</span><span class="p">],</span> <span class="n">expand</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c"># Other abnormal cases with istate returned as -3</span>
                        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># Interrupt</span>
                <span class="k">elif</span> <span class="n">istate</span> <span class="o">==</span> <span class="o">-</span><span class="mi">6</span><span class="p">:</span>
                    <span class="c"># divide-zero-error when error(i) became 0 for some i</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">adjust_atol</span><span class="p">(</span><span class="n">unew</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>   <span class="c"># Unavoidable interrupts</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c">#  Interrupt</span>
                <span class="n">istate</span> <span class="o">=</span> <span class="mi">1</span>
	<span class="k">return</span> <span class="n">unew</span>

<span class="c">### end of class Odepack ###</span>
</div></div>
<div class="viewcode-block" id="Lsode"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsode">[docs]</a><span class="k">class</span> <span class="nc">Lsode</span><span class="p">(</span><span class="n">Odepack</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Basic Solver in ODEPACK package.</span>
<span class="sd">    Solves the initial-value problem for stiff or nonstiff systems</span>
<span class="sd">    of first-order ODE::</span>

<span class="sd">        du/dt = f(u,t)</span>

<span class="sd">    or, in component form::</span>

<span class="sd">        du(i)/dt = f(u,t)[i] for i in 1,...,neq</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">quick_description</span> <span class="o">=</span> <span class="s">&quot;LSODE solver for a stiff or nonstiff system&quot;</span>

    <span class="n">_optional_parameters</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_optional_parameters</span> <span class="o">+</span> \
        <span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">,</span> <span class="s">&#39;jac_banded_f77&#39;</span><span class="p">,</span> <span class="s">&#39;ml&#39;</span><span class="p">,</span> <span class="s">&#39;mu&#39;</span><span class="p">,</span> <span class="s">&#39;jac&#39;</span><span class="p">,</span> <span class="s">&#39;jac_f77&#39;</span><span class="p">,</span> <span class="s">&#39;order&#39;</span><span class="p">,</span>
         <span class="s">&#39;f_f77&#39;</span><span class="p">]</span>

    <span class="n">_iwork_index</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_iwork_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;ml&#39;</span><span class="p">,</span> <span class="s">&#39;mu&#39;</span>
    <span class="n">_rwork_index</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_rwork_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">_extra_args_fortran</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="Lsode.adjust_parameters"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsode.adjust_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Properties for new parameters in this solver.&quot;&quot;&quot;</span>
       <span class="c"># If jac_banded is input in form of jac(u,t,ml,mu),</span>
        <span class="c"># wrap jac_banded to jac_banded_f77 for Fortran code</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t,ml,mu&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u,ml,mu&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">][</span><span class="s">&#39;returnArrayOrder&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;Fortran&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;jac_banded_f77&#39;</span>
        <span class="c"># If jac_banded is input in form of jac(t,u,ml,mu),</span>
        <span class="c"># wrap jac_banded_f77 to the general form jac_banded(u,t,ml,mu)</span>
        <span class="c"># for switch_to().</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u,ml,mu&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t,ml,mu&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;jac_banded&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;iter_method&#39;</span><span class="p">][</span><span class="s">&#39;range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;iter_method&#39;</span><span class="p">][</span><span class="s">&#39;condition-list&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="p">{</span><span class="s">&#39;1&#39;</span><span class="p">:[(</span><span class="s">&#39;jac&#39;</span><span class="p">,</span><span class="s">&#39;jac_f77&#39;</span><span class="p">),],</span>\
                 <span class="s">&#39;4&#39;</span><span class="p">:[</span><span class="s">&#39;ml&#39;</span><span class="p">,</span><span class="s">&#39;mu&#39;</span><span class="p">,(</span><span class="s">&#39;jac_banded&#39;</span><span class="p">,</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">)],</span>\
                 <span class="s">&#39;5&#39;</span><span class="p">:(</span><span class="s">&#39;ml&#39;</span><span class="p">,</span><span class="s">&#39;mu&#39;</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;iter_method&#39;</span><span class="p">][</span><span class="s">&#39;help&#39;</span><span class="p">]</span> <span class="o">=</span> \
            <span class="s">&#39;Corrector iteration method choice with 6 possible&#39;</span>\
            <span class="s">&#39;values:                                          &#39;</span>\
            <span class="s">&#39;   0: Functional iteration without any jacobian  &#39;</span>\
            <span class="s">&#39;      matrix involved.                           &#39;</span>\
            <span class="s">&#39;   1: Chord iteration with user-supplied full    &#39;</span>\
            <span class="s">&#39;      Jacobian.                                  &#39;</span>\
            <span class="s">&#39;   2: Chord iteration with internally generated  &#39;</span>\
            <span class="s">&#39;      full Jacobian matrix.                      &#39;</span>\
            <span class="s">&#39;   3: Chord iteration with internally generated  &#39;</span>\
            <span class="s">&#39;      diagonal Jacobian matrix.                  &#39;</span>\
            <span class="s">&#39;   4: Chord iteration with user-supplied banded  &#39;</span>\
            <span class="s">&#39;      Jacobian matrix.                           &#39;</span>\
            <span class="s">&#39;   5: Chord iteration with internally generated  &#39;</span>\
            <span class="s">&#39;      banded Jacobian matrix.                    &#39;</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsode.set_extra_args"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsode.set_extra_args">[docs]</a>    <span class="k">def</span> <span class="nf">set_extra_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="c"># ml &amp; mu are required to be extra parameters for banded Jacobian.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ml&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;mu&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> \
                    <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jac_f77</span><span class="p">,</span> <span class="s">&#39;_cpointer&#39;</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_extra_args_fortran</span> <span class="p">[</span><span class="s">&#39;jac_extra_args&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ml</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">set_extra_args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsode.set_iter_method"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsode.set_iter_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_iter_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;iter_method&#39;</span><span class="p">):</span>
            <span class="n">with_ml_mu</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;ml&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;mu&#39;</span><span class="p">)</span>
            <span class="n">with_jac_banded</span> <span class="o">=</span> \
                <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_banded&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_banded_f77&#39;</span><span class="p">)</span>
            <span class="n">with_jac_full</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_f77&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">with_ml_mu</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">=</span> <span class="mi">4</span> <span class="k">if</span> <span class="n">with_jac_banded</span> <span class="k">else</span> <span class="mi">5</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">with_jac_full</span> <span class="k">else</span> <span class="mi">2</span>
</div>
<div class="viewcode-block" id="Lsode.set_jac"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsode.set_jac">[docs]</a>    <span class="k">def</span> <span class="nf">set_jac</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="ow">is</span> <span class="mi">4</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jac_f77</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jac_banded_f77</span>
</div>
<div class="viewcode-block" id="Lsode.set_liw_min"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsode.set_liw_min">[docs]</a>    <span class="k">def</span> <span class="nf">set_liw_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">liw_min</span> <span class="o">=</span> <span class="mi">20</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,)</span> <span class="k">else</span> <span class="mi">20</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span>
</div>
<div class="viewcode-block" id="Lsode.set_lrw_min"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsode.set_lrw_min">[docs]</a>    <span class="k">def</span> <span class="nf">set_lrw_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mf_length</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">:(</span><span class="mi">20</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mi">11</span><span class="p">:(</span><span class="mi">22</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="mi">12</span><span class="p">:(</span><span class="mi">22</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="mi">13</span><span class="p">:(</span><span class="mi">22</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>\
                     <span class="mi">14</span><span class="p">:(</span><span class="mi">22</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="mi">15</span><span class="p">:(</span><span class="mi">22</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="mi">20</span><span class="p">:(</span><span class="mi">20</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mi">21</span><span class="p">:(</span><span class="mi">22</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>\
                     <span class="mi">22</span><span class="p">:(</span><span class="mi">22</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="mi">23</span><span class="p">:(</span><span class="mi">22</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mi">24</span><span class="p">:(</span><span class="mi">22</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mi">25</span><span class="p">:(</span><span class="mi">22</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">)}</span>
        <span class="n">lrw_arg</span> <span class="o">=</span> <span class="n">mf_length</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mf</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span> <span class="o">=</span> <span class="n">lrw_arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">*</span><span class="n">lrw_arg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">lrw_arg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mf</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">24</span><span class="p">,</span><span class="mi">25</span><span class="p">):</span>  <span class="c"># user-supplied banded jacobian matrics</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ml</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span>
</div>
<div class="viewcode-block" id="Lsode.set_iopt"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsode.set_iopt">[docs]</a>    <span class="k">def</span> <span class="nf">set_iopt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iopt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iwork_in</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> \
                            <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rwork_in</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>


<span class="c">### End of Lsode ###</span>

</div></div>
<div class="viewcode-block" id="Lsoda"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsoda">[docs]</a><span class="k">class</span> <span class="nc">Lsoda</span><span class="p">(</span><span class="n">Odepack</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A variant version of the DLSODE package.</span>
<span class="sd">    It switches automatically between stiff and nonstiff methods.</span>
<span class="sd">    This means that the user does not have to determine whether the problem</span>
<span class="sd">    is stiff or not, and the solver will automatically choose the appropriate</span>
<span class="sd">    method.  It always starts with the nonstiff method.</span>
<span class="sd">    Solves the initial-value problem for stiff or nonstiff systems of</span>
<span class="sd">    first-order ODE::</span>

<span class="sd">        du/dt = f(u,t)</span>

<span class="sd">    or, in component form::</span>

<span class="sd">        du(i)/dt = f(u,t)[i] for i in 1,...,neq</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">quick_description</span> <span class="o">=</span> <span class="s">&quot;LSODA solver with stiff-nonstiff auto shift&quot;</span>

    <span class="n">_optional_parameters</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_optional_parameters</span> <span class="o">+</span> \
        <span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">,</span> <span class="s">&#39;jac_banded_f77&#39;</span><span class="p">,</span> <span class="s">&#39;ml&#39;</span><span class="p">,</span> <span class="s">&#39;mu&#39;</span><span class="p">,</span> <span class="s">&#39;jac&#39;</span><span class="p">,</span> <span class="s">&#39;jac_f77&#39;</span><span class="p">,</span>
         <span class="s">&#39;max_ordn&#39;</span><span class="p">,</span> <span class="s">&#39;max_ords&#39;</span><span class="p">,</span> <span class="s">&#39;f_f77&#39;</span><span class="p">]</span>


    <span class="n">_iwork_index</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_iwork_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;ml&#39;</span><span class="p">,</span> <span class="s">&#39;mu&#39;</span>
    <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;max_ordn&#39;</span><span class="p">,</span> <span class="s">&#39;max_ords&#39;</span>
    <span class="n">_rwork_index</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_rwork_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">_error_messages</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_error_messages</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">_error_messages</span><span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span>
<span class="s">    Length of RWORK or IWORK are too small to proceed, but the integration</span>
<span class="s">    was successful as far as &#39;&#39;&#39;</span>

<div class="viewcode-block" id="Lsoda.adjust_parameters"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsoda.adjust_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Properties for new parameters in this solver.&quot;&quot;&quot;</span>
        <span class="c"># If jac_banded is input in form of jac(u,t,ml,mu),</span>
        <span class="c"># wrap jac_banded to jac_banded_f77 for Fortran code</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t,ml,mu&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u,ml,mu&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">][</span><span class="s">&#39;returnArrayOrder&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;Fortran&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;jac_banded_f77&#39;</span>
        <span class="c"># If jac_banded is input in form of jac(t,u,ml,mu),</span>
        <span class="c"># wrap jac_banded_f77 to the general form jac_banded(u,t,ml,mu)</span>
        <span class="c"># for switch_to().</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u,ml,mu&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t,ml,mu&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;jac_banded&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;iter_method&#39;</span><span class="p">][</span><span class="s">&#39;range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;iter_method&#39;</span><span class="p">][</span><span class="s">&#39;condition-list&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="p">{</span><span class="s">&#39;1&#39;</span><span class="p">:[(</span><span class="s">&#39;jac&#39;</span><span class="p">,</span><span class="s">&#39;jac_f77&#39;</span><span class="p">),],</span>
                 <span class="s">&#39;4&#39;</span><span class="p">:[(</span><span class="s">&#39;jac_banded&#39;</span><span class="p">,</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">),</span><span class="s">&#39;ml&#39;</span><span class="p">,</span><span class="s">&#39;mu&#39;</span><span class="p">],</span>
                 <span class="s">&#39;5&#39;</span><span class="p">:(</span><span class="s">&#39;ml&#39;</span><span class="p">,</span><span class="s">&#39;mu&#39;</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;iter_method&#39;</span><span class="p">][</span><span class="s">&#39;help&#39;</span><span class="p">]</span> <span class="o">=</span> \
            <span class="s">&#39;Jacobian type choice with 4 possible values:     &#39;</span>\
            <span class="s">&#39;   1:   User-supplied full jacobian matrix       &#39;</span>\
            <span class="s">&#39;   2:   Internally generated full jacobian       &#39;</span>\
            <span class="s">&#39;         --&gt; Default value                       &#39;</span>\
            <span class="s">&#39;   4:   User-supplied banded Jacobian matrix     &#39;</span>\
            <span class="s">&#39;   5:   Internally generated banded Jacobian     &#39;</span>\
            <span class="s">&#39;        matrix                                   &#39;</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Lsoda.set_extra_args"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsoda.set_extra_args">[docs]</a>    <span class="k">def</span> <span class="nf">set_extra_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="c"># ml &amp; mu are required to be extra parameters for banded Jacobian.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ml&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;mu&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> \
                    <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jac_f77</span><span class="p">,</span> <span class="s">&#39;_cpointer&#39;</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_extra_args_fortran</span> <span class="p">[</span><span class="s">&#39;jac_extra_args&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ml</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">set_extra_args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsoda.set_iter_method"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsoda.set_iter_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_iter_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;iter_method&#39;</span><span class="p">):</span>
            <span class="n">with_ml_mu</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;ml&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;mu&#39;</span><span class="p">)</span>
            <span class="n">with_jac_banded</span> <span class="o">=</span> \
                <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_banded&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_banded_f77&#39;</span><span class="p">)</span>
            <span class="n">with_jac_full</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_f77&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">with_ml_mu</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">=</span> <span class="mi">4</span> <span class="k">if</span> <span class="n">with_jac_banded</span> <span class="k">else</span> <span class="mi">5</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">with_jac_full</span> <span class="k">else</span> <span class="mi">2</span>
</div>
<div class="viewcode-block" id="Lsoda.set_jac"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsoda.set_jac">[docs]</a>    <span class="k">def</span> <span class="nf">set_jac</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="ow">is</span> <span class="mi">4</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jac_f77</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jac_banded_f77</span>
</div>
<div class="viewcode-block" id="Lsoda.set_liw_min"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsoda.set_liw_min">[docs]</a>    <span class="k">def</span> <span class="nf">set_liw_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">liw_min</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span>
</div>
<div class="viewcode-block" id="Lsoda.set_lrw_min"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsoda.set_lrw_min">[docs]</a>    <span class="k">def</span> <span class="nf">set_lrw_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">+</span> <span class="mi">16</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span><span class="p">,</span> <span class="mi">22</span> <span class="o">+</span> <span class="mi">9</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span><span class="p">,</span> \
                           <span class="mi">22</span> <span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span> <span class="o">+</span> \
                           <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ml</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Lsoda.set_iopt"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsoda.set_iopt">[docs]</a>    <span class="k">def</span> <span class="nf">set_iopt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iopt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iwork_in</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rwork_in</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">))</span>

<span class="c">### End of Lsoda ###</span>
</div></div>
<div class="viewcode-block" id="Lsodar"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodar">[docs]</a><span class="k">class</span> <span class="nc">Lsodar</span><span class="p">(</span><span class="n">Odepack</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A variant version of the DLSODE package.</span>
<span class="sd">    It differs from DLSODE in two ways.</span>

<span class="sd">    It switches automatically between stiff and nonstiff methods.</span>
<span class="sd">    This means that the user does not have to determine whether the</span>
<span class="sd">    problem is stiff or not, and the solver will automatically choose</span>
<span class="sd">    the appropriate method.  It always starts with the nonstiff method.</span>
<span class="sd">    It finds the root of at least one of a set of constraint functions</span>
<span class="sd">    g(i) of the independent and dependent variables.</span>
<span class="sd">    It finds only those roots for which some g(i), as a function of t,</span>
<span class="sd">    changes sign in the interval of integration.</span>
<span class="sd">    It then returns the solution at the root, if that occurs sooner</span>
<span class="sd">    than the specified stop condition, and otherwise returns the</span>
<span class="sd">    solution according to the specified stop condition.</span>
<span class="sd">    Solves the initial-value problem for stiff or nonstiff systems of</span>
<span class="sd">    first-order ODE::</span>

<span class="sd">       du/dt = f(u,t),</span>

<span class="sd">    or, in component form::</span>

<span class="sd">       du(i)/dt = f(u,t)[i] for i in 1,...,neq</span>

<span class="sd">    At the same time, it locates the roots of any of a set of functions::</span>

<span class="sd">       g(i) = g(i,t,u(1),...,u(NEQ))  (i = 1,...,ng).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">quick_description</span> <span class="o">=</span> <span class="s">&quot;LSODAR method with stiff-nonstiff auto shift&quot;</span>

    <span class="n">_optional_parameters</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_optional_parameters</span> <span class="o">+</span> \
        <span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">,</span> <span class="s">&#39;jac_banded_f77&#39;</span><span class="p">,</span> <span class="s">&#39;ml&#39;</span><span class="p">,</span> <span class="s">&#39;mu&#39;</span><span class="p">,</span> <span class="s">&#39;jac&#39;</span><span class="p">,</span> <span class="s">&#39;jac_f77&#39;</span><span class="p">,</span>
         <span class="s">&#39;max_ordn&#39;</span><span class="p">,</span> <span class="s">&#39;max_ords&#39;</span><span class="p">,</span> <span class="s">&#39;g&#39;</span><span class="p">,</span> <span class="s">&#39;g_f77&#39;</span><span class="p">,</span> <span class="s">&#39;ng&#39;</span><span class="p">,</span> <span class="s">&#39;f_f77&#39;</span><span class="p">]</span>

    <span class="n">_iwork_index</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_iwork_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;ml&#39;</span><span class="p">,</span> <span class="s">&#39;mu&#39;</span>
    <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;max_ordn&#39;</span><span class="p">,</span> <span class="s">&#39;max_ords&#39;</span>
    <span class="n">_rwork_index</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_rwork_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">_error_messages</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_error_messages</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">_error_messages</span><span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span>
<span class="s">    Length of RWORK or IWORK are too small to proceed, but the integration</span>
<span class="s">    was successful as far as &#39;&#39;&#39;</span>

<div class="viewcode-block" id="Lsodar.adjust_parameters"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodar.adjust_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Properties for new parameters in this solver.&quot;&quot;&quot;</span>
        <span class="c"># If jac_banded is input in form of jac(u,t,ml,mu),</span>
        <span class="c"># wrap jac_banded to jac_banded_f77 for Fortran code</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t,ml,mu&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u,ml,mu&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">][</span><span class="s">&#39;returnArrayOrder&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;Fortran&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;jac_banded_f77&#39;</span>
        <span class="c"># If jac_banded is input in form of jac(t,u,ml,mu),</span>
        <span class="c"># wrap jac_banded_f77 to the general form jac_banded(u,t,ml,mu)</span>
        <span class="c"># for switch_to().</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u,ml,mu&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t,ml,mu&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;jac_banded&#39;</span>

        <span class="c"># If g is input in form of g(u,t),</span>
        <span class="c"># wrap g to g_f77 for Fortran code.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;g&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;g&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;g&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;g_f77&#39;</span>
        <span class="c"># If g is input in form of g(t,u),</span>
        <span class="c"># wrap g_f77 to the general form g(u,t) for switch_to().</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;g_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;g_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;g_f77&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;g&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;iter_method&#39;</span><span class="p">][</span><span class="s">&#39;range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;iter_method&#39;</span><span class="p">][</span><span class="s">&#39;condition-list&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="p">{</span><span class="s">&#39;1&#39;</span><span class="p">:[(</span><span class="s">&#39;jac&#39;</span><span class="p">,</span><span class="s">&#39;jac_f77&#39;</span><span class="p">),],</span>
                 <span class="s">&#39;4&#39;</span><span class="p">:[(</span><span class="s">&#39;jac_banded&#39;</span><span class="p">,</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">),</span><span class="s">&#39;ml&#39;</span><span class="p">,</span><span class="s">&#39;mu&#39;</span><span class="p">],</span>
                 <span class="s">&#39;5&#39;</span><span class="p">:(</span><span class="s">&#39;ml&#39;</span><span class="p">,</span><span class="s">&#39;mu&#39;</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;iter_method&#39;</span><span class="p">][</span><span class="s">&#39;help&#39;</span><span class="p">]</span> <span class="o">=</span> \
            <span class="s">&#39;Jacobian type choice with 4 possible values:     &#39;</span>\
            <span class="s">&#39;1:   User-supplied full jacobian matrix          &#39;</span>\
            <span class="s">&#39;2:   Internally generated full jacobian          &#39;</span>\
            <span class="s">&#39;         --&gt; Default value                       &#39;</span>\
            <span class="s">&#39;4:   User-supplied banded Jacobian matrix        &#39;</span>\
            <span class="s">&#39;5:   Internally generated banded Jacobian matrix &#39;</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Lsodar.set_extra_args"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodar.set_extra_args">[docs]</a>    <span class="k">def</span> <span class="nf">set_extra_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="c"># ml &amp; mu are required to be extra parameters for banded Jacobian.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ml&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;mu&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> \
                    <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jac_f77</span><span class="p">,</span> <span class="s">&#39;_cpointer&#39;</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_extra_args_fortran</span> <span class="p">[</span><span class="s">&#39;jac_extra_args&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ml</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">set_extra_args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsodar.set_iter_method"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodar.set_iter_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_iter_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;iter_method&#39;</span><span class="p">):</span>
            <span class="n">with_ml_mu</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;ml&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;mu&#39;</span><span class="p">)</span>
            <span class="n">with_jac_banded</span> <span class="o">=</span> \
                <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_banded&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_banded_f77&#39;</span><span class="p">)</span>
            <span class="n">with_jac_full</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_f77&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">with_ml_mu</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">=</span> <span class="mi">4</span> <span class="k">if</span> <span class="n">with_jac_banded</span> <span class="k">else</span> <span class="mi">5</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">with_jac_full</span> <span class="k">else</span> <span class="mi">2</span>
</div>
<div class="viewcode-block" id="Lsodar.set_jac"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodar.set_jac">[docs]</a>    <span class="k">def</span> <span class="nf">set_jac</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="ow">is</span> <span class="mi">4</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jac_f77</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jac_banded_f77</span>
</div>
<div class="viewcode-block" id="Lsodar.set_liw_min"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodar.set_liw_min">[docs]</a>    <span class="k">def</span> <span class="nf">set_liw_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">liw_min</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span>
</div>
<div class="viewcode-block" id="Lsodar.set_lrw_min"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodar.set_lrw_min">[docs]</a>    <span class="k">def</span> <span class="nf">set_lrw_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">+</span> <span class="mi">16</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ng</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span><span class="p">,</span> <span class="mi">22</span> <span class="o">+</span> <span class="mi">9</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> \
                           <span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ng</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span><span class="p">,</span> \
                           <span class="mi">22</span> <span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ng</span> <span class="o">+</span> \
                           <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ml</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Lsodar.set_iopt"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodar.set_iopt">[docs]</a>    <span class="k">def</span> <span class="nf">set_iopt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iopt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iwork_in</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rwork_in</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Lsodar.solve"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodar.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_points</span><span class="p">,</span> <span class="n">terminate</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c"># ng is numbers of constraint-functions</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;g&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U0</span><span class="p">,</span><span class="n">time_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">size</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;g_f77&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g_f77</span><span class="p">,</span><span class="s">&#39;_cpointer&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">(</span><span class="n">time_points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">U0</span><span class="p">))</span><span class="o">.</span><span class="n">size</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ng&#39;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s">&#39;&#39;&#39;</span>
<span class="s">        Unsufficient input! ng must be specified if g is input as a</span>
<span class="s">        Fortran subroutine. &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">time_points</span><span class="p">,</span> <span class="n">terminate</span><span class="o">=</span><span class="n">terminate</span><span class="p">)</span>

<span class="c">### End of Lsodar ###</span>
</div></div>
<div class="viewcode-block" id="Lsodes"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodes">[docs]</a><span class="k">class</span> <span class="nc">Lsodes</span><span class="p">(</span><span class="n">Odepack</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A variant of the DLSODE package, and is intended for initial problems</span>
<span class="sd">    in which the Jacobian matrix df/du has an arbitrary sparse structure</span>
<span class="sd">    (when the problem is stiff)::</span>

<span class="sd">        du/dt = f(u,t),</span>

<span class="sd">    or, in component form::</span>

<span class="sd">        du(i)/dt = f(u,t)[i] for i in 1,...,neq</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">quick_description</span> <span class="o">=</span> <span class="s">&quot;LSODES solver for sparse Jacobians&quot;</span>

    <span class="n">_optional_parameters</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_optional_parameters</span> <span class="o">+</span> \
        <span class="p">[</span><span class="s">&#39;order&#39;</span><span class="p">,</span> <span class="s">&#39;moss&#39;</span><span class="p">,</span><span class="s">&#39;seth&#39;</span><span class="p">,</span> <span class="s">&#39;jac_column&#39;</span><span class="p">,</span> <span class="s">&#39;ia&#39;</span><span class="p">,</span> <span class="s">&#39;ja&#39;</span><span class="p">,</span> <span class="s">&#39;jac_column_f77&#39;</span><span class="p">,</span>
         <span class="s">&#39;f_f77&#39;</span><span class="p">]</span>

    <span class="n">_extra_args_fortran</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_error_messages</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_error_messages</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">_error_messages</span><span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    A fatal error return flag came from the sparse solver CDRV by way of DPRJS</span>
<span class="s">    or DSOLSS (numerical factorization or backsolve).  This should never happen.</span>
<span class="s">    The integration was successful as far as &#39;&#39;&#39;</span>


<div class="viewcode-block" id="Lsodes.adjust_parameters"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodes.adjust_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Properties for new parameters in this solver.&quot;&quot;&quot;</span>
        <span class="c"># If jac_column is input in form of jac(u,t,j),</span>
        <span class="c"># wrap jac_column to jac_column_f77(t,u,j-1) for Fortran code.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_column&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t,j-1,ia,ja&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_column&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u,j,ia,ja&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_column&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;jac_column_f77&#39;</span>
        <span class="c"># If jac_column is input in form of jac(t,u,j),</span>
        <span class="c"># wrap it to the general form jac_column(u,t,j) for switch_to().</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_column_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u,j+1&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_column_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t,j&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_column_f77&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;jac_column&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;moss&#39;</span><span class="p">][</span><span class="s">&#39;range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;moss&#39;</span><span class="p">][</span><span class="s">&#39;condition-list&#39;</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[(</span><span class="s">&#39;jac_column&#39;</span><span class="p">,</span> <span class="s">&#39;jac_column_f77&#39;</span><span class="p">),],</span> \
                         <span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;ia&#39;</span><span class="p">,</span> <span class="s">&#39;ja&#39;</span><span class="p">]}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;moss&#39;</span><span class="p">][</span><span class="s">&#39;help&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">           Method choice to obtain sparse structure with 3 possible</span>
<span class="s">           values:</span>
<span class="s">               0:   means the user has supplied IA, JA.</span>
<span class="s">               1:   means the user has supplied JAC_COLUMN and the</span>
<span class="s">                    sparse structure will be obtained from NEQ initial</span>
<span class="s">                    calls to JAC_COLUMN.</span>
<span class="s">               2:   means the sparse structure will be obtained from</span>
<span class="s">                    NEQ+1 initial calls to F.                    &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;iter_method&#39;</span><span class="p">][</span><span class="s">&#39;condition-list&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="p">{</span><span class="s">&#39;1&#39;</span><span class="p">:[(</span><span class="s">&#39;jac_column&#39;</span><span class="p">,</span><span class="s">&#39;jac_column_f77&#39;</span><span class="p">),],}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;iter_method&#39;</span><span class="p">][</span><span class="s">&#39;help&#39;</span><span class="p">]</span> <span class="o">=</span> \
            <span class="s">&#39;Corrector iteration method choice with 4 possible&#39;</span>\
            <span class="s">&#39;values:                                          &#39;</span>\
            <span class="s">&#39;   0: Functional iteration without any Jacobian  &#39;</span>\
            <span class="s">&#39;      matrix.                                    &#39;</span>\
            <span class="s">&#39;   1: Chord iteration with user-supplied sparse  &#39;</span>\
            <span class="s">&#39;      Jacobian.                                  &#39;</span>\
            <span class="s">&#39;   2: Chord iteration with internally generated  &#39;</span>\
            <span class="s">&#39;      sparse Jacobian matrix.                    &#39;</span>\
            <span class="s">&#39;   3: Chord iteration with internally generated  &#39;</span>\
            <span class="s">&#39;      diagonal Jacobian matrix.                  &#39;</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsodes.set_iter_method"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodes.set_iter_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_iter_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">with_jac_column</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;jac_column&#39;</span><span class="p">)</span> <span class="ow">or</span> \
            <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;jac_column_f77&#39;</span><span class="p">)</span>
        <span class="n">with_ia_ja</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ia&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ja&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;moss&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">with_ia_ja</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">moss</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">with_jac_column</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">moss</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">moss</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;iter_method&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">with_jac_column</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsodes.set_iwork_rwork"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodes.set_iwork_rwork">[docs]</a>    <span class="k">def</span> <span class="nf">set_iwork_rwork</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Initialization of work arrays with caculated length and optional inputs.</span>
<span class="sd">        In ODEPACK, &quot;iwork&quot; &amp; &quot;rwork&quot; should be initialized with the specific</span>
<span class="sd">        optional parameters in all the solvers.</span>
<span class="sd">        &quot;liw&quot; &amp; &quot;lrw&quot; represented the length requirement of work arrays.</span>
<span class="sd">        Specially, in Dlsodes, ia &amp; ja should be attached to iwork_in.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c"># initialize integer work array (iwork)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iwork_in</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">30</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moss</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ia&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iwork_in</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ia</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ja</span><span class="p">)</span>
        <span class="n">nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ja&#39;</span><span class="p">,[]))</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ja&#39;</span><span class="p">)</span> \
                      <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>  <span class="c"># default value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">liw_min</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iwork_in</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iwork_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iwork_in</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_iwork_index</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span>

        <span class="c"># calculate the minimum length of float work array (rwork)</span>
        <span class="n">maxord</span> <span class="o">=</span> <span class="mi">5</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adams_or_bdf</span> <span class="o">==</span> <span class="s">&quot;bdf&quot;</span> <span class="k">else</span> <span class="mi">12</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">*</span><span class="p">(</span><span class="n">maxord</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">lrw_arg</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">9</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span><span class="p">),(</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>\
                  <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span> <span class="o">+=</span> <span class="n">lrw_arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">nnz</span><span class="o">*</span><span class="n">lrw_arg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">*</span><span class="n">lrw_arg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span>\
                  <span class="p">((</span><span class="n">nnz</span> <span class="o">+</span> <span class="n">lrw_arg</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

        <span class="c"># Initializereal input work arrays</span>
        <span class="n">lrw_in</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rwork_index</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rwork_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">lrw_in</span><span class="p">,</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rwork_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rwork_in</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_rwork_index</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="mf">0.</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsodes.set_iopt"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodes.set_iopt">[docs]</a>    <span class="k">def</span> <span class="nf">set_iopt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iopt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iwork_in</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rwork_in</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">))</span>

<span class="c">### End of Lsodes ###</span>

</div></div>
<div class="viewcode-block" id="Lsodi"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodi">[docs]</a><span class="k">class</span> <span class="nc">Lsodi</span><span class="p">(</span><span class="n">Odepack</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A variant version of the DLSODE package.</span>
<span class="sd">    Solves the initial value problem for linearly implicit systems of first</span>
<span class="sd">    order ODEs::</span>

<span class="sd">       A(u,t) * du/dt = g(t,u) ,</span>

<span class="sd">    where A(u,t) is a square matrix.</span>
<span class="sd">    Or, in component form::</span>

<span class="sd">       ( a   * ( du / dt ))  + ... +  ( a     * ( du   / dt ))  =</span>
<span class="sd">          i,1      1                     i,NEQ      NEQ</span>
<span class="sd">        =   g ( t, u , u ,..., u    )   ( i = 1,...,NEQ )</span>
<span class="sd">             i      1   2       NEQ</span>

<span class="sd">    If A is singular, this is a differential-algebraic system.</span>
<span class="sd">    Either res or res_f77 need to be supplied.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">quick_description</span> <span class="o">=</span> <span class="s">&quot;LSODI solver for linearly implicit systems&quot;</span>

    <span class="n">_optional_parameters</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_optional_parameters</span> <span class="o">+</span> \
        <span class="p">[</span><span class="s">&#39;adda_lsodi&#39;</span><span class="p">,</span> <span class="s">&#39;adda_banded_lsodi&#39;</span><span class="p">,</span> <span class="s">&#39;adda_lsodi_f77&#39;</span><span class="p">,</span>
         <span class="s">&#39;adda_banded_lsodi_f77&#39;</span><span class="p">,</span> <span class="s">&#39;jac_lsodi&#39;</span><span class="p">,</span> <span class="s">&#39;jac_banded_lsodi&#39;</span><span class="p">,</span>
         <span class="s">&#39;jac_lsodi_f77&#39;</span><span class="p">,</span> <span class="s">&#39;jac_banded_lsodi_f77&#39;</span><span class="p">,</span> <span class="s">&#39;res&#39;</span><span class="p">,</span>
         <span class="s">&#39;order&#39;</span><span class="p">,</span> <span class="s">&#39;ml&#39;</span><span class="p">,</span> <span class="s">&#39;mu&#39;</span><span class="p">,</span> <span class="s">&#39;ydoti&#39;</span><span class="p">,</span> <span class="s">&#39;nsteps&#39;</span><span class="p">,</span> <span class="s">&#39;res_f77&#39;</span><span class="p">]</span>

    <span class="n">_required_parameters</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">_iwork_index</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_iwork_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;ml&#39;</span><span class="p">,</span> <span class="s">&#39;mu&#39;</span>
    <span class="n">_rwork_index</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_rwork_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">_extra_args_fortran</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_error_messages</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_error_messages</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">_error_messages</span><span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    User-supplied Subroutine RES set its error flag (IRES = 3) despite repeated</span>
<span class="s">    tries by Lsodi to avoid that condition. Current T is &#39;&#39;&#39;</span>
    <span class="n">_error_messages</span><span class="p">[</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    Lsodi was unable to compute the initial value of du/dt.</span>
<span class="s">    Current T is &#39;&#39;&#39;</span>
    <span class="n">_error_messages</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    User-supplied Subroutine RES signalled Lsodi to halt the</span>
<span class="s">    integration and return (IRES = 2). Current T is &#39;&#39;&#39;</span>

<div class="viewcode-block" id="Lsodi.__init__"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodi.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c"># Different default setting of iteration methods</span>
        <span class="n">with_jac</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;jac_lsodi&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s">&#39;jac_lsodi_f77&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span> \
            <span class="ow">or</span> <span class="p">(</span><span class="s">&#39;jac_banded_lsodi&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">or</span> \
            <span class="p">(</span><span class="s">&#39;jac_banded_lsodi_f77&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&#39;adams_or_bdf&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;adams_or_bdf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;adams&#39;</span> <span class="k">if</span> <span class="n">with_jac</span> <span class="k">else</span> <span class="s">&#39;bdf&#39;</span>
        <span class="c"># &#39;f&#39; is not a mandatory parameter in Lsodi()</span>
        <span class="c"># set f with dummy definition for general constructor</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsodi.adjust_parameters"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodi.adjust_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;iter_method&#39;</span><span class="p">][</span><span class="s">&#39;range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;iter_method&#39;</span><span class="p">][</span><span class="s">&#39;condition-list&#39;</span><span class="p">]</span> <span class="o">=</span> \
                         <span class="p">{</span><span class="s">&#39;1&#39;</span><span class="p">:[(</span><span class="s">&#39;jac_lsodi&#39;</span><span class="p">,</span><span class="s">&#39;jac_lsodi_f77&#39;</span><span class="p">),</span>
                               <span class="p">(</span><span class="s">&#39;adda_lsodi&#39;</span><span class="p">,</span><span class="s">&#39;adda_lsodi_f77&#39;</span><span class="p">),</span>
                               <span class="p">(</span><span class="s">&#39;res&#39;</span><span class="p">,</span> <span class="s">&#39;res_f77&#39;</span><span class="p">)],</span>
                          <span class="s">&#39;2&#39;</span><span class="p">:[(</span><span class="s">&#39;adda_lsodi&#39;</span><span class="p">,</span><span class="s">&#39;adda_lsodi_f77&#39;</span><span class="p">),</span>
                               <span class="p">(</span><span class="s">&#39;res&#39;</span><span class="p">,</span> <span class="s">&#39;res_f77&#39;</span><span class="p">)],</span>\
                          <span class="s">&#39;4&#39;</span><span class="p">:[</span><span class="s">&#39;ml&#39;</span><span class="p">,</span><span class="s">&#39;mu&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s">&#39;res&#39;</span><span class="p">,</span> <span class="s">&#39;res_f77&#39;</span><span class="p">),</span>
                               <span class="p">(</span><span class="s">&#39;adda_banded_lsodi&#39;</span><span class="p">,</span><span class="s">&#39;adda_banded_lsodi_f77&#39;</span><span class="p">),</span>
                               <span class="p">(</span><span class="s">&#39;jac_banded_lsodi&#39;</span><span class="p">,</span><span class="s">&#39;jac_banded_lsodi_f77&#39;</span><span class="p">)],</span>\
                          <span class="s">&#39;5&#39;</span><span class="p">:[</span><span class="s">&#39;ml&#39;</span><span class="p">,</span><span class="s">&#39;mu&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s">&#39;res&#39;</span><span class="p">,</span> <span class="s">&#39;res_f77&#39;</span><span class="p">),</span>
                               <span class="p">(</span><span class="s">&#39;adda_banded_lsodi&#39;</span><span class="p">,</span><span class="s">&#39;adda_banded_lsodi_f77&#39;</span><span class="p">)]</span> <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;iter_method&#39;</span><span class="p">][</span><span class="s">&#39;help&#39;</span><span class="p">]</span> <span class="o">=</span> \
            <span class="s">&#39;Choice for the corrector iteration method:       &#39;</span>\
            <span class="s">&#39;  1: Chord iteration with a user-supplied full   &#39;</span>\
            <span class="s">&#39;     Jacobian matrix.                            &#39;</span>\
            <span class="s">&#39;  2: Chord iteration with an internally generated&#39;</span>\
            <span class="s">&#39;     (difference quotient) full Jacobian. This   &#39;</span>\
            <span class="s">&#39;     uses neq+1 extra calls to &quot;res&quot; per dr/du   &#39;</span>\
            <span class="s">&#39;     evaluation. --&gt; Default value.              &#39;</span>\
            <span class="s">&#39;  4: Chord iteration with a user-supplied banded &#39;</span>\
            <span class="s">&#39;     Jacobian matrix.                            &#39;</span>\
            <span class="s">&#39;  5: Chord iteration with an internally generated&#39;</span>\
            <span class="s">&#39;     banded Jacobian matrix. Using &quot;ml&quot;+&quot;mu&quot;+2   &#39;</span>\
            <span class="s">&#39;     extra calls to &quot;res&quot; per dr/du evaluation.  &#39;</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsodi.set_extra_args"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodi.set_extra_args">[docs]</a>    <span class="k">def</span> <span class="nf">set_extra_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_extra_args_fortran</span> <span class="p">[</span><span class="s">&#39;jac_extra_args&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ml</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_extra_args_fortran</span> <span class="p">[</span><span class="s">&#39;adda_extra_args&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ml</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">set_extra_args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsodi.set_iter_method"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodi.set_iter_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_iter_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;iter_method&#39;</span><span class="p">):</span>
            <span class="n">with_banded_jac</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;jac_banded_lsodi_f77&#39;</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;jac_banded_lsodi&#39;</span><span class="p">)</span>
            <span class="n">with_banded_adda</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;adda_banded_lsodi_f77&#39;</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;adda_banded_lsodi&#39;</span><span class="p">)</span>
            <span class="n">with_ml_mu</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ml&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;mu&#39;</span><span class="p">)</span>
            <span class="n">with_full_jac</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;jac_lsodi_f77&#39;</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;jac_lsodi&#39;</span><span class="p">)</span>
            <span class="n">with_full_adda</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;adda_lsodi_f77&#39;</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;adda_lsodi&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">with_ml_mu</span> <span class="ow">and</span> <span class="n">with_banded_jac</span> <span class="ow">and</span> <span class="n">with_banded_adda</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">=</span> <span class="mi">4</span>
            <span class="k">elif</span> <span class="n">with_ml_mu</span> <span class="ow">and</span> <span class="n">with_banded_adda</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="k">elif</span> <span class="n">with_full_jac</span> <span class="ow">and</span> <span class="n">with_full_adda</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">with_full_adda</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s">&#39;adda must be supplied in Lsodi.&#39;</span>
</div>
<div class="viewcode-block" id="Lsodi.set_jac"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodi.set_jac">[docs]</a>    <span class="k">def</span> <span class="nf">set_jac</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jac_lsodi_f77</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jac_banded_lsodi_f77</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adda_lsodi_f77</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adda_banded_lsodi_f77</span>
</div>
<div class="viewcode-block" id="Lsodi.set_liw_min"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodi.set_liw_min">[docs]</a>    <span class="k">def</span> <span class="nf">set_liw_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">liw_min</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span>
</div>
<div class="viewcode-block" id="Lsodi.set_lrw_min"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodi.set_lrw_min">[docs]</a>    <span class="k">def</span> <span class="nf">set_lrw_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mf_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">24</span><span class="p">,</span><span class="mi">25</span><span class="p">]</span>
        <span class="n">length_args</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">22</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">22</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">22</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">22</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>\
                       <span class="p">(</span><span class="mi">22</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">22</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">22</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">22</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>
        <span class="n">lrw_arg</span> <span class="o">=</span> <span class="n">length_args</span><span class="p">[</span><span class="n">mf_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mf</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span> <span class="o">=</span> <span class="n">lrw_arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">*</span><span class="n">lrw_arg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
                   <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">*</span><span class="n">lrw_arg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> \
                   <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ml&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> \
                             <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;mu&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Lsodi.set_iwork_rwork"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodi.set_iwork_rwork">[docs]</a>    <span class="k">def</span> <span class="nf">set_iwork_rwork</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># calculate the required length of work arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_liw_min</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_lrw_min</span><span class="p">()</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">check_liwlrw</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">iwork</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">liw</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rwork</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lrw</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="n">iwork_index</span><span class="p">,</span> <span class="n">rwork_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iwork_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rwork_index</span>
        <span class="c"># Put optional inputs into work arrays with specified indices.</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">iwork_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iwork</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">iwork_index</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">rwork_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rwork</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rwork_index</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="mf">0.</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsodi.set_iopt"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodi.set_iopt">[docs]</a>    <span class="k">def</span> <span class="nf">set_iopt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iopt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iwork</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rwork</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Lsodi.set_dummy_functions"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodi.set_dummy_functions">[docs]</a>    <span class="k">def</span> <span class="nf">set_dummy_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;adda_lsodi_f77&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adda_lsodi_f77</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">:</span> <span class="mf">0.</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_lsodi_f77&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jac_lsodi_f77</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">:</span> <span class="mf">0.</span>
</div>
<div class="viewcode-block" id="Lsodi.solve"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodi.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_points</span><span class="p">,</span> <span class="n">terminate</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c"># Call Solver.solve(), which will direct to Odepack.advance()</span>
        <span class="c"># to step forward.</span>
        <span class="k">return</span> <span class="n">Solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_points</span><span class="p">,</span> <span class="n">terminate</span><span class="o">=</span><span class="n">terminate</span><span class="p">)</span>


<span class="c">### End of Lsodi ###</span>
</div></div>
<div class="viewcode-block" id="Lsodis"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodis">[docs]</a><span class="k">class</span> <span class="nc">Lsodis</span><span class="p">(</span><span class="n">Odepack</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A variant version of Lsodi, and is intended for stiff problems</span>
<span class="sd">    in which the matrix A and the Jacobian matrix d(g - A*s)/du have</span>
<span class="sd">    arbitrary sparse structures.</span>
<span class="sd">    Solves the initial value problem for linearly implicit systems</span>
<span class="sd">    of first order ODEs::</span>

<span class="sd">       A(u,t) * du/dt = g(u,t),</span>

<span class="sd">    where A(u,t) is a square matrix.</span>
<span class="sd">    Or, in component form::</span>

<span class="sd">      ( a   * ( du / dt ))  + ... +  ( a     * ( du   / dt ))  =</span>
<span class="sd">         i,1      1                     i,NEQ      NEQ</span>
<span class="sd">       =   g ( t, u , u ,..., u    )   ( i = 1,...,NEQ )</span>
<span class="sd">            i      1   2       NEQ</span>

<span class="sd">    If A is singular, this is a differential-algebraic system.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">quick_description</span> <span class="o">=</span> <span class="s">&quot;LSODIS solver for linearly implicit sparse systems&quot;</span>

    <span class="n">_optional_parameters</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_optional_parameters</span> <span class="o">+</span> \
        <span class="p">[</span><span class="s">&#39;jac_lsodis&#39;</span><span class="p">,</span> <span class="s">&#39;moss&#39;</span><span class="p">,</span> <span class="s">&#39;ia&#39;</span><span class="p">,</span> <span class="s">&#39;ja&#39;</span><span class="p">,</span> <span class="s">&#39;ic&#39;</span><span class="p">,</span> <span class="s">&#39;jc&#39;</span><span class="p">,</span>
         <span class="s">&#39;ydoti&#39;</span><span class="p">,</span> <span class="s">&#39;order&#39;</span><span class="p">]</span>

    <span class="n">_required_parameters</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;res&#39;</span><span class="p">,</span> <span class="s">&#39;adda_lsodis&#39;</span><span class="p">]</span>
    <span class="c"># Do not support Fortran subroutines</span>

    <span class="n">_extra_args_fortran</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_error_messages</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_error_messages</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">_error_messages</span><span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    User-supplied Subroutine RES set its error flag (IRES = 3) despite repeated</span>
<span class="s">    tries by Lsodis to avoid that condition. Current T is &#39;&#39;&#39;</span>
    <span class="n">_error_messages</span><span class="p">[</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    Lsodis was unable to compute the initial value of du/dt.</span>
<span class="s">    Current T is &#39;&#39;&#39;</span>
    <span class="n">_error_messages</span><span class="p">[</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    A fatal error return-flag came from the sparse solver CDRV.</span>
<span class="s">    This should never happen. Current T is &#39;&#39;&#39;</span>
    <span class="n">_error_messages</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    User-supplied Subroutine RES signalled Lsodis to halt the</span>
<span class="s">    integration and return (IRES = 2). Current T is &#39;&#39;&#39;</span>

<div class="viewcode-block" id="Lsodis.__init__"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodis.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c"># Different default setting of iteration methods</span>
        <span class="n">with_jac</span> <span class="o">=</span> <span class="s">&#39;jac_lsodis&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span>
        <span class="k">if</span> <span class="s">&#39;adams_or_bdf&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;adams_or_bdf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;adams&#39;</span> <span class="k">if</span> <span class="n">with_jac</span> <span class="k">else</span> <span class="s">&#39;bdf&#39;</span>
        <span class="c"># &#39;f&#39; is not a mandatory parameter in Lsodis()</span>
        <span class="c"># set f with dummy definition for general constructor</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsodis.adjust_parameters"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodis.adjust_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;iter_method&#39;</span><span class="p">][</span><span class="s">&#39;range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;iter_method&#39;</span><span class="p">][</span><span class="s">&#39;condition-list&#39;</span><span class="p">]</span> <span class="o">=</span> \
                         <span class="p">{</span><span class="s">&#39;1&#39;</span><span class="p">:[</span><span class="s">&#39;jac_lsodis&#39;</span><span class="p">,],}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;iter_method&#39;</span><span class="p">][</span><span class="s">&#39;help&#39;</span><span class="p">]</span> <span class="o">=</span> \
        <span class="s">&#39;Choice for the corrector iteration method:       &#39;</span>\
        <span class="s">&#39;  1: Chord iteration with a user-supplied sparse &#39;</span>\
        <span class="s">&#39;     Jacobian matrix.                            &#39;</span>\
        <span class="s">&#39;  2: Chord iteration with an internally generated&#39;</span>\
        <span class="s">&#39;    (difference quotient) sparse jacobian matrix.&#39;</span>\
        <span class="s">&#39;    This uses extra calls to &quot;res&quot; per dr/du     &#39;</span>\
        <span class="s">&#39;    evaluation. --&gt; Default value.               &#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;moss&#39;</span><span class="p">][</span><span class="s">&#39;range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;moss&#39;</span><span class="p">][</span><span class="s">&#39;condition-list&#39;</span><span class="p">]</span> <span class="o">=</span> \
                         <span class="p">{</span><span class="s">&#39;1&#39;</span><span class="p">:[</span><span class="s">&#39;jac_lsodis&#39;</span><span class="p">,],</span>
                          <span class="s">&#39;0&#39;</span><span class="p">:[</span><span class="s">&#39;ia&#39;</span><span class="p">,</span><span class="s">&#39;ja&#39;</span><span class="p">,</span><span class="s">&#39;ic&#39;</span><span class="p">,</span><span class="s">&#39;jc&#39;</span><span class="p">],</span>
                          <span class="s">&#39;3&#39;</span><span class="p">:[</span><span class="s">&#39;jac_lsodis&#39;</span><span class="p">,</span><span class="s">&#39;ia&#39;</span><span class="p">,</span><span class="s">&#39;ja&#39;</span><span class="p">],</span>
                          <span class="s">&#39;4&#39;</span><span class="p">:[</span><span class="s">&#39;ia&#39;</span><span class="p">,</span><span class="s">&#39;ja&#39;</span><span class="p">]}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;moss&#39;</span><span class="p">][</span><span class="s">&#39;help&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span>
<span class="s">         Method to obtain sparse structure of jacobian matrix.</span>
<span class="s">         &quot;moss&quot; has 5 possible values:</span>
<span class="s">          0:   means the user has supplied IA, JA, IC, and JC.</span>
<span class="s">          1:   means the user has supplied JAC and the</span>
<span class="s">               structure will be obtained from NEQ initial</span>
<span class="s">               calls to JAC and NEQ initial calls to ADDA.</span>
<span class="s">          2:   means the structure will be obtained from NEQ+1</span>
<span class="s">               initial calls to RES and NEQ initial calls to ADDA.</span>
<span class="s">          3:   like MOSS = 1, except user has supplied IA and JA.</span>
<span class="s">          4:   like MOSS = 2, except user has supplied IA and JA &#39;&#39;&#39;</span><span class="p">,</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsodis.set_iter_method"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodis.set_iter_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_iter_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">with_jac</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_lsodis&#39;</span><span class="p">)</span>
        <span class="n">with_ia_ja</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;ia&#39;</span><span class="p">)</span> <span class="ow">and</span>  <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;ja&#39;</span><span class="p">)</span>
        <span class="n">with_ic_jc</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;ic&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jc&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;iter_method&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">with_jac</span> <span class="k">else</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;moss&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">with_ia_ja</span> <span class="ow">and</span> <span class="n">with_ic_jc</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">moss</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">with_ia_ja</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">moss</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">if</span> <span class="n">with_jac</span> <span class="k">else</span> <span class="mi">4</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">moss</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">with_jac</span> <span class="k">else</span> <span class="mi">2</span>
</div>
<div class="viewcode-block" id="Lsodis.set_iwork_rwork"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodis.set_iwork_rwork">[docs]</a>    <span class="k">def</span> <span class="nf">set_iwork_rwork</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Initialization of work arrays with caculated length and optional inputs.</span>
<span class="sd">        In ODEPACK, &quot;iwork&quot; &amp; &quot;rwork&quot; should be initialized with the specific</span>
<span class="sd">        optional parameters in all the solvers.</span>
<span class="sd">        &quot;liw&quot; &amp; &quot;lrw&quot; represented the length requirement of work arrays.</span>
<span class="sd">        Specially, in Lsodis, (ia, ja, ic &amp; jc) should be attached to</span>
<span class="sd">        iwork.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c"># initialize integer work array (iwork)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iwork</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">30</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moss</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ia&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iwork</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ia</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ja</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moss</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ic&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iwork</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ic</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jc</span><span class="p">)</span>
        <span class="n">nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ja&#39;</span><span class="p">,[]))</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ja&#39;</span><span class="p">)</span> \
                      <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>  <span class="c"># default value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">liw_min</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iwork</span><span class="p">)</span>

        <span class="c"># calculate the length of  float work array (rwork)</span>
        <span class="n">mf_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">22</span><span class="p">]</span>
        <span class="n">length_args</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">20</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">9</span><span class="p">),(</span><span class="mi">20</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">10</span><span class="p">),(</span><span class="mi">20</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">9</span><span class="p">),(</span><span class="mi">20</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">10</span><span class="p">)]</span>
        <span class="n">lrw_arg</span> <span class="o">=</span> <span class="n">length_args</span><span class="p">[</span><span class="n">mf_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mf</span> <span class="o">%</span> <span class="mi">100</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">nnz</span> <span class="o">+</span> <span class="n">lrw_arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">*</span><span class="n">lrw_arg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
                       <span class="p">(</span><span class="n">nnz</span> <span class="o">+</span> <span class="n">lrw_arg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>

        <span class="c"># Check lrw&gt;lrw_min, liw&gt;liw_min if lrw/liw are specified by users</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">check_liwlrw</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">liw</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">liw_min</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iwork</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">liw</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">liw_min</span><span class="p">)</span>

        <span class="c"># Read in optional inputs</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iwork_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iwork</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_iwork_index</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span>

        <span class="c"># Initialize real work array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rwork</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lrw</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rwork_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rwork</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_rwork_index</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="mf">0.</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsodis.set_iopt"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodis.set_iopt">[docs]</a>    <span class="k">def</span> <span class="nf">set_iopt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iopt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iwork</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rwork</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsodis.set_dummy_functions"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodis.set_dummy_functions">[docs]</a>    <span class="k">def</span> <span class="nf">set_dummy_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;jac_lsodis_f77&#39;</span><span class="p">,</span> <span class="s">&#39;adda_lsodis_f77&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">:</span><span class="mf">0.</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsodis.solve"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsodis.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_points</span><span class="p">,</span> <span class="n">terminate</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c"># Call Solver.solve(), which will direct to Odepack.advance()</span>
        <span class="c"># to step forward.</span>
        <span class="k">return</span> <span class="n">Solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_points</span><span class="p">,</span> <span class="n">terminate</span><span class="o">=</span><span class="n">terminate</span><span class="p">)</span>

<span class="c">### End of class Lsodis ###</span>
</div></div>
<div class="viewcode-block" id="Lsoibt"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsoibt">[docs]</a><span class="k">class</span> <span class="nc">Lsoibt</span><span class="p">(</span><span class="n">Odepack</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A variant version of Lsodi_ODEPACK, for the case where the matrices</span>
<span class="sd">    A, dg/du, and d(A*s)/du are all block-tridiagonal.</span>
<span class="sd">    Solves the initial value problem for linearly implicit systems of first</span>
<span class="sd">    order ODEs::</span>

<span class="sd">       A(u,t) * du/dt = g(u,t),</span>

<span class="sd">    where A(u,t) is a square matrix.</span>
<span class="sd">    Or, in component form::</span>

<span class="sd">      ( a   * ( du / dt ))  + ... +  ( a     * ( du   / dt ))  =</span>
<span class="sd">         i,1      1                     i,NEQ      NEQ</span>
<span class="sd">       =   g ( t, u , u ,..., u    )   ( i = 1,...,NEQ )</span>
<span class="sd">            i      1   2       NEQ</span>

<span class="sd">    If A is singular, this is a differential-algebraic system.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">quick_description</span> <span class="o">=</span> <span class="s">&quot;LSOIBIT solver for linearly implicit block tridiag systems&quot;</span>

    <span class="n">_optional_parameters</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_optional_parameters</span> <span class="o">+</span> \
        <span class="p">[</span><span class="s">&#39;jac_lsoibt&#39;</span><span class="p">,</span> <span class="s">&#39;ydoti&#39;</span><span class="p">,</span> <span class="s">&#39;order&#39;</span><span class="p">]</span>

    <span class="n">_required_parameters</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;res&#39;</span><span class="p">,</span> <span class="s">&#39;adda_lsoibt&#39;</span><span class="p">,</span> <span class="s">&#39;mb&#39;</span><span class="p">,</span> <span class="s">&#39;nb&#39;</span><span class="p">]</span>
    <span class="c"># Do not support Fortran subroutines</span>

    <span class="n">_iwork_index</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_iwork_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;mb&#39;</span><span class="p">,</span> <span class="s">&#39;nb&#39;</span>
    <span class="n">_rwork_index</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_rwork_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">_extra_args_fortran</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_error_messages</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_error_messages</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">_error_messages</span><span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    User-supplied Subroutine RES set its error flag (IRES = 3) despite repeated</span>
<span class="s">    tries by Lsoibt_ODEPACK to avoid that condition. Current T is &#39;&#39;&#39;</span>
    <span class="n">_error_messages</span><span class="p">[</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    Lsoibt_ODEPACK was unable to compute the initial value of du/dt.</span>
<span class="s">    Current T is &#39;&#39;&#39;</span>
    <span class="n">_error_messages</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    User-supplied Subroutine RES signalled Lsoibt_ODEPACK to halt the</span>
<span class="s">    integration and return (IRES = 2). Current T is &#39;&#39;&#39;</span>

<div class="viewcode-block" id="Lsoibt.__init__"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsoibt.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c"># Different default setting of iteration methods</span>
        <span class="n">with_jac</span> <span class="o">=</span> <span class="s">&#39;jac_lsoibt&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span>
        <span class="k">if</span> <span class="s">&#39;adams_or_bdf&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;adams_or_bdf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;adams&#39;</span> <span class="k">if</span> <span class="n">with_jac</span> <span class="k">else</span> <span class="s">&#39;bdf&#39;</span>
        <span class="c"># &#39;f&#39; is not a mandatory parameter in Lsoibt()</span>
        <span class="c"># set f with dummy definition for general constructor</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsoibt.adjust_parameters"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsoibt.adjust_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;iter_method&#39;</span><span class="p">][</span><span class="s">&#39;range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;iter_method&#39;</span><span class="p">][</span><span class="s">&#39;condition-list&#39;</span><span class="p">]</span> <span class="o">=</span> \
                         <span class="p">{</span><span class="s">&#39;1&#39;</span><span class="p">:(</span><span class="s">&#39;jac_lsoibt&#39;</span><span class="p">,),}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;iter_method&#39;</span><span class="p">][</span><span class="s">&#39;help&#39;</span><span class="p">]</span> <span class="o">=</span> \
        <span class="s">&#39;Choice for the corrector iteration method:       &#39;</span>\
        <span class="s">&#39;  1: Chord iteration with a user-supplied block- &#39;</span>\
        <span class="s">&#39;     tridiagonal Jacobian matrix.                &#39;</span>\
        <span class="s">&#39;  2: Chord iteration with an internally generated&#39;</span>\
        <span class="s">&#39;     (difference quotient) block-tridiagonal     &#39;</span>\
        <span class="s">&#39;     Jacobian matrix. This uses 3*mb+1 calls to  &#39;</span>\
        <span class="s">&#39;     &quot;res&quot; per dr/du evaluation.--&gt;Default value.&#39;</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsoibt.set_iter_method"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsoibt.set_iter_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_iter_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">with_jac</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_lsoibt&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;iter_method&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">with_jac</span> <span class="k">else</span> <span class="mi">2</span>
</div>
<div class="viewcode-block" id="Lsoibt.set_liw_min"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsoibt.set_liw_min">[docs]</a>    <span class="k">def</span> <span class="nf">set_liw_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">liw_min</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span>
</div>
<div class="viewcode-block" id="Lsoibt.set_lrw_min"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsoibt.set_lrw_min">[docs]</a>    <span class="k">def</span> <span class="nf">set_lrw_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mf_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">22</span><span class="p">]</span>
        <span class="n">length_args</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">22</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">22</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">22</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">22</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">)]</span>
        <span class="n">lrw_arg</span> <span class="o">=</span> <span class="n">length_args</span><span class="p">[</span><span class="n">mf_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mf</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span> <span class="o">=</span> <span class="n">lrw_arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">*</span><span class="n">lrw_arg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
            <span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">mb</span><span class="o">*</span><span class="n">lrw_arg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Lsoibt.set_iwork_rwork"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsoibt.set_iwork_rwork">[docs]</a>    <span class="k">def</span> <span class="nf">set_iwork_rwork</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># calculate the required length of work arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_liw_min</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_lrw_min</span><span class="p">()</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">check_liwlrw</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">iwork</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">liw</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rwork</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lrw</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="n">iwork_index</span><span class="p">,</span> <span class="n">rwork_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iwork_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rwork_index</span>
        <span class="c"># Put optional inputs into work arrays with specified indices.</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">iwork_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iwork</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">iwork_index</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">rwork_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rwork</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rwork_index</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="mf">0.</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsoibt.set_iopt"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsoibt.set_iopt">[docs]</a>    <span class="k">def</span> <span class="nf">set_iopt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iopt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iwork</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rwork</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Lsoibt.set_dummy_functions"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsoibt.set_dummy_functions">[docs]</a>    <span class="k">def</span> <span class="nf">set_dummy_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_lsoibt_f77&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jac_lsoibt_f77</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">:(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;adda_lsoibt_f77&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adda_lsoibt_f77</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">:(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsoibt.validate_data"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsoibt.validate_data">[docs]</a>    <span class="k">def</span> <span class="nf">validate_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">validate_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mb</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nb</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">    The requirement for block size (mb,nb) are: mb&gt;=1, nb&gt;=4, mb*nb=neq=</span><span class="si">%d</span><span class="s">.</span>
<span class="s">    Your block size are (</span><span class="si">%d</span><span class="s">,</span><span class="si">%d</span><span class="s">). &#39;&#39;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="p">,</span> <span class="n">mb</span><span class="p">,</span> <span class="n">nb</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="Lsoibt.solve"><a class="viewcode-back" href="../../odepack.html#odesolvers.odepack.Lsoibt.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_points</span><span class="p">,</span> <span class="n">terminate</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c"># Call Solver.solve(), which will direct to Odepack.advance()</span>
        <span class="c"># to step forward.</span>
        <span class="k">return</span> <span class="n">Solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_points</span><span class="p">,</span> <span class="n">terminate</span><span class="o">=</span><span class="n">terminate</span><span class="p">)</span>

<span class="c">### end of class Lsoibt ###</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">odesolver API 0.1 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Liwei Wang and Hans Petter Langtangen.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>