

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>odesolvers.odepack &mdash; odesolver API 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="odesolver API 0.1 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">odesolver API 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-odesolvers.odepack">
<span id="odesolvers-odepack"></span><h1><a class="reference internal" href="#module-odesolvers.odepack" title="odesolvers.odepack"><tt class="xref py py-mod docutils literal"><span class="pre">odesolvers.odepack</span></tt></a><a class="headerlink" href="#module-odesolvers.odepack" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="odesolvers.odepack.Lsoda">
<em class="property">class </em><tt class="descclassname">odesolvers.odepack.</tt><tt class="descname">Lsoda</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsoda"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsoda" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.odepack.Odepack" title="odesolvers.odepack.Odepack"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.odepack.Odepack</span></tt></a></p>
<p>A variant version of the DLSODE package.
It switches automatically between stiff and nonstiff methods.
This means that the user does not have to determine whether the problem
is stiff or not, and the solver will automatically choose the appropriate
method.  It always starts with the nonstiff method.
Solves the initial-value problem for stiff or nonstiff systems of
first-order ODE:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">du</span><span class="o">/</span><span class="n">dt</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>or, in component form:</p>
<div class="highlight-python"><pre>du(i)/dt = f(u,t)[i] for i in 1,...,neq</pre>
</div>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
<tr class="row-odd"><td>atol</td>
<td>absolute tolerance for solution (default: 1e-08)</td>
</tr>
<tr class="row-even"><td>rtol</td>
<td>relative tolerance for solution (default: 1e-06)</td>
</tr>
<tr class="row-odd"><td>adams_or_bdf</td>
<td>Method in vode or solvers in odepack: &#8220;adams&#8221; or
&#8220;bdf&#8221; (default: adams)</td>
</tr>
<tr class="row-even"><td>nsteps</td>
<td>Max no of internal solver steps per time step (de
fault: 1000)</td>
</tr>
<tr class="row-odd"><td>first_step</td>
<td>Suggested first time step size for an adaptive al
gorithm</td>
</tr>
<tr class="row-even"><td>min_step</td>
<td>Minimum step size for an adaptive algorithm</td>
</tr>
<tr class="row-odd"><td>max_step</td>
<td>Maximum step size for an adaptive algorithm</td>
</tr>
<tr class="row-even"><td>iter_method</td>
<td>Corrector iteration method choice</td>
</tr>
<tr class="row-odd"><td>lrw</td>
<td>Length of real work array.</td>
</tr>
<tr class="row-even"><td>liw</td>
<td>Length of integer work array, similiar as &lt;lrw&gt;.</td>
</tr>
<tr class="row-odd"><td>jac_banded</td>
<td><p class="first">A callable object to define the banded Jacobian
matrix(df/du) of right-hand side function f.
Used in Lsode, Lsoda, Lsodar.</p>
<blockquote class="last">
<div>jac_banded(u,t,ml,mu) returns df/du
vector * float * int * int &#8211;&gt;   2d-array</div></blockquote>
</td>
</tr>
<tr class="row-even"><td>jac_banded_f77</td>
<td><p class="first">Intend to supply a Fortran subroutine as jac_banded. This subroutine should be defined in form:</p>
<div class="last highlight-python"><pre> subroutine jac_banded_f77(neq,t,u,ml
     1 ,mu,pd,nrowpd)
Cf2py intent(out) pd
      integer neq,ml,mu,nrowpd
      double precision t,u,pd
      dimension u(neq),pd(nrowpd,neq)
      pd = ...
      return
      end</pre>
</div>
</td>
</tr>
<tr class="row-odd"><td>ml</td>
<td>Lower half-bandwidth of banded jacobian matrix</td>
</tr>
<tr class="row-even"><td>mu</td>
<td>Upper half-bandwidth of banded jacobian matrix</td>
</tr>
<tr class="row-odd"><td>jac</td>
<td>Jacobian of right-hand side function f (df/du) (d
efault: None)</td>
</tr>
<tr class="row-even"><td>jac_f77</td>
<td><p class="first">Intend to supply a Fortran subroutine as jac.
This subroutine should be defined in form:</p>
<div class="last highlight-python"><pre>      subroutine jac_f77(neq,t,u,ml,mu,pd,
     1      nrowpd)
Cf2py intent(hide) neq,ml,mu,nrowpd
Cf2py intent(out) pd
      integer neq,ml,mu,nrowpd
      double precision t,u,pd
      dimension u(neq),pd(neq,neq)
      pd = ...
      return
      end</pre>
</div>
</td>
</tr>
<tr class="row-odd"><td>max_ordn</td>
<td>Maximum order in nonstiff methods.</td>
</tr>
<tr class="row-even"><td>max_ords</td>
<td>Maximum order in stiff methods.</td>
</tr>
<tr class="row-odd"><td>f_f77</td>
<td><p class="first">Intend to supply a Fortran subroutine as f.
This subroutine should be defined in form:</p>
<div class="last highlight-python"><pre>      subroutine f_f77(neq,t,u,udot)
Cf2py intent(hide)   neq
Cf2py intent(out)    udot
      integer neq
      double precision t,u(neq),udot(neq)
      udot = ...
      return
      end</pre>
</div>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_atol</span></tt>(u_current)</td>
<td>Error tolerance tol(i) became zero for some i during integration, where tol = rtol(i) * u(i) + atol(i).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsoda.adjust_parameters" title="odesolvers.odepack.Lsoda.adjust_parameters"><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt></a>()</td>
<td>Properties for new parameters in this solver.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td>This function intends to one step forward for linearly solvers</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_iaja</span></tt>()</td>
<td>ia, ja, ic, jc are optional inputs to describe arbitrary sparse</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_liwlrw</span></tt>()</td>
<td>If the lengths of work arrays are specified by users, check whether</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_pars</span></tt>()</td>
<td>Some pairs of parameters should be input simutaneously.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_tol</span></tt>()</td>
<td>atol &amp; rtol should be defined as scalars or vectors with length neq.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">expand_iwork</span></tt>(new_liw[,&nbsp;expand])</td>
<td>Extension module return an actually required length for integer work array when it is too short.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">expand_rwork</span></tt>(new_lrw[,&nbsp;expand])</td>
<td>Length of real work array is smaller than actually required length.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Import extension module _odesolver and check that it exists.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td>In the long parameter-lists for solvers in ODEPACK, quite a few</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">new_stepnr</span></tt>()</td>
<td>When Fortran code returns a status &#8220;istate==-1&#8221;, it indicates that</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">print_roots</span></tt>(jroot,&nbsp;t_current,&nbsp;u_current)</td>
<td>Roots found at current T for some constraint functions.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_dummy_functions</span></tt>()</td>
<td>Functions have to get dummy values before they are passed to extension</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Lsoda.set_extra_args" title="odesolvers.odepack.Lsoda.set_extra_args"><tt class="xref py py-obj docutils literal"><span class="pre">set_extra_args</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Lsoda.set_iopt" title="odesolvers.odepack.Lsoda.set_iopt"><tt class="xref py py-obj docutils literal"><span class="pre">set_iopt</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsoda.set_iter_method" title="odesolvers.odepack.Lsoda.set_iter_method"><tt class="xref py py-obj docutils literal"><span class="pre">set_iter_method</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_iwork_rwork</span></tt>()</td>
<td>Initialize arrays for optional inputs, and calculate the</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsoda.set_jac" title="odesolvers.odepack.Lsoda.set_jac"><tt class="xref py py-obj docutils literal"><span class="pre">set_jac</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Lsoda.set_liw_min" title="odesolvers.odepack.Lsoda.set_liw_min"><tt class="xref py py-obj docutils literal"><span class="pre">set_liw_min</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsoda.set_lrw_min" title="odesolvers.odepack.Lsoda.set_lrw_min"><tt class="xref py py-obj docutils literal"><span class="pre">set_lrw_min</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_ydoti</span></tt>()</td>
<td>&#8220;ydoti&#8221; is an array used in linearly solvers.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>This function is involved for non-linearly solvers in ODEPACK, i.e.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">tol_multiply</span></tt>(tolsf)</td>
<td>This function is used to adjust tolerance parameters for Fortran part.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>Common validity check in Odepack.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odesolvers.odepack.Lsoda.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.odepack'</em><a class="headerlink" href="#odesolvers.odepack.Lsoda.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsoda.adjust_parameters">
<tt class="descname">adjust_parameters</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsoda.adjust_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsoda.adjust_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Properties for new parameters in this solver.</p>
</dd></dl>

<dl class="attribute">
<dt id="odesolvers.odepack.Lsoda.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'LSODA solver with stiff-nonstiff auto shift'</em><a class="headerlink" href="#odesolvers.odepack.Lsoda.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsoda.set_extra_args">
<tt class="descname">set_extra_args</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsoda.set_extra_args"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsoda.set_extra_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsoda.set_iopt">
<tt class="descname">set_iopt</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsoda.set_iopt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsoda.set_iopt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsoda.set_iter_method">
<tt class="descname">set_iter_method</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsoda.set_iter_method"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsoda.set_iter_method" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsoda.set_jac">
<tt class="descname">set_jac</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsoda.set_jac"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsoda.set_jac" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsoda.set_liw_min">
<tt class="descname">set_liw_min</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsoda.set_liw_min"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsoda.set_liw_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsoda.set_lrw_min">
<tt class="descname">set_lrw_min</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsoda.set_lrw_min"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsoda.set_lrw_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.odepack.Lsodar">
<em class="property">class </em><tt class="descclassname">odesolvers.odepack.</tt><tt class="descname">Lsodar</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodar" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.odepack.Odepack" title="odesolvers.odepack.Odepack"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.odepack.Odepack</span></tt></a></p>
<p>A variant version of the DLSODE package.
It differs from DLSODE in two ways.</p>
<p>It switches automatically between stiff and nonstiff methods.
This means that the user does not have to determine whether the
problem is stiff or not, and the solver will automatically choose
the appropriate method.  It always starts with the nonstiff method.
It finds the root of at least one of a set of constraint functions
g(i) of the independent and dependent variables.
It finds only those roots for which some g(i), as a function of t,
changes sign in the interval of integration.
It then returns the solution at the root, if that occurs sooner
than the specified stop condition, and otherwise returns the
solution according to the specified stop condition.
Solves the initial-value problem for stiff or nonstiff systems of
first-order ODE:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">du</span><span class="o">/</span><span class="n">dt</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">t</span><span class="p">),</span>
</pre></div>
</div>
<p>or, in component form:</p>
<div class="highlight-python"><pre>du(i)/dt = f(u,t)[i] for i in 1,...,neq</pre>
</div>
<p>At the same time, it locates the roots of any of a set of functions:</p>
<div class="highlight-python"><pre>g(i) = g(i,t,u(1),...,u(NEQ))  (i = 1,...,ng).</pre>
</div>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
<tr class="row-odd"><td>atol</td>
<td>absolute tolerance for solution (default: 1e-08)</td>
</tr>
<tr class="row-even"><td>rtol</td>
<td>relative tolerance for solution (default: 1e-06)</td>
</tr>
<tr class="row-odd"><td>adams_or_bdf</td>
<td>Method in vode or solvers in odepack: &#8220;adams&#8221; or
&#8220;bdf&#8221; (default: adams)</td>
</tr>
<tr class="row-even"><td>nsteps</td>
<td>Max no of internal solver steps per time step (de
fault: 1000)</td>
</tr>
<tr class="row-odd"><td>first_step</td>
<td>Suggested first time step size for an adaptive al
gorithm</td>
</tr>
<tr class="row-even"><td>min_step</td>
<td>Minimum step size for an adaptive algorithm</td>
</tr>
<tr class="row-odd"><td>max_step</td>
<td>Maximum step size for an adaptive algorithm</td>
</tr>
<tr class="row-even"><td>iter_method</td>
<td>Corrector iteration method choice</td>
</tr>
<tr class="row-odd"><td>lrw</td>
<td>Length of real work array.</td>
</tr>
<tr class="row-even"><td>liw</td>
<td>Length of integer work array, similiar as &lt;lrw&gt;.</td>
</tr>
<tr class="row-odd"><td>jac_banded</td>
<td><p class="first">A callable object to define the banded Jacobian
matrix(df/du) of right-hand side function f.
Used in Lsode, Lsoda, Lsodar.</p>
<blockquote class="last">
<div>jac_banded(u,t,ml,mu) returns df/du
vector * float * int * int &#8211;&gt;   2d-array</div></blockquote>
</td>
</tr>
<tr class="row-even"><td>jac_banded_f77</td>
<td><p class="first">Intend to supply a Fortran subroutine as jac_banded. This subroutine should be defined in form:</p>
<div class="last highlight-python"><pre> subroutine jac_banded_f77(neq,t,u,ml
     1 ,mu,pd,nrowpd)
Cf2py intent(out) pd
      integer neq,ml,mu,nrowpd
      double precision t,u,pd
      dimension u(neq),pd(nrowpd,neq)
      pd = ...
      return
      end</pre>
</div>
</td>
</tr>
<tr class="row-odd"><td>ml</td>
<td>Lower half-bandwidth of banded jacobian matrix</td>
</tr>
<tr class="row-even"><td>mu</td>
<td>Upper half-bandwidth of banded jacobian matrix</td>
</tr>
<tr class="row-odd"><td>jac</td>
<td>Jacobian of right-hand side function f (df/du) (d
efault: None)</td>
</tr>
<tr class="row-even"><td>jac_f77</td>
<td><p class="first">Intend to supply a Fortran subroutine as jac.
This subroutine should be defined in form:</p>
<div class="last highlight-python"><pre>      subroutine jac_f77(neq,t,u,ml,mu,pd,
     1      nrowpd)
Cf2py intent(hide) neq,ml,mu,nrowpd
Cf2py intent(out) pd
      integer neq,ml,mu,nrowpd
      double precision t,u,pd
      dimension u(neq),pd(neq,neq)
      pd = ...
      return
      end</pre>
</div>
</td>
</tr>
<tr class="row-odd"><td>max_ordn</td>
<td>Maximum order in nonstiff methods.</td>
</tr>
<tr class="row-even"><td>max_ords</td>
<td>Maximum order in stiff methods.</td>
</tr>
<tr class="row-odd"><td>g</td>
<td><p class="first">Callable object to define constraint functions,
whose roots are desired during the integration.</p>
<blockquote class="last">
<div>g(u, t) &#8211;&gt; values of constraint functions
scalar/vector * float &#8211;&gt; scalar/vector</div></blockquote>
</td>
</tr>
<tr class="row-even"><td>g_f77</td>
<td><p class="first">Intend to supply a Fortran subroutine as g.
This subroutine should be defined in form:</p>
<div class="last highlight-python"><pre>      subroutine g_f77(neq, t, u, ng, groot)
Cf2py intent(hide) neq
Cf2py optional, intent(hide) ng
Cf2py intent(in) t, u
Cf2py intent(out) groot
      integer neq, ng
      double precision t, u, groot
      dimension u(neq), groot(ng)
      groot = ...
      return
      end</pre>
</div>
</td>
</tr>
<tr class="row-odd"><td>ng</td>
<td>No of components in constraint function g.</td>
</tr>
<tr class="row-even"><td>f_f77</td>
<td><p class="first">Intend to supply a Fortran subroutine as f.
This subroutine should be defined in form:</p>
<div class="last highlight-python"><pre>      subroutine f_f77(neq,t,u,udot)
Cf2py intent(hide)   neq
Cf2py intent(out)    udot
      integer neq
      double precision t,u(neq),udot(neq)
      udot = ...
      return
      end</pre>
</div>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_atol</span></tt>(u_current)</td>
<td>Error tolerance tol(i) became zero for some i during integration, where tol = rtol(i) * u(i) + atol(i).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsodar.adjust_parameters" title="odesolvers.odepack.Lsodar.adjust_parameters"><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt></a>()</td>
<td>Properties for new parameters in this solver.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td>This function intends to one step forward for linearly solvers</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_iaja</span></tt>()</td>
<td>ia, ja, ic, jc are optional inputs to describe arbitrary sparse</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_liwlrw</span></tt>()</td>
<td>If the lengths of work arrays are specified by users, check whether</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_pars</span></tt>()</td>
<td>Some pairs of parameters should be input simutaneously.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_tol</span></tt>()</td>
<td>atol &amp; rtol should be defined as scalars or vectors with length neq.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">expand_iwork</span></tt>(new_liw[,&nbsp;expand])</td>
<td>Extension module return an actually required length for integer work array when it is too short.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">expand_rwork</span></tt>(new_lrw[,&nbsp;expand])</td>
<td>Length of real work array is smaller than actually required length.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Import extension module _odesolver and check that it exists.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td>In the long parameter-lists for solvers in ODEPACK, quite a few</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">new_stepnr</span></tt>()</td>
<td>When Fortran code returns a status &#8220;istate==-1&#8221;, it indicates that</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">print_roots</span></tt>(jroot,&nbsp;t_current,&nbsp;u_current)</td>
<td>Roots found at current T for some constraint functions.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_dummy_functions</span></tt>()</td>
<td>Functions have to get dummy values before they are passed to extension</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Lsodar.set_extra_args" title="odesolvers.odepack.Lsodar.set_extra_args"><tt class="xref py py-obj docutils literal"><span class="pre">set_extra_args</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Lsodar.set_iopt" title="odesolvers.odepack.Lsodar.set_iopt"><tt class="xref py py-obj docutils literal"><span class="pre">set_iopt</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsodar.set_iter_method" title="odesolvers.odepack.Lsodar.set_iter_method"><tt class="xref py py-obj docutils literal"><span class="pre">set_iter_method</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_iwork_rwork</span></tt>()</td>
<td>Initialize arrays for optional inputs, and calculate the</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsodar.set_jac" title="odesolvers.odepack.Lsodar.set_jac"><tt class="xref py py-obj docutils literal"><span class="pre">set_jac</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Lsodar.set_liw_min" title="odesolvers.odepack.Lsodar.set_liw_min"><tt class="xref py py-obj docutils literal"><span class="pre">set_liw_min</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsodar.set_lrw_min" title="odesolvers.odepack.Lsodar.set_lrw_min"><tt class="xref py py-obj docutils literal"><span class="pre">set_lrw_min</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_ydoti</span></tt>()</td>
<td>&#8220;ydoti&#8221; is an array used in linearly solvers.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsodar.solve" title="odesolvers.odepack.Lsodar.solve"><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt></a>(time_points[,&nbsp;terminate])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">tol_multiply</span></tt>(tolsf)</td>
<td>This function is used to adjust tolerance parameters for Fortran part.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>Common validity check in Odepack.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odesolvers.odepack.Lsodar.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.odepack'</em><a class="headerlink" href="#odesolvers.odepack.Lsodar.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodar.adjust_parameters">
<tt class="descname">adjust_parameters</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodar.adjust_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodar.adjust_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Properties for new parameters in this solver.</p>
</dd></dl>

<dl class="attribute">
<dt id="odesolvers.odepack.Lsodar.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'LSODAR method with stiff-nonstiff auto shift'</em><a class="headerlink" href="#odesolvers.odepack.Lsodar.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodar.set_extra_args">
<tt class="descname">set_extra_args</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodar.set_extra_args"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodar.set_extra_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodar.set_iopt">
<tt class="descname">set_iopt</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodar.set_iopt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodar.set_iopt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodar.set_iter_method">
<tt class="descname">set_iter_method</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodar.set_iter_method"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodar.set_iter_method" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodar.set_jac">
<tt class="descname">set_jac</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodar.set_jac"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodar.set_jac" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodar.set_liw_min">
<tt class="descname">set_liw_min</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodar.set_liw_min"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodar.set_liw_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodar.set_lrw_min">
<tt class="descname">set_lrw_min</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodar.set_lrw_min"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodar.set_lrw_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodar.solve">
<tt class="descname">solve</tt><big>(</big><em>time_points</em>, <em>terminate=None</em><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodar.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodar.solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.odepack.Lsode">
<em class="property">class </em><tt class="descclassname">odesolvers.odepack.</tt><tt class="descname">Lsode</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.odepack.Odepack" title="odesolvers.odepack.Odepack"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.odepack.Odepack</span></tt></a></p>
<p>Basic Solver in ODEPACK package.
Solves the initial-value problem for stiff or nonstiff systems
of first-order ODE:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">du</span><span class="o">/</span><span class="n">dt</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>or, in component form:</p>
<div class="highlight-python"><pre>du(i)/dt = f(u,t)[i] for i in 1,...,neq</pre>
</div>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
<tr class="row-odd"><td>atol</td>
<td>absolute tolerance for solution (default: 1e-08)</td>
</tr>
<tr class="row-even"><td>rtol</td>
<td>relative tolerance for solution (default: 1e-06)</td>
</tr>
<tr class="row-odd"><td>adams_or_bdf</td>
<td>Method in vode or solvers in odepack: &#8220;adams&#8221; or
&#8220;bdf&#8221; (default: adams)</td>
</tr>
<tr class="row-even"><td>nsteps</td>
<td>Max no of internal solver steps per time step (de
fault: 1000)</td>
</tr>
<tr class="row-odd"><td>first_step</td>
<td>Suggested first time step size for an adaptive al
gorithm</td>
</tr>
<tr class="row-even"><td>min_step</td>
<td>Minimum step size for an adaptive algorithm</td>
</tr>
<tr class="row-odd"><td>max_step</td>
<td>Maximum step size for an adaptive algorithm</td>
</tr>
<tr class="row-even"><td>iter_method</td>
<td>Corrector iteration method choice</td>
</tr>
<tr class="row-odd"><td>lrw</td>
<td>Length of real work array.</td>
</tr>
<tr class="row-even"><td>liw</td>
<td>Length of integer work array, similiar as &lt;lrw&gt;.</td>
</tr>
<tr class="row-odd"><td>jac_banded</td>
<td><p class="first">A callable object to define the banded Jacobian
matrix(df/du) of right-hand side function f.
Used in Lsode, Lsoda, Lsodar.</p>
<blockquote class="last">
<div>jac_banded(u,t,ml,mu) returns df/du
vector * float * int * int &#8211;&gt;   2d-array</div></blockquote>
</td>
</tr>
<tr class="row-even"><td>jac_banded_f77</td>
<td><p class="first">Intend to supply a Fortran subroutine as jac_banded. This subroutine should be defined in form:</p>
<div class="last highlight-python"><pre> subroutine jac_banded_f77(neq,t,u,ml
     1 ,mu,pd,nrowpd)
Cf2py intent(out) pd
      integer neq,ml,mu,nrowpd
      double precision t,u,pd
      dimension u(neq),pd(nrowpd,neq)
      pd = ...
      return
      end</pre>
</div>
</td>
</tr>
<tr class="row-odd"><td>ml</td>
<td>Lower half-bandwidth of banded jacobian matrix</td>
</tr>
<tr class="row-even"><td>mu</td>
<td>Upper half-bandwidth of banded jacobian matrix</td>
</tr>
<tr class="row-odd"><td>jac</td>
<td>Jacobian of right-hand side function f (df/du) (d
efault: None)</td>
</tr>
<tr class="row-even"><td>jac_f77</td>
<td><p class="first">Intend to supply a Fortran subroutine as jac.
This subroutine should be defined in form:</p>
<div class="last highlight-python"><pre>      subroutine jac_f77(neq,t,u,ml,mu,pd,
     1      nrowpd)
Cf2py intent(hide) neq,ml,mu,nrowpd
Cf2py intent(out) pd
      integer neq,ml,mu,nrowpd
      double precision t,u,pd
      dimension u(neq),pd(neq,neq)
      pd = ...
      return
      end</pre>
</div>
</td>
</tr>
<tr class="row-odd"><td>order</td>
<td>Maximum order used by the integrator (&lt;= 12 for &#8221;
adams&#8221;, &lt;= 5 for &#8220;bdf&#8221;) (default: 4)</td>
</tr>
<tr class="row-even"><td>f_f77</td>
<td><p class="first">Intend to supply a Fortran subroutine as f.
This subroutine should be defined in form:</p>
<div class="last highlight-python"><pre>      subroutine f_f77(neq,t,u,udot)
Cf2py intent(hide)   neq
Cf2py intent(out)    udot
      integer neq
      double precision t,u(neq),udot(neq)
      udot = ...
      return
      end</pre>
</div>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_atol</span></tt>(u_current)</td>
<td>Error tolerance tol(i) became zero for some i during integration, where tol = rtol(i) * u(i) + atol(i).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsode.adjust_parameters" title="odesolvers.odepack.Lsode.adjust_parameters"><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt></a>()</td>
<td>Properties for new parameters in this solver.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td>This function intends to one step forward for linearly solvers</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_iaja</span></tt>()</td>
<td>ia, ja, ic, jc are optional inputs to describe arbitrary sparse</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_liwlrw</span></tt>()</td>
<td>If the lengths of work arrays are specified by users, check whether</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_pars</span></tt>()</td>
<td>Some pairs of parameters should be input simutaneously.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_tol</span></tt>()</td>
<td>atol &amp; rtol should be defined as scalars or vectors with length neq.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">expand_iwork</span></tt>(new_liw[,&nbsp;expand])</td>
<td>Extension module return an actually required length for integer work array when it is too short.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">expand_rwork</span></tt>(new_lrw[,&nbsp;expand])</td>
<td>Length of real work array is smaller than actually required length.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Import extension module _odesolver and check that it exists.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td>In the long parameter-lists for solvers in ODEPACK, quite a few</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">new_stepnr</span></tt>()</td>
<td>When Fortran code returns a status &#8220;istate==-1&#8221;, it indicates that</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">print_roots</span></tt>(jroot,&nbsp;t_current,&nbsp;u_current)</td>
<td>Roots found at current T for some constraint functions.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_dummy_functions</span></tt>()</td>
<td>Functions have to get dummy values before they are passed to extension</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Lsode.set_extra_args" title="odesolvers.odepack.Lsode.set_extra_args"><tt class="xref py py-obj docutils literal"><span class="pre">set_extra_args</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Lsode.set_iopt" title="odesolvers.odepack.Lsode.set_iopt"><tt class="xref py py-obj docutils literal"><span class="pre">set_iopt</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsode.set_iter_method" title="odesolvers.odepack.Lsode.set_iter_method"><tt class="xref py py-obj docutils literal"><span class="pre">set_iter_method</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_iwork_rwork</span></tt>()</td>
<td>Initialize arrays for optional inputs, and calculate the</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsode.set_jac" title="odesolvers.odepack.Lsode.set_jac"><tt class="xref py py-obj docutils literal"><span class="pre">set_jac</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Lsode.set_liw_min" title="odesolvers.odepack.Lsode.set_liw_min"><tt class="xref py py-obj docutils literal"><span class="pre">set_liw_min</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsode.set_lrw_min" title="odesolvers.odepack.Lsode.set_lrw_min"><tt class="xref py py-obj docutils literal"><span class="pre">set_lrw_min</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_ydoti</span></tt>()</td>
<td>&#8220;ydoti&#8221; is an array used in linearly solvers.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>This function is involved for non-linearly solvers in ODEPACK, i.e.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">tol_multiply</span></tt>(tolsf)</td>
<td>This function is used to adjust tolerance parameters for Fortran part.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>Common validity check in Odepack.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odesolvers.odepack.Lsode.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.odepack'</em><a class="headerlink" href="#odesolvers.odepack.Lsode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsode.adjust_parameters">
<tt class="descname">adjust_parameters</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsode.adjust_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsode.adjust_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Properties for new parameters in this solver.</p>
</dd></dl>

<dl class="attribute">
<dt id="odesolvers.odepack.Lsode.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'LSODE solver for a stiff or nonstiff system'</em><a class="headerlink" href="#odesolvers.odepack.Lsode.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsode.set_extra_args">
<tt class="descname">set_extra_args</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsode.set_extra_args"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsode.set_extra_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsode.set_iopt">
<tt class="descname">set_iopt</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsode.set_iopt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsode.set_iopt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsode.set_iter_method">
<tt class="descname">set_iter_method</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsode.set_iter_method"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsode.set_iter_method" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsode.set_jac">
<tt class="descname">set_jac</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsode.set_jac"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsode.set_jac" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsode.set_liw_min">
<tt class="descname">set_liw_min</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsode.set_liw_min"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsode.set_liw_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsode.set_lrw_min">
<tt class="descname">set_lrw_min</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsode.set_lrw_min"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsode.set_lrw_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.odepack.Lsodes">
<em class="property">class </em><tt class="descclassname">odesolvers.odepack.</tt><tt class="descname">Lsodes</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.odepack.Odepack" title="odesolvers.odepack.Odepack"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.odepack.Odepack</span></tt></a></p>
<p>A variant of the DLSODE package, and is intended for initial problems
in which the Jacobian matrix df/du has an arbitrary sparse structure
(when the problem is stiff):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">du</span><span class="o">/</span><span class="n">dt</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">t</span><span class="p">),</span>
</pre></div>
</div>
<p>or, in component form:</p>
<div class="highlight-python"><pre>du(i)/dt = f(u,t)[i] for i in 1,...,neq</pre>
</div>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
<tr class="row-odd"><td>atol</td>
<td>absolute tolerance for solution (default: 1e-08)</td>
</tr>
<tr class="row-even"><td>rtol</td>
<td>relative tolerance for solution (default: 1e-06)</td>
</tr>
<tr class="row-odd"><td>adams_or_bdf</td>
<td>Method in vode or solvers in odepack: &#8220;adams&#8221; or
&#8220;bdf&#8221; (default: adams)</td>
</tr>
<tr class="row-even"><td>nsteps</td>
<td>Max no of internal solver steps per time step (de
fault: 1000)</td>
</tr>
<tr class="row-odd"><td>first_step</td>
<td>Suggested first time step size for an adaptive al
gorithm</td>
</tr>
<tr class="row-even"><td>min_step</td>
<td>Minimum step size for an adaptive algorithm</td>
</tr>
<tr class="row-odd"><td>max_step</td>
<td>Maximum step size for an adaptive algorithm</td>
</tr>
<tr class="row-even"><td>iter_method</td>
<td>Corrector iteration method choice</td>
</tr>
<tr class="row-odd"><td>lrw</td>
<td>Length of real work array.</td>
</tr>
<tr class="row-even"><td>liw</td>
<td>Length of integer work array, similiar as &lt;lrw&gt;.</td>
</tr>
<tr class="row-odd"><td>order</td>
<td>Maximum order used by the integrator (&lt;= 12 for &#8221;
adams&#8221;, &lt;= 5 for &#8220;bdf&#8221;) (default: 4)</td>
</tr>
<tr class="row-even"><td>moss</td>
<td>Method to obtain sparse structure of Jacobian.</td>
</tr>
<tr class="row-odd"><td>seth</td>
<td>Element threshhold for sparsity determination. (d
efault: 0)</td>
</tr>
<tr class="row-even"><td>jac_column</td>
<td><dl class="first last docutils">
<dt>A callable object to specify a column of Jacobian</dt>
<dd>(df/du) matrix.</dd>
<dt>jac(u,t,j,ia,ja): jth column of Jacobian (df/du)</dt>
<dd>vector * float * integer * integer vector
* integer vector    &#8212;&gt;  vector</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td>ia</td>
<td>Integer array with length neq+1 which contains
starting locations in ja of the descriptions
for columns 1...neq, in that order, with ia(1)
== 1. The last element ia[neq+1] should equal
to the total number of nonzero locations assumed.
For each column j = 1...neq, the values of the
row index i in column j, where a nonzero element
may occur, are given by i == ja(k) where ia(j) &lt;=
k &lt; ia(j+1).</td>
</tr>
<tr class="row-even"><td>ja</td>
<td>Integer array containing the row indices where
nonzero elements occur, reading in columnwise
order.
Describes the sparsity matrix structure
together with ia.
In Lsodes, ia &amp; ja describe the structure of
Jacobian matrix; while in Lsodis, ia &amp; ja are
used to describe the structure of matrix A.</td>
</tr>
<tr class="row-odd"><td>jac_column_f77</td>
<td><p class="first">Intend to supply a Fortran subroutine as
jac_column.
This subroutine should be defined in form:</p>
<div class="last highlight-python"><pre>      subroutine jac_column_f77(neq, t, u, j,
     1       ia, ja, pd)
Cf2py intent(hide) neq, ia, ja
Cf2py intent(out) pd
      integer neq, j, ia, ja
      double precision t, u, pd
      dimension u(neq), pd(neq), ia(neq + 1),
     1       ja(*)
      pd = ...
      return
      end</pre>
</div>
</td>
</tr>
<tr class="row-even"><td>f_f77</td>
<td><p class="first">Intend to supply a Fortran subroutine as f.
This subroutine should be defined in form:</p>
<div class="last highlight-python"><pre>      subroutine f_f77(neq,t,u,udot)
Cf2py intent(hide)   neq
Cf2py intent(out)    udot
      integer neq
      double precision t,u(neq),udot(neq)
      udot = ...
      return
      end</pre>
</div>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_atol</span></tt>(u_current)</td>
<td>Error tolerance tol(i) became zero for some i during integration, where tol = rtol(i) * u(i) + atol(i).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsodes.adjust_parameters" title="odesolvers.odepack.Lsodes.adjust_parameters"><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt></a>()</td>
<td>Properties for new parameters in this solver.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td>This function intends to one step forward for linearly solvers</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_iaja</span></tt>()</td>
<td>ia, ja, ic, jc are optional inputs to describe arbitrary sparse</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_liwlrw</span></tt>()</td>
<td>If the lengths of work arrays are specified by users, check whether</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_pars</span></tt>()</td>
<td>Some pairs of parameters should be input simutaneously.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_tol</span></tt>()</td>
<td>atol &amp; rtol should be defined as scalars or vectors with length neq.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">expand_iwork</span></tt>(new_liw[,&nbsp;expand])</td>
<td>Extension module return an actually required length for integer work array when it is too short.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">expand_rwork</span></tt>(new_lrw[,&nbsp;expand])</td>
<td>Length of real work array is smaller than actually required length.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Import extension module _odesolver and check that it exists.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td>In the long parameter-lists for solvers in ODEPACK, quite a few</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">new_stepnr</span></tt>()</td>
<td>When Fortran code returns a status &#8220;istate==-1&#8221;, it indicates that</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">print_roots</span></tt>(jroot,&nbsp;t_current,&nbsp;u_current)</td>
<td>Roots found at current T for some constraint functions.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_dummy_functions</span></tt>()</td>
<td>Functions have to get dummy values before they are passed to extension</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_extra_args</span></tt>()</td>
<td>Setting for extra parameters of user-defined functions.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Lsodes.set_iopt" title="odesolvers.odepack.Lsodes.set_iopt"><tt class="xref py py-obj docutils literal"><span class="pre">set_iopt</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsodes.set_iter_method" title="odesolvers.odepack.Lsodes.set_iter_method"><tt class="xref py py-obj docutils literal"><span class="pre">set_iter_method</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Lsodes.set_iwork_rwork" title="odesolvers.odepack.Lsodes.set_iwork_rwork"><tt class="xref py py-obj docutils literal"><span class="pre">set_iwork_rwork</span></tt></a>()</td>
<td>Initialization of work arrays with caculated length and optional inputs.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_jac</span></tt>()</td>
<td>Set values for Jacobian matrix. In several solvers like Lsode,</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_liw_min</span></tt>()</td>
<td>Calculate the necessary length of integer work arrays when it is not specified explicitly by users.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_lrw_min</span></tt>()</td>
<td>Calculate the necessary length of real work arrays for Fortran code.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_ydoti</span></tt>()</td>
<td>&#8220;ydoti&#8221; is an array used in linearly solvers.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>This function is involved for non-linearly solvers in ODEPACK, i.e.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">tol_multiply</span></tt>(tolsf)</td>
<td>This function is used to adjust tolerance parameters for Fortran part.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>Common validity check in Odepack.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odesolvers.odepack.Lsodes.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.odepack'</em><a class="headerlink" href="#odesolvers.odepack.Lsodes.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodes.adjust_parameters">
<tt class="descname">adjust_parameters</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodes.adjust_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodes.adjust_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Properties for new parameters in this solver.</p>
</dd></dl>

<dl class="attribute">
<dt id="odesolvers.odepack.Lsodes.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'LSODES solver for sparse Jacobians'</em><a class="headerlink" href="#odesolvers.odepack.Lsodes.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodes.set_iopt">
<tt class="descname">set_iopt</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodes.set_iopt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodes.set_iopt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodes.set_iter_method">
<tt class="descname">set_iter_method</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodes.set_iter_method"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodes.set_iter_method" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodes.set_iwork_rwork">
<tt class="descname">set_iwork_rwork</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodes.set_iwork_rwork"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodes.set_iwork_rwork" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialization of work arrays with caculated length and optional inputs.
In ODEPACK, &#8220;iwork&#8221; &amp; &#8220;rwork&#8221; should be initialized with the specific
optional parameters in all the solvers.
&#8220;liw&#8221; &amp; &#8220;lrw&#8221; represented the length requirement of work arrays.
Specially, in Dlsodes, ia &amp; ja should be attached to iwork_in.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.odepack.Lsodi">
<em class="property">class </em><tt class="descclassname">odesolvers.odepack.</tt><tt class="descname">Lsodi</tt><big>(</big><em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodi" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.odepack.Odepack" title="odesolvers.odepack.Odepack"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.odepack.Odepack</span></tt></a></p>
<p>A variant version of the DLSODE package.
Solves the initial value problem for linearly implicit systems of first
order ODEs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">du</span><span class="o">/</span><span class="n">dt</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">u</span><span class="p">)</span> <span class="p">,</span>
</pre></div>
</div>
<p>where A(u,t) is a square matrix.
Or, in component form:</p>
<div class="highlight-python"><pre>( a   * ( du / dt ))  + ... +  ( a     * ( du   / dt ))  =
   i,1      1                     i,NEQ      NEQ
 =   g ( t, u , u ,..., u    )   ( i = 1,...,NEQ )
      i      1   2       NEQ</pre>
</div>
<p>If A is singular, this is a differential-algebraic system.
Either res or res_f77 need to be supplied.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
<tr class="row-odd"><td>atol</td>
<td>absolute tolerance for solution (default: 1e-08)</td>
</tr>
<tr class="row-even"><td>rtol</td>
<td>relative tolerance for solution (default: 1e-06)</td>
</tr>
<tr class="row-odd"><td>adams_or_bdf</td>
<td>Method in vode or solvers in odepack: &#8220;adams&#8221; or
&#8220;bdf&#8221; (default: adams)</td>
</tr>
<tr class="row-even"><td>nsteps</td>
<td>Max no of internal solver steps per time step (de
fault: 1000)</td>
</tr>
<tr class="row-odd"><td>first_step</td>
<td>Suggested first time step size for an adaptive al
gorithm</td>
</tr>
<tr class="row-even"><td>min_step</td>
<td>Minimum step size for an adaptive algorithm</td>
</tr>
<tr class="row-odd"><td>max_step</td>
<td>Maximum step size for an adaptive algorithm</td>
</tr>
<tr class="row-even"><td>iter_method</td>
<td>Corrector iteration method choice</td>
</tr>
<tr class="row-odd"><td>lrw</td>
<td>Length of real work array.</td>
</tr>
<tr class="row-even"><td>liw</td>
<td>Length of integer work array, similiar as &lt;lrw&gt;.</td>
</tr>
<tr class="row-odd"><td>adda_lsodi</td>
<td><p class="first">Callable object to add the matrix A = A(u,t) to
another matrix p stored in the same form as A.
addaName(u,t,p)  :   vector * float * 2d-array</p>
<blockquote class="last">
<div>&#8212;-&gt;  2d-array with dimension (neq,neq)</div></blockquote>
</td>
</tr>
<tr class="row-even"><td>adda_banded_lsodi</td>
<td><p class="first">Callable object to add the banded matrix
A = A(u,t) to another matrix stored P in the
same form as A, i.e. add A(i,j)to P(i-j+MU+1,j)
addaName(u,t,p,ml,mu):
vector * float * 2d-array * int * int</p>
<blockquote class="last">
<div>&#8212;&gt;  2d-array with dimension (<a href="#id1"><span class="problematic" id="id2">*</span></a>,neq)</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td>adda_lsodi_f77</td>
<td><p class="first">Intend to supply a Fortran subroutine as
adda_lsodi.
This subroutine should be defined in form:</p>
<div class="last highlight-python"><pre>      subroutine adda_lsodi_f77(neq, t, u, ml,
     1       mu, pd, nrowpd)
Cf2py intent(in, hide) neq, ml, mu
Cf2py intent(in, hide), depend(pd) nrowpd
Cf2py intent(in, out) pd
      integer neq, ml, mu, nrowpd
      double precision t, u, pd
      dimension u(neq), pd(nrowpd, neq)
      pd = ...
      return
      end</pre>
</div>
</td>
</tr>
<tr class="row-even"><td>adda_banded_lsodi_f77</td>
<td><p class="first">Intend to supply a Fortran subroutine as
adda_banded.
This subroutine should be defined in form:</p>
<div class="last highlight-python"><pre>      subroutine adda_banded_lsodi_f77(neq, t,
     1         u, ml, mu, pd, nrowpd)
Cf2py intent(in, hide) neq, ml, mu
Cf2py intent(in, hide), depend(pd) nrowpd
Cf2py intent(in, out) pd
      integer neq, ml, mu, nrowpd
      double precision t, u, pd
      dimension u(neq), pd(nrowpd, neq)
      pd = ...
      return
      end</pre>
</div>
</td>
</tr>
<tr class="row-odd"><td>jac_lsodi</td>
<td><p class="first">Callable object to define the full Jacobian
matrix dr/du where r = g - A*s.
jac(u,t,s)    &#8211;&gt; dr/du
vector * float * vector</p>
<blockquote class="last">
<div>&#8212;-&gt;  2d-array with dimension (neq,neq)</div></blockquote>
</td>
</tr>
<tr class="row-even"><td>jac_banded_lsodi</td>
<td><p class="first">Callable object to define the banded Jacobian
matrix dr/du where r = g - A*s.
jac(u,t,s,ml,mu), where ml &amp; mu are lower &amp; upper
half-bandwidth of banded matrix.
vector * float * vector * int * int</p>
<blockquote class="last">
<div>&#8212;&gt;  2d-array with dimension (<a href="#id3"><span class="problematic" id="id4">*</span></a>,neq)</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td>jac_lsodi_f77</td>
<td><p class="first">Intend to supply Fortran subroutine as jac_lsodi.
This subroutine should be defined in form:</p>
<div class="last highlight-python"><pre>      subroutine jac_lsodi_f77(neq, t, u, s, ml,
     1           mu, pd, nrowpd)
Cf2py intent(in, hide) neq, ml, mu, nrowpd
Cf2py intent(out) pd
      integer neq, ml, mu, nrowpd
      double precision t, u, pd, s
      dimension u(neq), s(neq), pd(nrowpd, neq)
      pd = ...
      return
      end</pre>
</div>
</td>
</tr>
<tr class="row-even"><td>jac_banded_lsodi_f77</td>
<td><p class="first">Intend to supply a Fortran subroutine as
jac_banded_lsodi.
This subroutine should be defined in form:</p>
<div class="last highlight-python"><pre>      subroutine jac_banded_lsodi_f77(neq, t, u,
     1      s, ml, mu, pd, nrowpd)
Cf2py intent(in, hide) neq, ml, mu, nrowpd
Cf2py intent(out) pd
      integer neq, ml, mu, nrowpd
      double precision t, u, pd, s
      dimension u(neq), s(neq), pd(nrowpd, neq)
      pd = ...
      return
      end</pre>
</div>
</td>
</tr>
<tr class="row-odd"><td>res</td>
<td><p class="first">User-supplied function to calculate the residual
vector, defined by r =  g(u,t) - A(u,t) * s.
Used in the linearly implicit solvers: Lsodi,
Lsodis, Lsoibt.
res(u,t,s,ires)   &#8211;&gt;   (r,ires)
vector * float * vector * int &#8211;&gt;  vector * int</p>
<blockquote>
<div>&#8220;ires&#8221; is a flag both for input and output.</div></blockquote>
<p>On input, ires indicates how ODEPACK would use
the returned array &#8220;r&#8221;:
ires == 1: the full residual exactly.
ires == 2: &#8220;r&#8221; is used only to computejacobian</p>
<blockquote>
<div>dr/du by difference quotients.</div></blockquote>
<p class="last">&#8220;res&#8221; should set flag &#8220;ires&#8221; if it encounters a
halt condition or illegal input. Otherwise, it
should not be reset. On output, value 1 or -1
represents a normal return.</p>
</td>
</tr>
<tr class="row-even"><td>order</td>
<td>Maximum order used by the integrator (&lt;= 12 for &#8221;
adams&#8221;, &lt;= 5 for &#8220;bdf&#8221;) (default: 4)</td>
</tr>
<tr class="row-odd"><td>ml</td>
<td>Lower half-bandwidth of banded jacobian matrix</td>
</tr>
<tr class="row-even"><td>mu</td>
<td>Upper half-bandwidth of banded jacobian matrix</td>
</tr>
<tr class="row-odd"><td>ydoti</td>
<td>Real array for the initial value of dy/dt. (defau
lt: [])</td>
</tr>
<tr class="row-even"><td>nsteps</td>
<td>Max no of internal solver steps per time step (de
fault: 1000)</td>
</tr>
<tr class="row-odd"><td>res_f77</td>
<td><p class="first">Intend to supply a Fortran subroutine as res.
This subroutine should be defined in form:</p>
<div class="last highlight-python"><pre>     subroutine res_f77(neq, t, u, s, r, ires)
Cf2py intent(hide) neq
Cf2py intent(out) r
Cf2py intent(in,out) ires
     double precision t, u, s, r
     dimension u(neq, s(neq), r(neq)
     ...
     return
     end</pre>
</div>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_atol</span></tt>(u_current)</td>
<td>Error tolerance tol(i) became zero for some i during integration, where tol = rtol(i) * u(i) + atol(i).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsodi.adjust_parameters" title="odesolvers.odepack.Lsodi.adjust_parameters"><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td>This function intends to one step forward for linearly solvers</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_iaja</span></tt>()</td>
<td>ia, ja, ic, jc are optional inputs to describe arbitrary sparse</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_liwlrw</span></tt>()</td>
<td>If the lengths of work arrays are specified by users, check whether</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_pars</span></tt>()</td>
<td>Some pairs of parameters should be input simutaneously.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_tol</span></tt>()</td>
<td>atol &amp; rtol should be defined as scalars or vectors with length neq.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">expand_iwork</span></tt>(new_liw[,&nbsp;expand])</td>
<td>Extension module return an actually required length for integer work array when it is too short.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">expand_rwork</span></tt>(new_lrw[,&nbsp;expand])</td>
<td>Length of real work array is smaller than actually required length.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Import extension module _odesolver and check that it exists.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td>In the long parameter-lists for solvers in ODEPACK, quite a few</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">new_stepnr</span></tt>()</td>
<td>When Fortran code returns a status &#8220;istate==-1&#8221;, it indicates that</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">print_roots</span></tt>(jroot,&nbsp;t_current,&nbsp;u_current)</td>
<td>Roots found at current T for some constraint functions.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsodi.set_dummy_functions" title="odesolvers.odepack.Lsodi.set_dummy_functions"><tt class="xref py py-obj docutils literal"><span class="pre">set_dummy_functions</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Lsodi.set_extra_args" title="odesolvers.odepack.Lsodi.set_extra_args"><tt class="xref py py-obj docutils literal"><span class="pre">set_extra_args</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Lsodi.set_iopt" title="odesolvers.odepack.Lsodi.set_iopt"><tt class="xref py py-obj docutils literal"><span class="pre">set_iopt</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsodi.set_iter_method" title="odesolvers.odepack.Lsodi.set_iter_method"><tt class="xref py py-obj docutils literal"><span class="pre">set_iter_method</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Lsodi.set_iwork_rwork" title="odesolvers.odepack.Lsodi.set_iwork_rwork"><tt class="xref py py-obj docutils literal"><span class="pre">set_iwork_rwork</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsodi.set_jac" title="odesolvers.odepack.Lsodi.set_jac"><tt class="xref py py-obj docutils literal"><span class="pre">set_jac</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Lsodi.set_liw_min" title="odesolvers.odepack.Lsodi.set_liw_min"><tt class="xref py py-obj docutils literal"><span class="pre">set_liw_min</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsodi.set_lrw_min" title="odesolvers.odepack.Lsodi.set_lrw_min"><tt class="xref py py-obj docutils literal"><span class="pre">set_lrw_min</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_ydoti</span></tt>()</td>
<td>&#8220;ydoti&#8221; is an array used in linearly solvers.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsodi.solve" title="odesolvers.odepack.Lsodi.solve"><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt></a>(time_points[,&nbsp;terminate])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">tol_multiply</span></tt>(tolsf)</td>
<td>This function is used to adjust tolerance parameters for Fortran part.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>Common validity check in Odepack.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="odesolvers.odepack.Lsodi.__init__">
<tt class="descname">__init__</tt><big>(</big><em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodi.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodi.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.odepack.Lsodi.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.odepack'</em><a class="headerlink" href="#odesolvers.odepack.Lsodi.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodi.adjust_parameters">
<tt class="descname">adjust_parameters</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodi.adjust_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodi.adjust_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.odepack.Lsodi.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'LSODI solver for linearly implicit systems'</em><a class="headerlink" href="#odesolvers.odepack.Lsodi.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodi.set_dummy_functions">
<tt class="descname">set_dummy_functions</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodi.set_dummy_functions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodi.set_dummy_functions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodi.set_extra_args">
<tt class="descname">set_extra_args</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodi.set_extra_args"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodi.set_extra_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodi.set_iopt">
<tt class="descname">set_iopt</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodi.set_iopt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodi.set_iopt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodi.set_iter_method">
<tt class="descname">set_iter_method</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodi.set_iter_method"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodi.set_iter_method" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodi.set_iwork_rwork">
<tt class="descname">set_iwork_rwork</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodi.set_iwork_rwork"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodi.set_iwork_rwork" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodi.set_jac">
<tt class="descname">set_jac</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodi.set_jac"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodi.set_jac" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodi.set_liw_min">
<tt class="descname">set_liw_min</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodi.set_liw_min"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodi.set_liw_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodi.set_lrw_min">
<tt class="descname">set_lrw_min</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodi.set_lrw_min"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodi.set_lrw_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodi.solve">
<tt class="descname">solve</tt><big>(</big><em>time_points</em>, <em>terminate=None</em><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodi.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodi.solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.odepack.Lsodis">
<em class="property">class </em><tt class="descclassname">odesolvers.odepack.</tt><tt class="descname">Lsodis</tt><big>(</big><em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.odepack.Odepack" title="odesolvers.odepack.Odepack"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.odepack.Odepack</span></tt></a></p>
<p>A variant version of Lsodi, and is intended for stiff problems
in which the matrix A and the Jacobian matrix d(g - A*s)/du have
arbitrary sparse structures.
Solves the initial value problem for linearly implicit systems
of first order ODEs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">du</span><span class="o">/</span><span class="n">dt</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">t</span><span class="p">),</span>
</pre></div>
</div>
<p>where A(u,t) is a square matrix.
Or, in component form:</p>
<div class="highlight-python"><pre>( a   * ( du / dt ))  + ... +  ( a     * ( du   / dt ))  =
   i,1      1                     i,NEQ      NEQ
 =   g ( t, u , u ,..., u    )   ( i = 1,...,NEQ )
      i      1   2       NEQ</pre>
</div>
<p>If A is singular, this is a differential-algebraic system.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>res</td>
<td><p class="first">User-supplied function to calculate the residual
vector, defined by r =  g(u,t) - A(u,t) * s.
Used in the linearly implicit solvers: Lsodi,
Lsodis, Lsoibt.
res(u,t,s,ires)   &#8211;&gt;   (r,ires)
vector * float * vector * int &#8211;&gt;  vector * int</p>
<blockquote>
<div>&#8220;ires&#8221; is a flag both for input and output.</div></blockquote>
<p>On input, ires indicates how ODEPACK would use
the returned array &#8220;r&#8221;:
ires == 1: the full residual exactly.
ires == 2: &#8220;r&#8221; is used only to computejacobian</p>
<blockquote>
<div>dr/du by difference quotients.</div></blockquote>
<p class="last">&#8220;res&#8221; should set flag &#8220;ires&#8221; if it encounters a
halt condition or illegal input. Otherwise, it
should not be reset. On output, value 1 or -1
represents a normal return.</p>
</td>
</tr>
<tr class="row-odd"><td>adda_lsodis</td>
<td><p class="first">Callable object to add j-th column of matrix
A = A(u,t) to another matrix stored in sparse
form.
adda(u,t,j,ia,ja,p)  :   &#8211;&gt; p
vector * float * int * int vector * int vector</p>
<blockquote class="last">
<div><ul class="simple">
<li>vector      &#8212;&gt;  vector</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
<tr class="row-odd"><td>atol</td>
<td>absolute tolerance for solution (default: 1e-08)</td>
</tr>
<tr class="row-even"><td>rtol</td>
<td>relative tolerance for solution (default: 1e-06)</td>
</tr>
<tr class="row-odd"><td>adams_or_bdf</td>
<td>Method in vode or solvers in odepack: &#8220;adams&#8221; or
&#8220;bdf&#8221; (default: adams)</td>
</tr>
<tr class="row-even"><td>nsteps</td>
<td>Max no of internal solver steps per time step (de
fault: 1000)</td>
</tr>
<tr class="row-odd"><td>first_step</td>
<td>Suggested first time step size for an adaptive al
gorithm</td>
</tr>
<tr class="row-even"><td>min_step</td>
<td>Minimum step size for an adaptive algorithm</td>
</tr>
<tr class="row-odd"><td>max_step</td>
<td>Maximum step size for an adaptive algorithm</td>
</tr>
<tr class="row-even"><td>iter_method</td>
<td>Corrector iteration method choice</td>
</tr>
<tr class="row-odd"><td>lrw</td>
<td>Length of real work array.</td>
</tr>
<tr class="row-even"><td>liw</td>
<td>Length of integer work array, similiar as &lt;lrw&gt;.</td>
</tr>
<tr class="row-odd"><td>jac_lsodis</td>
<td><p class="first">Callable object to supply the jth column of
the sparse Jacobian matrix dr/du where
r = g - A*s.
jac(u,t,s,j,ia,ja)   &#8212;&#8211;&gt;   p
vector * float * vector * int * int vector</p>
<blockquote class="last">
<div><ul class="simple">
<li>int vector      &#8212;&#8212;&gt;   vector</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td>moss</td>
<td>Method to obtain sparse structure of Jacobian.</td>
</tr>
<tr class="row-odd"><td>ia</td>
<td>Integer array with length neq+1 which contains
starting locations in ja of the descriptions
for columns 1...neq, in that order, with ia(1)
== 1. The last element ia[neq+1] should equal
to the total number of nonzero locations assumed.
For each column j = 1...neq, the values of the
row index i in column j, where a nonzero element
may occur, are given by i == ja(k) where ia(j) &lt;=
k &lt; ia(j+1).</td>
</tr>
<tr class="row-even"><td>ja</td>
<td>Integer array containing the row indices where
nonzero elements occur, reading in columnwise
order.
Describes the sparsity matrix structure
together with ia.
In Lsodes, ia &amp; ja describe the structure of
Jacobian matrix; while in Lsodis, ia &amp; ja are
used to describe the structure of matrix A.</td>
</tr>
<tr class="row-odd"><td>ic</td>
<td>Array which contains starting locations in jc.</td>
</tr>
<tr class="row-even"><td>jc</td>
<td>Integer array which describes the sparsity
Jacobian structure together with ic, like ia
and ja.
In Lsodis, ia and ja describe the sparse
structure of matrix A, while ic &amp; jc describe
the sparse structure of Jacobian matrix.</td>
</tr>
<tr class="row-odd"><td>ydoti</td>
<td>Real array for the initial value of dy/dt. (defau
lt: [])</td>
</tr>
<tr class="row-even"><td>order</td>
<td>Maximum order used by the integrator (&lt;= 12 for &#8221;
adams&#8221;, &lt;= 5 for &#8220;bdf&#8221;) (default: 4)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_atol</span></tt>(u_current)</td>
<td>Error tolerance tol(i) became zero for some i during integration, where tol = rtol(i) * u(i) + atol(i).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsodis.adjust_parameters" title="odesolvers.odepack.Lsodis.adjust_parameters"><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td>This function intends to one step forward for linearly solvers</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_iaja</span></tt>()</td>
<td>ia, ja, ic, jc are optional inputs to describe arbitrary sparse</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_liwlrw</span></tt>()</td>
<td>If the lengths of work arrays are specified by users, check whether</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_pars</span></tt>()</td>
<td>Some pairs of parameters should be input simutaneously.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_tol</span></tt>()</td>
<td>atol &amp; rtol should be defined as scalars or vectors with length neq.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">expand_iwork</span></tt>(new_liw[,&nbsp;expand])</td>
<td>Extension module return an actually required length for integer work array when it is too short.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">expand_rwork</span></tt>(new_lrw[,&nbsp;expand])</td>
<td>Length of real work array is smaller than actually required length.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Import extension module _odesolver and check that it exists.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td>In the long parameter-lists for solvers in ODEPACK, quite a few</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">new_stepnr</span></tt>()</td>
<td>When Fortran code returns a status &#8220;istate==-1&#8221;, it indicates that</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">print_roots</span></tt>(jroot,&nbsp;t_current,&nbsp;u_current)</td>
<td>Roots found at current T for some constraint functions.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsodis.set_dummy_functions" title="odesolvers.odepack.Lsodis.set_dummy_functions"><tt class="xref py py-obj docutils literal"><span class="pre">set_dummy_functions</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_extra_args</span></tt>()</td>
<td>Setting for extra parameters of user-defined functions.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Lsodis.set_iopt" title="odesolvers.odepack.Lsodis.set_iopt"><tt class="xref py py-obj docutils literal"><span class="pre">set_iopt</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsodis.set_iter_method" title="odesolvers.odepack.Lsodis.set_iter_method"><tt class="xref py py-obj docutils literal"><span class="pre">set_iter_method</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Lsodis.set_iwork_rwork" title="odesolvers.odepack.Lsodis.set_iwork_rwork"><tt class="xref py py-obj docutils literal"><span class="pre">set_iwork_rwork</span></tt></a>()</td>
<td>Initialization of work arrays with caculated length and optional inputs.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_jac</span></tt>()</td>
<td>Set values for Jacobian matrix. In several solvers like Lsode,</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_liw_min</span></tt>()</td>
<td>Calculate the necessary length of integer work arrays when it is not specified explicitly by users.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_lrw_min</span></tt>()</td>
<td>Calculate the necessary length of real work arrays for Fortran code.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_ydoti</span></tt>()</td>
<td>&#8220;ydoti&#8221; is an array used in linearly solvers.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsodis.solve" title="odesolvers.odepack.Lsodis.solve"><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt></a>(time_points[,&nbsp;terminate])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">tol_multiply</span></tt>(tolsf)</td>
<td>This function is used to adjust tolerance parameters for Fortran part.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>Common validity check in Odepack.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="odesolvers.odepack.Lsodis.__init__">
<tt class="descname">__init__</tt><big>(</big><em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodis.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodis.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.odepack.Lsodis.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.odepack'</em><a class="headerlink" href="#odesolvers.odepack.Lsodis.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodis.adjust_parameters">
<tt class="descname">adjust_parameters</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodis.adjust_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodis.adjust_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.odepack.Lsodis.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'LSODIS solver for linearly implicit sparse systems'</em><a class="headerlink" href="#odesolvers.odepack.Lsodis.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodis.set_dummy_functions">
<tt class="descname">set_dummy_functions</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodis.set_dummy_functions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodis.set_dummy_functions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodis.set_iopt">
<tt class="descname">set_iopt</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodis.set_iopt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodis.set_iopt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodis.set_iter_method">
<tt class="descname">set_iter_method</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodis.set_iter_method"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodis.set_iter_method" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodis.set_iwork_rwork">
<tt class="descname">set_iwork_rwork</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodis.set_iwork_rwork"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodis.set_iwork_rwork" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialization of work arrays with caculated length and optional inputs.
In ODEPACK, &#8220;iwork&#8221; &amp; &#8220;rwork&#8221; should be initialized with the specific
optional parameters in all the solvers.
&#8220;liw&#8221; &amp; &#8220;lrw&#8221; represented the length requirement of work arrays.
Specially, in Lsodis, (ia, ja, ic &amp; jc) should be attached to
iwork.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsodis.solve">
<tt class="descname">solve</tt><big>(</big><em>time_points</em>, <em>terminate=None</em><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsodis.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsodis.solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.odepack.Lsoibt">
<em class="property">class </em><tt class="descclassname">odesolvers.odepack.</tt><tt class="descname">Lsoibt</tt><big>(</big><em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsoibt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsoibt" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.odepack.Odepack" title="odesolvers.odepack.Odepack"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.odepack.Odepack</span></tt></a></p>
<p>A variant version of Lsodi_ODEPACK, for the case where the matrices
A, dg/du, and d(A*s)/du are all block-tridiagonal.
Solves the initial value problem for linearly implicit systems of first
order ODEs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">du</span><span class="o">/</span><span class="n">dt</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">t</span><span class="p">),</span>
</pre></div>
</div>
<p>where A(u,t) is a square matrix.
Or, in component form:</p>
<div class="highlight-python"><pre>( a   * ( du / dt ))  + ... +  ( a     * ( du   / dt ))  =
   i,1      1                     i,NEQ      NEQ
 =   g ( t, u , u ,..., u    )   ( i = 1,...,NEQ )
      i      1   2       NEQ</pre>
</div>
<p>If A is singular, this is a differential-algebraic system.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>res</td>
<td><p class="first">User-supplied function to calculate the residual
vector, defined by r =  g(u,t) - A(u,t) * s.
Used in the linearly implicit solvers: Lsodi,
Lsodis, Lsoibt.
res(u,t,s,ires)   &#8211;&gt;   (r,ires)
vector * float * vector * int &#8211;&gt;  vector * int</p>
<blockquote>
<div>&#8220;ires&#8221; is a flag both for input and output.</div></blockquote>
<p>On input, ires indicates how ODEPACK would use
the returned array &#8220;r&#8221;:
ires == 1: the full residual exactly.
ires == 2: &#8220;r&#8221; is used only to computejacobian</p>
<blockquote>
<div>dr/du by difference quotients.</div></blockquote>
<p class="last">&#8220;res&#8221; should set flag &#8220;ires&#8221; if it encounters a
halt condition or illegal input. Otherwise, it
should not be reset. On output, value 1 or -1
represents a normal return.</p>
</td>
</tr>
<tr class="row-odd"><td>adda_lsoibt</td>
<td><p class="first">Callable object to add matrix A = A(u,t) to
another matrix P, stored in block-tridiagonal
form.</p>
<blockquote>
<div>adda(u,t,pa,pb,pc)    &#8212;&#8211;&gt;  (pa,pb,pc)</div></blockquote>
<p>vector * float * (mb*mb*nb) array * (mb*mb*nb)
array * (mb*mb*nb) array</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>&#8211;&gt;  (mb*mb*nb) array * (mb*mb*nb) array *</dt>
<dd>(mb*mb*nb) array</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td>mb</td>
<td>Block size. Describe the block-tridiagonal form
of matrix A together with nb.</td>
</tr>
<tr class="row-odd"><td>nb</td>
<td>Number of blocks in the main diagonal.
In each of the NB block-rows of the matrix P
(each consisting of MB consecutive rows), the
nonzero elements are to lie in three
consecutive MB by MB blocks.  In block-rows 2
through NB - 1, these are centered about the
main diagonal. In block-rows 1 and NB, they
are the diagonal blocks and the two blocks
adjacent to the diagonal block.  (Thus block
positions (1,3) and (NB,NB-2) can be nonzero.)
Require: mb&gt;=1, nb&gt;=4, mb*nb==neq.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
<tr class="row-odd"><td>atol</td>
<td>absolute tolerance for solution (default: 1e-08)</td>
</tr>
<tr class="row-even"><td>rtol</td>
<td>relative tolerance for solution (default: 1e-06)</td>
</tr>
<tr class="row-odd"><td>adams_or_bdf</td>
<td>Method in vode or solvers in odepack: &#8220;adams&#8221; or
&#8220;bdf&#8221; (default: adams)</td>
</tr>
<tr class="row-even"><td>nsteps</td>
<td>Max no of internal solver steps per time step (de
fault: 1000)</td>
</tr>
<tr class="row-odd"><td>first_step</td>
<td>Suggested first time step size for an adaptive al
gorithm</td>
</tr>
<tr class="row-even"><td>min_step</td>
<td>Minimum step size for an adaptive algorithm</td>
</tr>
<tr class="row-odd"><td>max_step</td>
<td>Maximum step size for an adaptive algorithm</td>
</tr>
<tr class="row-even"><td>iter_method</td>
<td>Corrector iteration method choice</td>
</tr>
<tr class="row-odd"><td>lrw</td>
<td>Length of real work array.</td>
</tr>
<tr class="row-even"><td>liw</td>
<td>Length of integer work array, similiar as &lt;lrw&gt;.</td>
</tr>
<tr class="row-odd"><td>jac_lsoibt</td>
<td><p class="first">Callable object to supply the jth column of
the Jacobian matrix dr/du where r = g - A*s,
stored in block-tridiagonal form.
The argument list should in form of (u,t,s).</p>
<blockquote class="last">
<div><p>jac(u,t,s)   &#8212;&#8211;&gt;   (pa,pb,pc)
vector * float * vector   &#8212;&#8212;&gt;  (mb*mb*nb)</p>
<blockquote>
<div>array * (mb*mb*nb) array * (mb*mb*nb) array</div></blockquote>
<p>pa, pb, and pc are to be loaded with partial
derivatives (elements of the Jacobian matrix)
on output, in terms of the block-tridiagonal
structure assumed. That is, load the diagonal
blocks into pa, the superdiagonal blocks (and
block (nb,nb-2)) into pb, and the subdiagonal
blocks (and block (1,3)) into pc.
The blocks in block-row k of dr/du are to be
loaded into pa(<em>,</em>,k), pb(<em>,</em>,k), and
pc(<em>,</em>,k).
Thus the affect of this function should be:
pa(i,j,k) = ( (i.j) element of k-th diagonal</p>
<blockquote>
<div>block of dr/du)</div></blockquote>
<dl class="docutils">
<dt>pb(i,j,k) = ( (i,j) element of block (k,k+1)</dt>
<dd>of dr/du, or block (nb,nb-2) if
k == nb)</dd>
<dt>pc(i,j,k) = ( (i,j) element of block (k,k-1)</dt>
<dd>of dr/du, or block (1,3) if k==1)</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td>ydoti</td>
<td>Real array for the initial value of dy/dt. (defau
lt: [])</td>
</tr>
<tr class="row-odd"><td>order</td>
<td>Maximum order used by the integrator (&lt;= 12 for &#8221;
adams&#8221;, &lt;= 5 for &#8220;bdf&#8221;) (default: 4)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_atol</span></tt>(u_current)</td>
<td>Error tolerance tol(i) became zero for some i during integration, where tol = rtol(i) * u(i) + atol(i).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsoibt.adjust_parameters" title="odesolvers.odepack.Lsoibt.adjust_parameters"><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td>This function intends to one step forward for linearly solvers</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_iaja</span></tt>()</td>
<td>ia, ja, ic, jc are optional inputs to describe arbitrary sparse</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_liwlrw</span></tt>()</td>
<td>If the lengths of work arrays are specified by users, check whether</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_pars</span></tt>()</td>
<td>Some pairs of parameters should be input simutaneously.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_tol</span></tt>()</td>
<td>atol &amp; rtol should be defined as scalars or vectors with length neq.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">expand_iwork</span></tt>(new_liw[,&nbsp;expand])</td>
<td>Extension module return an actually required length for integer work array when it is too short.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">expand_rwork</span></tt>(new_lrw[,&nbsp;expand])</td>
<td>Length of real work array is smaller than actually required length.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Import extension module _odesolver and check that it exists.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td>In the long parameter-lists for solvers in ODEPACK, quite a few</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">new_stepnr</span></tt>()</td>
<td>When Fortran code returns a status &#8220;istate==-1&#8221;, it indicates that</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">print_roots</span></tt>(jroot,&nbsp;t_current,&nbsp;u_current)</td>
<td>Roots found at current T for some constraint functions.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsoibt.set_dummy_functions" title="odesolvers.odepack.Lsoibt.set_dummy_functions"><tt class="xref py py-obj docutils literal"><span class="pre">set_dummy_functions</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_extra_args</span></tt>()</td>
<td>Setting for extra parameters of user-defined functions.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Lsoibt.set_iopt" title="odesolvers.odepack.Lsoibt.set_iopt"><tt class="xref py py-obj docutils literal"><span class="pre">set_iopt</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsoibt.set_iter_method" title="odesolvers.odepack.Lsoibt.set_iter_method"><tt class="xref py py-obj docutils literal"><span class="pre">set_iter_method</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Lsoibt.set_iwork_rwork" title="odesolvers.odepack.Lsoibt.set_iwork_rwork"><tt class="xref py py-obj docutils literal"><span class="pre">set_iwork_rwork</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_jac</span></tt>()</td>
<td>Set values for Jacobian matrix. In several solvers like Lsode,</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Lsoibt.set_liw_min" title="odesolvers.odepack.Lsoibt.set_liw_min"><tt class="xref py py-obj docutils literal"><span class="pre">set_liw_min</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsoibt.set_lrw_min" title="odesolvers.odepack.Lsoibt.set_lrw_min"><tt class="xref py py-obj docutils literal"><span class="pre">set_lrw_min</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_ydoti</span></tt>()</td>
<td>&#8220;ydoti&#8221; is an array used in linearly solvers.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Lsoibt.solve" title="odesolvers.odepack.Lsoibt.solve"><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt></a>(time_points[,&nbsp;terminate])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">tol_multiply</span></tt>(tolsf)</td>
<td>This function is used to adjust tolerance parameters for Fortran part.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Lsoibt.validate_data" title="odesolvers.odepack.Lsoibt.validate_data"><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt></a>()</td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="odesolvers.odepack.Lsoibt.__init__">
<tt class="descname">__init__</tt><big>(</big><em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsoibt.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsoibt.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.odepack.Lsoibt.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.odepack'</em><a class="headerlink" href="#odesolvers.odepack.Lsoibt.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsoibt.adjust_parameters">
<tt class="descname">adjust_parameters</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsoibt.adjust_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsoibt.adjust_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.odepack.Lsoibt.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'LSOIBIT solver for linearly implicit block tridiag systems'</em><a class="headerlink" href="#odesolvers.odepack.Lsoibt.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsoibt.set_dummy_functions">
<tt class="descname">set_dummy_functions</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsoibt.set_dummy_functions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsoibt.set_dummy_functions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsoibt.set_iopt">
<tt class="descname">set_iopt</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsoibt.set_iopt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsoibt.set_iopt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsoibt.set_iter_method">
<tt class="descname">set_iter_method</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsoibt.set_iter_method"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsoibt.set_iter_method" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsoibt.set_iwork_rwork">
<tt class="descname">set_iwork_rwork</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsoibt.set_iwork_rwork"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsoibt.set_iwork_rwork" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsoibt.set_liw_min">
<tt class="descname">set_liw_min</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsoibt.set_liw_min"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsoibt.set_liw_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsoibt.set_lrw_min">
<tt class="descname">set_lrw_min</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsoibt.set_lrw_min"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsoibt.set_lrw_min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsoibt.solve">
<tt class="descname">solve</tt><big>(</big><em>time_points</em>, <em>terminate=None</em><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsoibt.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsoibt.solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Lsoibt.validate_data">
<tt class="descname">validate_data</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Lsoibt.validate_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Lsoibt.validate_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.odepack.Odepack">
<em class="property">class </em><tt class="descclassname">odesolvers.odepack.</tt><tt class="descname">Odepack</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Odepack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Odepack" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ODE.html#odesolvers.ODE.Solver" title="odesolvers.ODE.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.Solver</span></tt></a></p>
<p>This is a wrapper for seven solvers in Fortran package ODEPACK, which is
available at netlib repository, www.netlib.org/odepack.</p>
<p>Super class for the following set of solvers.</p>
<p><em>Solvers for explicitly given systems.</em>
For each of the following solvers, it is assumed that the ODEs are
given explicitly, so that the system can be written in the form
du/dt = f(u,t), where u is a vector of dependent variables, and t
is a scalar.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Lsode</td>
<td><p class="first">A wrapper to dlsode, the basic solver in ODEPACK for
stiff and nonstiff systems of the form du/dt = f.</p>
<p>In the stiff case, it treats the Jacobian matrix df/du as
either a dense (full) or a banded matrix, and as either
user-supplied or internally approximated by difference
quotients.</p>
<p class="last">It uses Adams methods (predictor-corrector) in the
nonstiff case, and Backward Differentiation Formula (BDF)
methods (the Gear methods) in the stiff case.  The linear
systems that arise are solved by direct methods (LU
factor/solve).</p>
</td>
</tr>
<tr class="row-odd"><td>Lsodes</td>
<td>solves systems du/dt = f, and in the stiff case
treats Jacobian matrix in general sparse form. It can
determine the sparsity structure on its own, or optionally
accepts this information from the user.
It then uses parts of the Yale Sparse Matrix Package (YSMP)
to solve the linear systems that arise, by a sparse
(direct) LU factorization/ backsolve method.</td>
</tr>
<tr class="row-even"><td>Lsoda</td>
<td>solves systems du/dt = f, with a dense or banded
Jacobian when the problem is stiff, but it automatically
selects between nonstiff (Adams) and stiff (BDF)
methods. It uses the nonstiff method initially, and
dynamically monitors data in order to decide which
method to use.</td>
</tr>
<tr class="row-odd"><td>Lsodar</td>
<td>a variant of Lsoda with a rootfinding capability added.
Thus it solves problems du/dt = f with dense or banded
Jacobian and automatic method selection, and at the same
time, it finds the roots of any of a set of given functions
of the form g(u,t).  This is often useful for finding stop
conditions, or for finding points at which a switch
is to be made in the function f.</td>
</tr>
</tbody>
</table>
<blockquote>
<div><p><em>Solvers for linearly implicit systems.</em>
The following solvers treat systems in the linearly implicit form:</p>
<div class="highlight-python"><pre>A(u,t) du/dt = g(u,t),</pre>
</div>
<p>where A is a square matrix, i.e., with the derivative
du/dt implicit, but linearly so.
These solvers allow A to be singular, in which case the system is a
differential-algebraic equation (DAE) system.
In that case, the user must be very careful to supply a well-posed
problem with consistent initial conditions.</p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Lsodi</td>
<td>solves linearly implicit systems in which the
matrices involved (A, dg/du, and d(A du/dt)/du) are all
assumed to be either dense or banded.</td>
</tr>
<tr class="row-odd"><td>Lsodibt</td>
<td>solves linearly implicit systems in which the matrices
involved are all assumed to be block-tridiagonal.  Linear
systems are solved by the LU method.</td>
</tr>
<tr class="row-even"><td>Lsodis</td>
<td>solves linearly implicit systems in which the
matrices involved are all assumed to be sparse.
Either determines the sparsity structure or accepts it from
the user, and uses parts of the Yale Sparse Matrix Package
to solve the linear systems that arise, by a direct method.</td>
</tr>
</tbody>
</table>
<p><em>Note</em>: It is encouraged that users provide a F2PY-compiled Fortran
subroutine or a multi-line string in Fortran code to define
user-supplied function. This would help to improve efficiency.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
<tr class="row-odd"><td>atol</td>
<td>absolute tolerance for solution (default: 1e-08)</td>
</tr>
<tr class="row-even"><td>rtol</td>
<td>relative tolerance for solution (default: 1e-06)</td>
</tr>
<tr class="row-odd"><td>adams_or_bdf</td>
<td>Method in vode or solvers in odepack: &#8220;adams&#8221; or
&#8220;bdf&#8221; (default: adams)</td>
</tr>
<tr class="row-even"><td>nsteps</td>
<td>Max no of internal solver steps per time step (de
fault: 1000)</td>
</tr>
<tr class="row-odd"><td>first_step</td>
<td>Suggested first time step size for an adaptive al
gorithm</td>
</tr>
<tr class="row-even"><td>min_step</td>
<td>Minimum step size for an adaptive algorithm</td>
</tr>
<tr class="row-odd"><td>max_step</td>
<td>Maximum step size for an adaptive algorithm</td>
</tr>
<tr class="row-even"><td>iter_method</td>
<td>Corrector iteration method choice</td>
</tr>
<tr class="row-odd"><td>lrw</td>
<td>Length of real work array.</td>
</tr>
<tr class="row-even"><td>liw</td>
<td>Length of integer work array, similiar as &lt;lrw&gt;.</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Odepack.adjust_atol" title="odesolvers.odepack.Odepack.adjust_atol"><tt class="xref py py-obj docutils literal"><span class="pre">adjust_atol</span></tt></a>(u_current)</td>
<td>Error tolerance tol(i) became zero for some i during integration, where tol = rtol(i) * u(i) + atol(i).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Odepack.adjust_parameters" title="odesolvers.odepack.Odepack.adjust_parameters"><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt></a>()</td>
<td>Special settings for properties of input parameters.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Odepack.advance" title="odesolvers.odepack.Odepack.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td>This function intends to one step forward for linearly solvers</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Odepack.check_iaja" title="odesolvers.odepack.Odepack.check_iaja"><tt class="xref py py-obj docutils literal"><span class="pre">check_iaja</span></tt></a>()</td>
<td>ia, ja, ic, jc are optional inputs to describe arbitrary sparse</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Odepack.check_liwlrw" title="odesolvers.odepack.Odepack.check_liwlrw"><tt class="xref py py-obj docutils literal"><span class="pre">check_liwlrw</span></tt></a>()</td>
<td>If the lengths of work arrays are specified by users, check whether</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Odepack.check_pars" title="odesolvers.odepack.Odepack.check_pars"><tt class="xref py py-obj docutils literal"><span class="pre">check_pars</span></tt></a>()</td>
<td>Some pairs of parameters should be input simutaneously.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Odepack.check_tol" title="odesolvers.odepack.Odepack.check_tol"><tt class="xref py py-obj docutils literal"><span class="pre">check_tol</span></tt></a>()</td>
<td>atol &amp; rtol should be defined as scalars or vectors with length neq.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Odepack.expand_iwork" title="odesolvers.odepack.Odepack.expand_iwork"><tt class="xref py py-obj docutils literal"><span class="pre">expand_iwork</span></tt></a>(new_liw[,&nbsp;expand])</td>
<td>Extension module return an actually required length for integer work array when it is too short.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Odepack.expand_rwork" title="odesolvers.odepack.Odepack.expand_rwork"><tt class="xref py py-obj docutils literal"><span class="pre">expand_rwork</span></tt></a>(new_lrw[,&nbsp;expand])</td>
<td>Length of real work array is smaller than actually required length.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Odepack.initialize" title="odesolvers.odepack.Odepack.initialize"><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt></a>()</td>
<td>Import extension module _odesolver and check that it exists.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Odepack.initialize_for_solve" title="odesolvers.odepack.Odepack.initialize_for_solve"><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt></a>()</td>
<td>In the long parameter-lists for solvers in ODEPACK, quite a few</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Odepack.new_stepnr" title="odesolvers.odepack.Odepack.new_stepnr"><tt class="xref py py-obj docutils literal"><span class="pre">new_stepnr</span></tt></a>()</td>
<td>When Fortran code returns a status &#8220;istate==-1&#8221;, it indicates that</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Odepack.print_roots" title="odesolvers.odepack.Odepack.print_roots"><tt class="xref py py-obj docutils literal"><span class="pre">print_roots</span></tt></a>(jroot,&nbsp;t_current,&nbsp;u_current)</td>
<td>Roots found at current T for some constraint functions.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Odepack.set_dummy_functions" title="odesolvers.odepack.Odepack.set_dummy_functions"><tt class="xref py py-obj docutils literal"><span class="pre">set_dummy_functions</span></tt></a>()</td>
<td>Functions have to get dummy values before they are passed to extension</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Odepack.set_extra_args" title="odesolvers.odepack.Odepack.set_extra_args"><tt class="xref py py-obj docutils literal"><span class="pre">set_extra_args</span></tt></a>()</td>
<td>Setting for extra parameters of user-defined functions.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Odepack.set_iopt" title="odesolvers.odepack.Odepack.set_iopt"><tt class="xref py py-obj docutils literal"><span class="pre">set_iopt</span></tt></a>()</td>
<td>Initialization for &#8220;ipot&#8221;, which is a flag to indicate whether optional</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Odepack.set_iter_method" title="odesolvers.odepack.Odepack.set_iter_method"><tt class="xref py py-obj docutils literal"><span class="pre">set_iter_method</span></tt></a>()</td>
<td>Set proper values for method-choices when it is not specified</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Odepack.set_iwork_rwork" title="odesolvers.odepack.Odepack.set_iwork_rwork"><tt class="xref py py-obj docutils literal"><span class="pre">set_iwork_rwork</span></tt></a>()</td>
<td>Initialize arrays for optional inputs, and calculate the</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Odepack.set_jac" title="odesolvers.odepack.Odepack.set_jac"><tt class="xref py py-obj docutils literal"><span class="pre">set_jac</span></tt></a>()</td>
<td>Set values for Jacobian matrix. In several solvers like Lsode,</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Odepack.set_liw_min" title="odesolvers.odepack.Odepack.set_liw_min"><tt class="xref py py-obj docutils literal"><span class="pre">set_liw_min</span></tt></a>()</td>
<td>Calculate the necessary length of integer work arrays when it is not specified explicitly by users.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Odepack.set_lrw_min" title="odesolvers.odepack.Odepack.set_lrw_min"><tt class="xref py py-obj docutils literal"><span class="pre">set_lrw_min</span></tt></a>()</td>
<td>Calculate the necessary length of real work arrays for Fortran code.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Odepack.set_ydoti" title="odesolvers.odepack.Odepack.set_ydoti"><tt class="xref py py-obj docutils literal"><span class="pre">set_ydoti</span></tt></a>()</td>
<td>&#8220;ydoti&#8221; is an array used in linearly solvers.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Odepack.solve" title="odesolvers.odepack.Odepack.solve"><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt></a>(time_points[,&nbsp;terminate])</td>
<td>This function is involved for non-linearly solvers in ODEPACK, i.e.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.odepack.Odepack.tol_multiply" title="odesolvers.odepack.Odepack.tol_multiply"><tt class="xref py py-obj docutils literal"><span class="pre">tol_multiply</span></tt></a>(tolsf)</td>
<td>This function is used to adjust tolerance parameters for Fortran part.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.odepack.Odepack.validate_data" title="odesolvers.odepack.Odepack.validate_data"><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt></a>()</td>
<td>Common validity check in Odepack.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odesolvers.odepack.Odepack.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.odepack'</em><a class="headerlink" href="#odesolvers.odepack.Odepack.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Odepack.adjust_atol">
<tt class="descname">adjust_atol</tt><big>(</big><em>u_current</em><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Odepack.adjust_atol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Odepack.adjust_atol" title="Permalink to this definition">¶</a></dt>
<dd><p>Error tolerance tol(i) became zero for some i during integration,
where tol = rtol(i) * u(i) + atol(i).
It indicates that pure absolute tolerance (atol(i)=0.0) was requested.
In order to avoid possible divide-zero-error, we could find the indices
of zero items and adjust atol.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Odepack.adjust_parameters">
<tt class="descname">adjust_parameters</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Odepack.adjust_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Odepack.adjust_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Special settings for properties of input parameters.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Odepack.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Odepack.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Odepack.advance" title="Permalink to this definition">¶</a></dt>
<dd><p>This function intends to one step forward for linearly solvers
(Lsodi, Lsodis, Lsoibt) in ODEPACK.
For these linearly solvers, if extra wrappers are added in Fortran
code, there are often memory errors. Besides, sometimes there
are unavoidable errors caused by bugs in the Ubuntu/Linux libraries
as libc.
To make these solvers more reliable on all platforms, this function
is used to call solvers in ODEPACK (dlsodi, dlsodis, dlsoibt) directly
without any wrappers in Fortran. However, this would lead to efficiency
lost with long work arrays as input parameters for Fortran code.
In Lsodi, Lsodis and Lsoibt, Solver.solve() would be applied to get the
desired solution, which will direct to this function to step forward.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Odepack.check_iaja">
<tt class="descname">check_iaja</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Odepack.check_iaja"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Odepack.check_iaja" title="Permalink to this definition">¶</a></dt>
<dd><p>ia, ja, ic, jc are optional inputs to describe arbitrary sparse
structure of matrix.</p>
<p>ia &amp; ja are used in dlsodes,dlsodis.
ic &amp; jc are used only in dlsodis.</p>
<p>There are special requirements for their values.
len(ia/ic) = neq + 1; (ia/ic)[0] = 1; (ia/ic)[-1] = 1 + len(ja/jc)</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Odepack.check_liwlrw">
<tt class="descname">check_liwlrw</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Odepack.check_liwlrw"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Odepack.check_liwlrw" title="Permalink to this definition">¶</a></dt>
<dd><p>If the lengths of work arrays are specified by users, check whether
they are greater than the required lengths of Fortran solvers.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Odepack.check_pars">
<tt class="descname">check_pars</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Odepack.check_pars"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Odepack.check_pars" title="Permalink to this definition">¶</a></dt>
<dd><p>Some pairs of parameters should be input simutaneously.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Odepack.check_tol">
<tt class="descname">check_tol</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Odepack.check_tol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Odepack.check_tol" title="Permalink to this definition">¶</a></dt>
<dd><p>atol &amp; rtol should be defined as scalars or vectors with length neq.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Odepack.expand_iwork">
<tt class="descname">expand_iwork</tt><big>(</big><em>new_liw</em>, <em>expand=False</em><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Odepack.expand_iwork"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Odepack.expand_iwork" title="Permalink to this definition">¶</a></dt>
<dd><p>Extension module return an actually required length for
integer work array when it is too short.
Then we could expand work array to required length to avoid this error.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Odepack.expand_rwork">
<tt class="descname">expand_rwork</tt><big>(</big><em>new_lrw</em>, <em>expand=False</em><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Odepack.expand_rwork"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Odepack.expand_rwork" title="Permalink to this definition">¶</a></dt>
<dd><p>Length of real work array is smaller than actually required length.
Then we could expand work array to avoid this error.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Odepack.initialize">
<tt class="descname">initialize</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Odepack.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Odepack.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Import extension module _odesolver and check that it exists.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Odepack.initialize_for_solve">
<tt class="descname">initialize_for_solve</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Odepack.initialize_for_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Odepack.initialize_for_solve" title="Permalink to this definition">¶</a></dt>
<dd><p>In the long parameter-lists for solvers in ODEPACK, quite a few
parameters can be set automatically with proper values depending
on values of other parameters.
In this function, all the parameters of this kind are initialized
with proper values.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Odepack.new_stepnr">
<tt class="descname">new_stepnr</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Odepack.new_stepnr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Odepack.new_stepnr" title="Permalink to this definition">¶</a></dt>
<dd><p>When Fortran code returns a status &#8220;istate==-1&#8221;, it indicates that
there are excessive amount of steps detected.
Then we could try to increase &#8220;nsteps&#8221; to avoid this error.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Odepack.print_roots">
<tt class="descname">print_roots</tt><big>(</big><em>jroot</em>, <em>t_current</em>, <em>u_current</em><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Odepack.print_roots"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Odepack.print_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Roots found at current T for some constraint functions.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Odepack.set_dummy_functions">
<tt class="descname">set_dummy_functions</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Odepack.set_dummy_functions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Odepack.set_dummy_functions" title="Permalink to this definition">¶</a></dt>
<dd><p>Functions have to get dummy values before they are passed to extension
module even if they are not involved in current solver.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Odepack.set_extra_args">
<tt class="descname">set_extra_args</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Odepack.set_extra_args"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Odepack.set_extra_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Setting for extra parameters of user-defined functions.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Odepack.set_iopt">
<tt class="descname">set_iopt</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Odepack.set_iopt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Odepack.set_iopt" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialization for &#8220;ipot&#8221;, which is a flag to indicate whether optional
parameters are specified in work arrays.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Odepack.set_iter_method">
<tt class="descname">set_iter_method</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Odepack.set_iter_method"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Odepack.set_iter_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Set proper values for method-choices when it is not specified
explicitly.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Odepack.set_iwork_rwork">
<tt class="descname">set_iwork_rwork</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Odepack.set_iwork_rwork"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Odepack.set_iwork_rwork" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize arrays for optional inputs, and calculate the
required length of work arrays in Fortran code.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Odepack.set_jac">
<tt class="descname">set_jac</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Odepack.set_jac"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Odepack.set_jac" title="Permalink to this definition">¶</a></dt>
<dd><p>Set values for Jacobian matrix. In several solvers like Lsode,
jacobian matrix could be supplied either in full form or in banded form.</p>
<p>This function intends to tell from which kind of Jacobian matrix
is specified.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Odepack.set_liw_min">
<tt class="descname">set_liw_min</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Odepack.set_liw_min"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Odepack.set_liw_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the necessary length of integer work arrays when it is not
specified explicitly by users.
Different solvers have different formulas.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Odepack.set_lrw_min">
<tt class="descname">set_lrw_min</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Odepack.set_lrw_min"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Odepack.set_lrw_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the necessary length of real work arrays for Fortran code.
Different solvers have different formulas.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Odepack.set_ydoti">
<tt class="descname">set_ydoti</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Odepack.set_ydoti"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Odepack.set_ydoti" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8220;ydoti&#8221; is an array used in linearly solvers.
It has to be extended if its length is smaller than neq.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Odepack.solve">
<tt class="descname">solve</tt><big>(</big><em>time_points</em>, <em>terminate=None</em><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Odepack.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Odepack.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is involved for non-linearly solvers in ODEPACK, i.e.
Lsode, Lsoda, Lsodar, and Lsodes.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Odepack.tol_multiply">
<tt class="descname">tol_multiply</tt><big>(</big><em>tolsf</em><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Odepack.tol_multiply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Odepack.tol_multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to adjust tolerance parameters for Fortran part.
When extension module returns a status &#8220;istate&#8221; as -2 or -3, it often
indicates that there are excessive amount of steps detected.
Then we could try to adjust tolerance settings with suggested factor
to avoid this error.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.odepack.Odepack.validate_data">
<tt class="descname">validate_data</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/odepack.html#Odepack.validate_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.odepack.Odepack.validate_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Common validity check in Odepack.</p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/odepack.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">odesolver API 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Liwei Wang and Hans Petter Langtangen.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>
