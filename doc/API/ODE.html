

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>odesolvers.ODE &mdash; odesolver API 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="odesolver API 0.1 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">odesolver API 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-odesolvers.ODE">
<span id="odesolvers-ode"></span><h1><a class="reference internal" href="#module-odesolvers.ODE" title="odesolvers.ODE"><tt class="xref py py-mod docutils literal"><span class="pre">odesolvers.ODE</span></tt></a><a class="headerlink" href="#module-odesolvers.ODE" title="Permalink to this headline">¶</a></h1>
<p>This module contains the base class <tt class="docutils literal"><span class="pre">Solver</span></tt> in the <tt class="docutils literal"><span class="pre">odesolvers</span></tt>
package, as well as implementations of many subclasses.</p>
<div class="section" id="how-to-implement-a-new-solver">
<h2>How to implement a new solver<a class="headerlink" href="#how-to-implement-a-new-solver" title="Permalink to this headline">¶</a></h2>
<div class="section" id="dependency-preparation">
<h3>Dependency preparation<a class="headerlink" href="#dependency-preparation" title="Permalink to this headline">¶</a></h3>
<p>This step is involved only when developers intend to wrap an existing
package into odesolvers.</p>
<p>If the original package is not written in Python language, developers
need to apply some specific tools (like F2PY or SWIG) to create an
extension module to make the package accessible from our Python
code.</p>
<dl class="docutils">
<dt>Otherwise, if the original package is also a Python software, developers</dt>
<dd>need to install and import the desired package as a Python module.</dd>
</dl>
<p>By an attempt to import these necessary modules (often set in method
initialize()), we can check whether the necessary dependencies are
installed properly.</p>
</div>
<div class="section" id="definition-of-legal-parameters-and-their-properties">
<h3>Definition of legal parameters and their properties<a class="headerlink" href="#definition-of-legal-parameters-and-their-properties" title="Permalink to this headline">¶</a></h3>
<p>Each solver has a set of specific parameters depending on its
underlying method. For example, adaptive solvers will be more
likely to apply attributes for step control, like first_step, min_step,
max_step. And a collection of methods probably need to provide a
parameter for users to make method choice, like ode_method.</p>
<dl class="docutils">
<dt>Developers should try to search in dictionary _parameters for suitable</dt>
<dd>items to represent the desired parameters. If there is no</dd>
<dt>suitable items found in this dictionary, developer need to supplement</dt>
<dd>new items in it.</dd>
</dl>
<p>There is no need to define input parameters one by one. With the help
of variable _optional_parameters and _required_parameters,
all parameters with names in these two name lists would be consid-
ered as legal in new solver.</p>
<p>Furthermore, if a parameter in new solver has some properties
different from general settings in _parameters, developers can reset(or
supplement) these properties in function adjust_parameters().</p>
</div>
<div class="section" id="special-check-in-validate-data">
<h3>Special check in validate_data()<a class="headerlink" href="#special-check-in-validate-data" title="Permalink to this headline">¶</a></h3>
<p>For some complicated solvers with many relevant input parameters,
there are possibly special relationship requirements inbetween some
specific input parameters.</p>
<p>For example, in class odesolvers.Lsodes, there are special require-
ments for the values of two input integer arrays <tt class="docutils literal"><span class="pre">ia</span></tt> and <tt class="docutils literal"><span class="pre">ja</span></tt>:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">ia</span></tt> and <tt class="docutils literal"><span class="pre">ja</span></tt> must be input simultaneously.</li>
<li><tt class="docutils literal"><span class="pre">len(ia)</span> <span class="pre">==</span> <span class="pre">neq</span> <span class="pre">+</span> <span class="pre">1</span></tt></li>
<li><tt class="docutils literal"><span class="pre">ia[neq]</span> <span class="pre">=</span> <span class="pre">len(ja)</span></tt></li>
</ul>
</div></blockquote>
<p>Most of the automatic checking are taken in initialization step. We
need to take extra check for the above requirements after all the
inputs are initialized. Thus a new function check_iaja() is defined
in odesolvers.Lsodes, and injected into function validate_data().</p>
</div>
<div class="section" id="internal-settings-in-initialize-for-solve">
<h3>Internal settings in initialize_for_solve()<a class="headerlink" href="#internal-settings-in-initialize-for-solve" title="Permalink to this headline">¶</a></h3>
<p>When I tried to wrap some complicated ODE software, some param-
eters are found to be dependent on values of other parameters,
although they are required as inputs for these underlying ODE
software.</p>
<dl class="docutils">
<dt>For example, as an input parameter for rkc.f, info[1] is an integer</dt>
<dd>flag to indicate whether function spcrad is supplied by users.</dd>
</dl>
<p>This kind of parameters are required by underlying software, but
unnecessary to be valued from user&#8217;s input. This is why I called them
as internal parameters.</p>
<p>Function initialize_for_solve() is used to initialize this kind of
parameters before they are passed to the underlying software.</p>
</div>
<div class="section" id="step-forward-in-advance">
<h3>Step forward in advance()<a class="headerlink" href="#step-forward-in-advance" title="Permalink to this headline">¶</a></h3>
<p>In function advance(), solution value for next time point should be
returned. This is the only mandatory step to implement a new solver.</p>
<dl class="docutils">
<dt>For simple numerical methods (like ForwardEuler method), numerical</dt>
<dd>scheme is implemented directly in this function. If the new solver</dd>
</dl>
<p>is a wrapper to another module(either Python module, or extension
module), iteration in underlying package will be ready to start if
Python code pass all the necessary parameters to the underlying
module according to its user interface.</p>
<p>In the user interfaces of some ODE software, like sympy.mpamath.odeint,
solving procedure is started directly with the whole sequence of time
points, but not step by step. Then developers should turn to start
iteration directly in function solve().</p>
<dl class="class">
<dt id="odesolvers.ODE.AdamsBashMoulton2">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">AdamsBashMoulton2</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#AdamsBashMoulton2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.AdamsBashMoulton2" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.ODE.Solver" title="odesolvers.ODE.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.Solver</span></tt></a></p>
<p>Two-step (3rd-order) Adams-Bashforth method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">predictor</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mf">12.</span><span class="o">*</span><span class="p">(</span><span class="mf">23.</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="mi">16</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
                    <span class="mi">5</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span>
<span class="n">corrector</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mf">12.</span><span class="o">*</span><span class="p">(</span><span class="mf">8.</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
                    <span class="mi">5</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">predictor</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<p>for constant time step dt.</p>
<p>RK2 is used as default solver for first steps.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
<tr class="row-odd"><td>start_method</td>
<td>Method for the first steps in multi-step solvers
(default: RK2)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.AdamsBashMoulton2.advance" title="odesolvers.ODE.AdamsBashMoulton2.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.ODE.AdamsBashMoulton2.initialize_for_solve" title="odesolvers.ODE.AdamsBashMoulton2.initialize_for_solve"><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.AdamsBashMoulton2.validate_data" title="odesolvers.ODE.AdamsBashMoulton2.validate_data"><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt></a>()</td>
<td></td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odesolvers.ODE.AdamsBashMoulton2.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.AdamsBashMoulton2.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.AdamsBashMoulton2.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#AdamsBashMoulton2.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.AdamsBashMoulton2.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.AdamsBashMoulton2.initialize_for_solve">
<tt class="descname">initialize_for_solve</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#AdamsBashMoulton2.initialize_for_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.AdamsBashMoulton2.initialize_for_solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.AdamsBashMoulton2.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Explicit 2nd-order Adams-Bashforth-Moulton method'</em><a class="headerlink" href="#odesolvers.ODE.AdamsBashMoulton2.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.AdamsBashMoulton2.validate_data">
<tt class="descname">validate_data</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#AdamsBashMoulton2.validate_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.AdamsBashMoulton2.validate_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.ODE.AdamsBashMoulton3">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">AdamsBashMoulton3</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#AdamsBashMoulton3"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.AdamsBashMoulton3" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.ODE.Solver" title="odesolvers.ODE.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.Solver</span></tt></a></p>
<p>Three-step (4th-order) Adams-Bashforth method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">predictor</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mf">24.</span><span class="o">*</span><span class="p">(</span><span class="mf">55.</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="mi">59</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
                           <span class="mi">37</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="mi">9</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">3</span><span class="p">]))</span>
<span class="n">corrector</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mf">24.</span><span class="o">*</span><span class="p">(</span><span class="mf">19.</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
                           <span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="mi">9</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">predictor</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<p>for constant time step dt.</p>
<p>RK2 is used as default solver for first steps.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
<tr class="row-odd"><td>start_method</td>
<td>Method for the first steps in multi-step solvers
(default: RK2)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.AdamsBashMoulton3.advance" title="odesolvers.ODE.AdamsBashMoulton3.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.ODE.AdamsBashMoulton3.initialize_for_solve" title="odesolvers.ODE.AdamsBashMoulton3.initialize_for_solve"><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.AdamsBashMoulton3.validate_data" title="odesolvers.ODE.AdamsBashMoulton3.validate_data"><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt></a>()</td>
<td></td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odesolvers.ODE.AdamsBashMoulton3.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.AdamsBashMoulton3.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.AdamsBashMoulton3.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#AdamsBashMoulton3.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.AdamsBashMoulton3.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.AdamsBashMoulton3.initialize_for_solve">
<tt class="descname">initialize_for_solve</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#AdamsBashMoulton3.initialize_for_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.AdamsBashMoulton3.initialize_for_solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.AdamsBashMoulton3.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Explicit 3rd-order Adams-Bashforth-Moulton method'</em><a class="headerlink" href="#odesolvers.ODE.AdamsBashMoulton3.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.AdamsBashMoulton3.validate_data">
<tt class="descname">validate_data</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#AdamsBashMoulton3.validate_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.AdamsBashMoulton3.validate_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.ODE.AdamsBashforth2">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">AdamsBashforth2</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#AdamsBashforth2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.AdamsBashforth2" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.ODE.Solver" title="odesolvers.ODE.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.Solver</span></tt></a></p>
<p>Second-order Adams-Bashforth method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<p>for constant time step dt.</p>
<p>RK2 is used as default solver in first step.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
<tr class="row-odd"><td>start_method</td>
<td>Method for the first steps in multi-step solvers
(default: RK2)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.AdamsBashforth2.advance" title="odesolvers.ODE.AdamsBashforth2.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.ODE.AdamsBashforth2.initialize_for_solve" title="odesolvers.ODE.AdamsBashforth2.initialize_for_solve"><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.AdamsBashforth2.validate_data" title="odesolvers.ODE.AdamsBashforth2.validate_data"><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt></a>()</td>
<td>Check that the time steps are constant.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odesolvers.ODE.AdamsBashforth2.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.AdamsBashforth2.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.AdamsBashforth2.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#AdamsBashforth2.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.AdamsBashforth2.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.AdamsBashforth2.initialize_for_solve">
<tt class="descname">initialize_for_solve</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#AdamsBashforth2.initialize_for_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.AdamsBashforth2.initialize_for_solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.AdamsBashforth2.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Explicit 2nd-order Adams-Bashforth method'</em><a class="headerlink" href="#odesolvers.ODE.AdamsBashforth2.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.AdamsBashforth2.validate_data">
<tt class="descname">validate_data</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#AdamsBashforth2.validate_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.AdamsBashforth2.validate_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that the time steps are constant.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.ODE.AdamsBashforth3">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">AdamsBashforth3</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#AdamsBashforth3"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.AdamsBashforth3" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.ODE.Solver" title="odesolvers.ODE.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.Solver</span></tt></a></p>
<p>Third-order Adams-Bashforth method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mf">12.</span><span class="o">*</span><span class="p">(</span><span class="mi">23</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="mi">16</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                        <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span>
</pre></div>
</div>
<p>for constant time step dt.</p>
<p>RK2 is used as default solver for first steps.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
<tr class="row-odd"><td>start_method</td>
<td>Method for the first steps in multi-step solvers
(default: RK2)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.AdamsBashforth3.advance" title="odesolvers.ODE.AdamsBashforth3.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.ODE.AdamsBashforth3.initialize_for_solve" title="odesolvers.ODE.AdamsBashforth3.initialize_for_solve"><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.AdamsBashforth3.validate_data" title="odesolvers.ODE.AdamsBashforth3.validate_data"><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt></a>()</td>
<td></td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odesolvers.ODE.AdamsBashforth3.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.AdamsBashforth3.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.AdamsBashforth3.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#AdamsBashforth3.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.AdamsBashforth3.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.AdamsBashforth3.initialize_for_solve">
<tt class="descname">initialize_for_solve</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#AdamsBashforth3.initialize_for_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.AdamsBashforth3.initialize_for_solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.AdamsBashforth3.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Explicit 3rd-order Adams-Bashforth method'</em><a class="headerlink" href="#odesolvers.ODE.AdamsBashforth3.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.AdamsBashforth3.validate_data">
<tt class="descname">validate_data</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#AdamsBashforth3.validate_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.AdamsBashforth3.validate_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.ODE.AdamsBashforth4">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">AdamsBashforth4</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#AdamsBashforth4"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.AdamsBashforth4" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.ODE.Solver" title="odesolvers.ODE.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.Solver</span></tt></a></p>
<p>Fourth-order Adams-Bashforth method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mf">24.</span><span class="o">*</span><span class="p">(</span><span class="mf">55.</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="mi">59</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
                        <span class="mi">37</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="mi">9</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">3</span><span class="p">]))</span>
</pre></div>
</div>
<p>for constant time step dt.</p>
<p>RK2 is used as default solver for first steps.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
<tr class="row-odd"><td>start_method</td>
<td>Method for the first steps in multi-step solvers
(default: RK2)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.AdamsBashforth4.advance" title="odesolvers.ODE.AdamsBashforth4.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.ODE.AdamsBashforth4.initialize_for_solve" title="odesolvers.ODE.AdamsBashforth4.initialize_for_solve"><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.AdamsBashforth4.validate_data" title="odesolvers.ODE.AdamsBashforth4.validate_data"><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt></a>()</td>
<td></td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odesolvers.ODE.AdamsBashforth4.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.AdamsBashforth4.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.AdamsBashforth4.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#AdamsBashforth4.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.AdamsBashforth4.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.AdamsBashforth4.initialize_for_solve">
<tt class="descname">initialize_for_solve</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#AdamsBashforth4.initialize_for_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.AdamsBashforth4.initialize_for_solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.AdamsBashforth4.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Explicit 4th-order Adams-Bashforth method'</em><a class="headerlink" href="#odesolvers.ODE.AdamsBashforth4.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.AdamsBashforth4.validate_data">
<tt class="descname">validate_data</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#AdamsBashforth4.validate_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.AdamsBashforth4.validate_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.ODE.Adaptive">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">Adaptive</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Adaptive"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Adaptive" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.ODE.Solver" title="odesolvers.ODE.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.Solver</span></tt></a></p>
<p>Superclass for adaptive solvers.    
Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
<tr class="row-odd"><td>rtol</td>
<td>relative tolerance for solution (default: 1e-06)</td>
</tr>
<tr class="row-even"><td>atol</td>
<td>absolute tolerance for solution (default: 1e-08)</td>
</tr>
<tr class="row-odd"><td>first_step</td>
<td>Suggested first time step size for an adaptive al
gorithm</td>
</tr>
<tr class="row-even"><td>min_step</td>
<td>Minimum step size for an adaptive algorithm</td>
</tr>
<tr class="row-odd"><td>max_step</td>
<td>Maximum step size for an adaptive algorithm</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td>Advance solution one time step.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.ODE.Adaptive.initialize_for_solve" title="odesolvers.ODE.Adaptive.initialize_for_solve"><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra check after all the attributes, (including inputs and internal parameters), have been initialized, e.g.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odesolvers.ODE.Adaptive.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.Adaptive.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Adaptive.initialize_for_solve">
<tt class="descname">initialize_for_solve</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Adaptive.initialize_for_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Adaptive.initialize_for_solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.ODE.AdaptiveResidual">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">AdaptiveResidual</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#AdaptiveResidual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.AdaptiveResidual" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.ODE.Adaptive" title="odesolvers.ODE.Adaptive"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.Adaptive</span></tt></a></p>
<p>Designed for educational purposes to demonstrate a possible
adaptive strategy.</p>
<p>Currently, only scalar ODE problems can be applied for purpose of
simplification.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
<tr class="row-odd"><td>rtol</td>
<td>relative tolerance for solution (default: 1e-06)</td>
</tr>
<tr class="row-even"><td>atol</td>
<td>absolute tolerance for solution (default: 1e-08)</td>
</tr>
<tr class="row-odd"><td>first_step</td>
<td>Suggested first time step size for an adaptive al
gorithm</td>
</tr>
<tr class="row-even"><td>min_step</td>
<td>Minimum step size for an adaptive algorithm</td>
</tr>
<tr class="row-odd"><td>max_step</td>
<td>Maximum step size for an adaptive algorithm</td>
</tr>
<tr class="row-even"><td>solver</td>
<td>Name of solver class in solvers that need an extr
a solver (e.g., AdaptiveResidual) (default: RK4)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td>Advance solution one time step.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.AdaptiveResidual.residual" title="odesolvers.ODE.AdaptiveResidual.residual"><tt class="xref py py-obj docutils literal"><span class="pre">residual</span></tt></a>(u_n,&nbsp;u_next,&nbsp;t_n,&nbsp;t_next)</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.ODE.AdaptiveResidual.solve" title="odesolvers.ODE.AdaptiveResidual.solve"><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt></a>(time_points[,&nbsp;terminate,&nbsp;print_info])</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra check after all the attributes, (including inputs and internal parameters), have been initialized, e.g.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="odesolvers.ODE.AdaptiveResidual.__init__">
<tt class="descname">__init__</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#AdaptiveResidual.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.AdaptiveResidual.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.AdaptiveResidual.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.AdaptiveResidual.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.AdaptiveResidual.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Very simple adaptive strategy based on the residual'</em><a class="headerlink" href="#odesolvers.ODE.AdaptiveResidual.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.AdaptiveResidual.residual">
<tt class="descname">residual</tt><big>(</big><em>u_n</em>, <em>u_next</em>, <em>t_n</em>, <em>t_next</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#AdaptiveResidual.residual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.AdaptiveResidual.residual" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.AdaptiveResidual.solve">
<tt class="descname">solve</tt><big>(</big><em>time_points</em>, <em>terminate=None</em>, <em>print_info=False</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#AdaptiveResidual.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.AdaptiveResidual.solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.ODE.Backward2Step">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">Backward2Step</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Backward2Step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Backward2Step" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.ODE.SolverImplicit" title="odesolvers.ODE.SolverImplicit"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.SolverImplicit</span></tt></a></p>
<p>Implicit Backward Euler method with 2 steps:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="o">/</span><span class="mi">3</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">3</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">3</span>
</pre></div>
</div>
<p>The 1st-order Backward Euler method is used for the first step.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
<tr class="row-odd"><td>jac</td>
<td>Jacobian of right-hand side function f (df/du) (d
efault: None)</td>
</tr>
<tr class="row-even"><td>jac_args</td>
<td>Extra positional arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span> <span class="pre">*j</span>
<span class="pre">ac_args,**jac_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>jac_kwargs</td>
<td>Extra keyword arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span> <span class="pre">*jac_</span>
<span class="pre">args,**jac_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>h_in_fd_jac</td>
<td>h in finite difference approximation of the Jacob
ian (default: 0.0001)</td>
</tr>
<tr class="row-odd"><td>nonlinear_solver</td>
<td>Newton or Picard nonlinear solver (default: Picar
d)</td>
</tr>
<tr class="row-even"><td>max_iter</td>
<td>Max no of iterations in nonlinear solver (default
: 25)</td>
</tr>
<tr class="row-odd"><td>eps_iter</td>
<td>Max error measure in nonlinear solver (default: 0
.0001)</td>
</tr>
<tr class="row-even"><td>relaxation</td>
<td>relaxation argument (r): new_solution = r*solutio
n + (1-r)*old_solution (default: 1.0)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.ODE.Backward2Step.Newton_system" title="odesolvers.ODE.Backward2Step.Newton_system"><tt class="xref py py-obj docutils literal"><span class="pre">Newton_system</span></tt></a>(ukp1)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.Backward2Step.Picard_update" title="odesolvers.ODE.Backward2Step.Picard_update"><tt class="xref py py-obj docutils literal"><span class="pre">Picard_update</span></tt></a>(ukp1)</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra check after all the attributes, (including inputs and internal parameters), have been initialized, e.g.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="odesolvers.ODE.Backward2Step.Newton_system">
<tt class="descname">Newton_system</tt><big>(</big><em>ukp1</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Backward2Step.Newton_system"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Backward2Step.Newton_system" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Backward2Step.Picard_update">
<tt class="descname">Picard_update</tt><big>(</big><em>ukp1</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Backward2Step.Picard_update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Backward2Step.Picard_update" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.Backward2Step.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.Backward2Step.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.Backward2Step.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Implicit 2nd-order Backward Euler method'</em><a class="headerlink" href="#odesolvers.ODE.Backward2Step.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.ODE.BackwardEuler">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">BackwardEuler</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#BackwardEuler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.BackwardEuler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.ODE.SolverImplicit" title="odesolvers.ODE.SolverImplicit"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.SolverImplicit</span></tt></a></p>
<p>Implicit Backward Euler method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>The nonlinear system is solved by Newton or Picard iteration.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
<tr class="row-odd"><td>jac</td>
<td>Jacobian of right-hand side function f (df/du) (d
efault: None)</td>
</tr>
<tr class="row-even"><td>jac_args</td>
<td>Extra positional arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span> <span class="pre">*j</span>
<span class="pre">ac_args,**jac_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>jac_kwargs</td>
<td>Extra keyword arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span> <span class="pre">*jac_</span>
<span class="pre">args,**jac_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>h_in_fd_jac</td>
<td>h in finite difference approximation of the Jacob
ian (default: 0.0001)</td>
</tr>
<tr class="row-odd"><td>nonlinear_solver</td>
<td>Newton or Picard nonlinear solver (default: Picar
d)</td>
</tr>
<tr class="row-even"><td>max_iter</td>
<td>Max no of iterations in nonlinear solver (default
: 25)</td>
</tr>
<tr class="row-odd"><td>eps_iter</td>
<td>Max error measure in nonlinear solver (default: 0
.0001)</td>
</tr>
<tr class="row-even"><td>relaxation</td>
<td>relaxation argument (r): new_solution = r*solutio
n + (1-r)*old_solution (default: 1.0)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.ODE.BackwardEuler.Newton_system" title="odesolvers.ODE.BackwardEuler.Newton_system"><tt class="xref py py-obj docutils literal"><span class="pre">Newton_system</span></tt></a>(ukp1)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.BackwardEuler.Picard_update" title="odesolvers.ODE.BackwardEuler.Picard_update"><tt class="xref py py-obj docutils literal"><span class="pre">Picard_update</span></tt></a>(ukp1)</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra check after all the attributes, (including inputs and internal parameters), have been initialized, e.g.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="odesolvers.ODE.BackwardEuler.Newton_system">
<tt class="descname">Newton_system</tt><big>(</big><em>ukp1</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#BackwardEuler.Newton_system"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.BackwardEuler.Newton_system" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.BackwardEuler.Picard_update">
<tt class="descname">Picard_update</tt><big>(</big><em>ukp1</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#BackwardEuler.Picard_update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.BackwardEuler.Picard_update" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.BackwardEuler.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.BackwardEuler.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.BackwardEuler.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Implicit 1st-order Backward Euler method'</em><a class="headerlink" href="#odesolvers.ODE.BackwardEuler.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.ODE.Dop853">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">Dop853</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Dop853"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Dop853" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.ODE.Ode_scipy" title="odesolvers.ODE.Ode_scipy"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.Ode_scipy</span></tt></a></p>
<p>Wrapper for scipy.integrate.ode.dop853, which applies the
Dormand&amp;Prince method of order 8(5,3).</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
<tr class="row-odd"><td>jac</td>
<td>Jacobian of right-hand side function f (df/du) (d
efault: None)</td>
</tr>
<tr class="row-even"><td>jac_kwargs</td>
<td>Extra keyword arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span> <span class="pre">*jac_</span>
<span class="pre">args,**jac_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-odd"><td>jac_args</td>
<td>Extra positional arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span> <span class="pre">*j</span>
<span class="pre">ac_args,**jac_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-even"><td>atol</td>
<td>absolute tolerance for solution (default: 1e-08)</td>
</tr>
<tr class="row-odd"><td>rtol</td>
<td>relative tolerance for solution (default: 1e-06)</td>
</tr>
<tr class="row-even"><td>first_step</td>
<td>Suggested first time step size for an adaptive al
gorithm</td>
</tr>
<tr class="row-odd"><td>max_step</td>
<td>Maximum step size for an adaptive algorithm</td>
</tr>
<tr class="row-even"><td>nsteps</td>
<td>Max no of internal solver steps per time step (de
fault: 1000)</td>
</tr>
<tr class="row-odd"><td>ifactor</td>
<td>Maximum factor for increasing the step size (defa
ult: 2)</td>
</tr>
<tr class="row-even"><td>dfactor</td>
<td>Maximum factor for decreasing the step size (defa
ult: 0.5)</td>
</tr>
<tr class="row-odd"><td>beta</td>
<td><dl class="first last docutils">
<dt>Beta argument for stabilized step size control in</dt>
<dd>Dormand&amp;Prince methods from scipy</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td>safety</td>
<td>Safety factor on new step selection (default: 0.9
)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra check after all the attributes, (including inputs and internal parameters), have been initialized, e.g.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odesolvers.ODE.Dop853.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.Dop853.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.Dop853.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Adaptive Dormand &amp; Prince method of order 8(5,3) (SciPy)'</em><a class="headerlink" href="#odesolvers.ODE.Dop853.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.ODE.Dopri5">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">Dopri5</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Dopri5"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Dopri5" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.ODE.Ode_scipy" title="odesolvers.ODE.Ode_scipy"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.Ode_scipy</span></tt></a></p>
<p>Wrapper for scipy.integrate.ode.dopri5, which applies the
Dormand&amp;Prince method of order 5.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
<tr class="row-odd"><td>jac</td>
<td>Jacobian of right-hand side function f (df/du) (d
efault: None)</td>
</tr>
<tr class="row-even"><td>jac_kwargs</td>
<td>Extra keyword arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span> <span class="pre">*jac_</span>
<span class="pre">args,**jac_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-odd"><td>jac_args</td>
<td>Extra positional arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span> <span class="pre">*j</span>
<span class="pre">ac_args,**jac_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-even"><td>atol</td>
<td>absolute tolerance for solution (default: 1e-08)</td>
</tr>
<tr class="row-odd"><td>rtol</td>
<td>relative tolerance for solution (default: 1e-06)</td>
</tr>
<tr class="row-even"><td>first_step</td>
<td>Suggested first time step size for an adaptive al
gorithm</td>
</tr>
<tr class="row-odd"><td>max_step</td>
<td>Maximum step size for an adaptive algorithm</td>
</tr>
<tr class="row-even"><td>nsteps</td>
<td>Max no of internal solver steps per time step (de
fault: 1000)</td>
</tr>
<tr class="row-odd"><td>ifactor</td>
<td>Maximum factor for increasing the step size (defa
ult: 2)</td>
</tr>
<tr class="row-even"><td>dfactor</td>
<td>Maximum factor for decreasing the step size (defa
ult: 0.5)</td>
</tr>
<tr class="row-odd"><td>beta</td>
<td><dl class="first last docutils">
<dt>Beta argument for stabilized step size control in</dt>
<dd>Dormand&amp;Prince methods from scipy</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td>safety</td>
<td>Safety factor on new step selection (default: 0.9
)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra check after all the attributes, (including inputs and internal parameters), have been initialized, e.g.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odesolvers.ODE.Dopri5.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.Dopri5.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.Dopri5.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Dormand &amp; Prince method of order 5 (SciPy)'</em><a class="headerlink" href="#odesolvers.ODE.Dopri5.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.Euler">
<tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">Euler</tt><a class="headerlink" href="#odesolvers.ODE.Euler" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#odesolvers.ODE.ForwardEuler" title="odesolvers.ODE.ForwardEuler"><tt class="xref py py-class docutils literal"><span class="pre">ForwardEuler</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="odesolvers.ODE.ForwardEuler">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">ForwardEuler</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#ForwardEuler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.ForwardEuler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.ODE.Solver" title="odesolvers.ODE.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.Solver</span></tt></a></p>
<p>Forward Euler scheme:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</pre></div>
</div>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
</tbody>
</table>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.ForwardEuler.advance" title="odesolvers.ODE.ForwardEuler.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td>Setting values of internal attributes to be used in iteration.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra check after all the attributes, (including inputs and internal parameters), have been initialized, e.g.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odesolvers.ODE.ForwardEuler.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.ForwardEuler.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.ForwardEuler.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#ForwardEuler.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.ForwardEuler.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.ForwardEuler.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'The simple explicit (forward) Euler scheme'</em><a class="headerlink" href="#odesolvers.ODE.ForwardEuler.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.ODE.Heun">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">Heun</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Heun"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Heun" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.ODE.Solver" title="odesolvers.ODE.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.Solver</span></tt></a></p>
<p>Heun&#8217;s method, also known as an RungeKutta2 or Trapezoidal method.
Basically, it is a central difference method, with one
iteration and the Forward Euler scheme as start value.
In this sense, it is a predictor-corrector method.</p>
<p>Scheme:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">+</span><span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]),</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
</tbody>
</table>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.Heun.advance" title="odesolvers.ODE.Heun.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td>Setting values of internal attributes to be used in iteration.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra check after all the attributes, (including inputs and internal parameters), have been initialized, e.g.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odesolvers.ODE.Heun.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.Heun.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Heun.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Heun.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Heun.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.Heun.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = &quot;Heun's explicit method (similar to RK2)&quot;</em><a class="headerlink" href="#odesolvers.ODE.Heun.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.ODE.Leapfrog">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">Leapfrog</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Leapfrog"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Leapfrog" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.ODE.Solver" title="odesolvers.ODE.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.Solver</span></tt></a></p>
<p>Leapfrog scheme:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</pre></div>
</div>
<p>with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dt2</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Forward Euler is used for the first step.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.Leapfrog.advance" title="odesolvers.ODE.Leapfrog.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td>Setting values of internal attributes to be used in iteration.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra check after all the attributes, (including inputs and internal parameters), have been initialized, e.g.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odesolvers.ODE.Leapfrog.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.Leapfrog.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Leapfrog.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Leapfrog.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Leapfrog.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.Leapfrog.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Standard explicit Leapfrog scheme'</em><a class="headerlink" href="#odesolvers.ODE.Leapfrog.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.ODE.LeapfrogFiltered">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">LeapfrogFiltered</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#LeapfrogFiltered"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.LeapfrogFiltered" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.ODE.Solver" title="odesolvers.ODE.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.Solver</span></tt></a></p>
<p>The standard Leapfrog scheme reads:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</pre></div>
</div>
<p>with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dt2</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Forward Euler is used for the first step.
Since Leapfrog gives oscillatory solutions, this class
applies a common filtering technique:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">gamma</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>with gamma=0.6 as in the NCAR Climate Model.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.LeapfrogFiltered.advance" title="odesolvers.ODE.LeapfrogFiltered.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td>Setting values of internal attributes to be used in iteration.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra check after all the attributes, (including inputs and internal parameters), have been initialized, e.g.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odesolvers.ODE.LeapfrogFiltered.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.LeapfrogFiltered.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.LeapfrogFiltered.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#LeapfrogFiltered.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.LeapfrogFiltered.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.LeapfrogFiltered.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Filtered Leapfrog scheme'</em><a class="headerlink" href="#odesolvers.ODE.LeapfrogFiltered.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.ODE.MidpointImplicit">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">MidpointImplicit</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#MidpointImplicit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.MidpointImplicit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.ODE.SolverImplicit" title="odesolvers.ODE.SolverImplicit"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.SolverImplicit</span></tt></a></p>
<p>Midpoint Implicit method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">((</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
</pre></div>
</div>
<p>The nonlinear system is solved by Picard or Newton iteration.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
<tr class="row-odd"><td>jac</td>
<td>Jacobian of right-hand side function f (df/du) (d
efault: None)</td>
</tr>
<tr class="row-even"><td>jac_args</td>
<td>Extra positional arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span> <span class="pre">*j</span>
<span class="pre">ac_args,**jac_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>jac_kwargs</td>
<td>Extra keyword arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span> <span class="pre">*jac_</span>
<span class="pre">args,**jac_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>h_in_fd_jac</td>
<td>h in finite difference approximation of the Jacob
ian (default: 0.0001)</td>
</tr>
<tr class="row-odd"><td>nonlinear_solver</td>
<td>Newton or Picard nonlinear solver (default: Picar
d)</td>
</tr>
<tr class="row-even"><td>max_iter</td>
<td>Max no of iterations in nonlinear solver (default
: 25)</td>
</tr>
<tr class="row-odd"><td>eps_iter</td>
<td>Max error measure in nonlinear solver (default: 0
.0001)</td>
</tr>
<tr class="row-even"><td>relaxation</td>
<td>relaxation argument (r): new_solution = r*solutio
n + (1-r)*old_solution (default: 1.0)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.ODE.MidpointImplicit.Newton_system" title="odesolvers.ODE.MidpointImplicit.Newton_system"><tt class="xref py py-obj docutils literal"><span class="pre">Newton_system</span></tt></a>(ukp1)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.MidpointImplicit.Picard_update" title="odesolvers.ODE.MidpointImplicit.Picard_update"><tt class="xref py py-obj docutils literal"><span class="pre">Picard_update</span></tt></a>(ukp1)</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra check after all the attributes, (including inputs and internal parameters), have been initialized, e.g.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="odesolvers.ODE.MidpointImplicit.Newton_system">
<tt class="descname">Newton_system</tt><big>(</big><em>ukp1</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#MidpointImplicit.Newton_system"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.MidpointImplicit.Newton_system" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.MidpointImplicit.Picard_update">
<tt class="descname">Picard_update</tt><big>(</big><em>ukp1</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#MidpointImplicit.Picard_update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.MidpointImplicit.Picard_update" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.MidpointImplicit.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.MidpointImplicit.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.MidpointImplicit.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Implicit 2nd-order Midpoint method'</em><a class="headerlink" href="#odesolvers.ODE.MidpointImplicit.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.ODE.MidpointIter">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">MidpointIter</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#MidpointIter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.MidpointIter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.ODE.Solver" title="odesolvers.ODE.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.Solver</span></tt></a></p>
<p>A midpoint/central difference method with max_iter fixed-point
iterations to solve the nonlinear system.
The Forward Euler scheme is recovered if max_iter=1 and f(u,t)
is independent of t. For max_iter=2 we have the Heun/RK2 scheme.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
<tr class="row-odd"><td>max_iter</td>
<td>Max no of iterations in nonlinear solver (default
: 25)</td>
</tr>
<tr class="row-even"><td>eps_iter</td>
<td>Max error measure in nonlinear solver (default: 0
.0001)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.ODE.MidpointIter.adjust_parameters" title="odesolvers.ODE.MidpointIter.adjust_parameters"><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.MidpointIter.advance" title="odesolvers.ODE.MidpointIter.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td>Setting values of internal attributes to be used in iteration.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra check after all the attributes, (including inputs and internal parameters), have been initialized, e.g.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odesolvers.ODE.MidpointIter.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.MidpointIter.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.MidpointIter.adjust_parameters">
<tt class="descname">adjust_parameters</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#MidpointIter.adjust_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.MidpointIter.adjust_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.MidpointIter.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#MidpointIter.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.MidpointIter.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.MidpointIter.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Explicit 2nd-order iterated Midpoint method'</em><a class="headerlink" href="#odesolvers.ODE.MidpointIter.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.ODE.MySolver">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">MySolver</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#MySolver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.MySolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.ODE.Solver" title="odesolvers.ODE.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.Solver</span></tt></a></p>
<p>Users can define a solver with supplying a function
myadvance(), and make use of all possible parameters
in this module:</p>
<div class="highlight-python"><pre>myadvance(MySolver_instance)  --&gt;  return unew</pre>
</div>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">myadvance_</span><span class="p">(</span><span class="n">ms</span><span class="p">):</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="n">ms</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="n">ms</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="n">ms</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">ms</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">ms</span><span class="o">.</span><span class="n">atol</span>
    <span class="c"># All class attributes can be obtained</span>
    <span class="n">unew</span> <span class="o">=</span> <span class="o">...</span>
    <span class="k">return</span> <span class="n">unew</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
    <span class="n">udot</span> <span class="o">=</span> <span class="o">...</span>
    <span class="k">return</span> <span class="n">udot</span>

<span class="n">method</span> <span class="o">=</span> <span class="n">MySolver</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">myadvance</span><span class="o">=</span><span class="n">myadvance_</span><span class="p">)</span>
<span class="n">method</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="n">u0</span><span class="p">)</span>
<span class="n">u</span><span class="p">,</span><span class="n">t</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">time_points</span><span class="p">)</span>
</pre></div>
</div>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
<tr class="row-odd"><td>myadvance</td>
<td>User supplied function to advance current solutio
n one step forward. See documents of class MySolv
er.</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-odd"><td>lrw</td>
<td>Length of real work array.</td>
</tr>
<tr class="row-even"><td>adda_lsoibt</td>
<td><p class="first">Callable object to add matrix A = A(u,t) to
another matrix P, stored in block-tridiagonal
form.</p>
<blockquote>
<div>adda(u,t,pa,pb,pc)    &#8212;&#8211;&gt;  (pa,pb,pc)</div></blockquote>
<p>vector * float * (mb*mb*nb) array * (mb*mb*nb)
array * (mb*mb*nb) array</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>&#8211;&gt;  (mb*mb*nb) array * (mb*mb*nb) array *</dt>
<dd>(mb*mb*nb) array</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td>method_order</td>
<td>Method order for user-defined method if known.A i
nteger for 1-level methods, or a pair of   intege
r for 2-levels methods.</td>
</tr>
<tr class="row-even"><td>jac_lsodi</td>
<td><p class="first">Callable object to define the full Jacobian
matrix dr/du where r = g - A*s.
jac(u,t,s)    &#8211;&gt; dr/du
vector * float * vector</p>
<blockquote class="last">
<div>&#8212;-&gt;  2d-array with dimension (neq,neq)</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td>res_f77</td>
<td><p class="first">Intend to supply a Fortran subroutine as res.
This subroutine should be defined in form:</p>
<div class="last highlight-python"><pre>     subroutine res_f77(neq, t, u, s, r, ires)
Cf2py intent(hide) neq
Cf2py intent(out) r
Cf2py intent(in,out) ires
     double precision t, u, s, r
     dimension u(neq, s(neq), r(neq)
     ...
     return
     end</pre>
</div>
</td>
</tr>
<tr class="row-even"><td>jac_kwargs</td>
<td>Extra keyword arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span> <span class="pre">*jac_</span>
<span class="pre">args,**jac_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-odd"><td>mb</td>
<td>Block size. Describe the block-tridiagonal form
of matrix A together with nb.</td>
</tr>
<tr class="row-even"><td>myadvance</td>
<td>User supplied function to advance current solutio
n one step forward. See documents of class MySolv
er.</td>
</tr>
<tr class="row-odd"><td>spcrad_f77</td>
<td><dl class="first docutils">
<dt>Intend to supply a Fortran subroutine as spcrad.</dt>
<dd><dl class="first last docutils">
<dt>This subroutine should be defined in form:</dt>
<dd>double precision function spcrad_f7</dd>
</dl>
</dd>
</dl>
<p>7(              1
neq,t,u)      Cf2py intent(hide)  neq</p>
<blockquote>
<div><dl class="docutils">
<dt>integer       neq</dt>
<dd>double precision t,u(ne</dd>
</dl>
</div></blockquote>
<ol class="last loweralpha" start="17">
<li><dl class="first docutils">
<dt>spcrad_f77 =</dt>
<dd><dl class="first last docutils">
<dt>return</dt>
<dd><p class="first last">end</p>
</dd>
</dl>
</dd>
</dl>
</li>
</ol>
</td>
</tr>
<tr class="row-even"><td>h_in_fd_jac</td>
<td>h in finite difference approximation of the Jacob
ian (default: 0.0001)</td>
</tr>
<tr class="row-odd"><td>jac_lsodis</td>
<td><p class="first">Callable object to supply the jth column of
the sparse Jacobian matrix dr/du where
r = g - A*s.
jac(u,t,s,j,ia,ja)   &#8212;&#8211;&gt;   p
vector * float * vector * int * int vector</p>
<blockquote class="last">
<div><ul class="simple">
<li>int vector      &#8212;&#8212;&gt;   vector</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td>rtol</td>
<td>relative tolerance for solution (default: 1e-06)</td>
</tr>
<tr class="row-odd"><td>jac_constant</td>
<td>Flag to show whether Jacobian is constant, 0 (fal
se) or 1 (true) (default: 0)</td>
</tr>
<tr class="row-even"><td>ode_method</td>
<td>solver type: &#8220;adams&#8221; or &#8220;bdf&#8221; (default: adams)</td>
</tr>
<tr class="row-odd"><td>jac_lsodi_f77</td>
<td><p class="first">Intend to supply Fortran subroutine as jac_lsodi.
This subroutine should be defined in form:</p>
<div class="last highlight-python"><pre>      subroutine jac_lsodi_f77(neq, t, u, s, ml,
     1           mu, pd, nrowpd)
Cf2py intent(in, hide) neq, ml, mu, nrowpd
Cf2py intent(out) pd
      integer neq, ml, mu, nrowpd
      double precision t, u, pd, s
      dimension u(neq), s(neq), pd(nrowpd, neq)
      pd = ...
      return
      end</pre>
</div>
</td>
</tr>
<tr class="row-even"><td>jac</td>
<td>Jacobian of right-hand side function f (df/du) (d
efault: None)</td>
</tr>
<tr class="row-odd"><td>adda_banded_lsodi_f77</td>
<td><p class="first">Intend to supply a Fortran subroutine as
adda_banded.
This subroutine should be defined in form:</p>
<div class="last highlight-python"><pre>      subroutine adda_banded_lsodi_f77(neq, t,
     1         u, ml, mu, pd, nrowpd)
Cf2py intent(in, hide) neq, ml, mu
Cf2py intent(in, hide), depend(pd) nrowpd
Cf2py intent(in, out) pd
      integer neq, ml, mu, nrowpd
      double precision t, u, pd
      dimension u(neq), pd(nrowpd, neq)
      pd = ...
      return
      end</pre>
</div>
</td>
</tr>
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>jac_f77</td>
<td><p class="first">Intend to supply a Fortran subroutine as jac.
This subroutine should be defined in form:</p>
<div class="last highlight-python"><pre>      subroutine jac_f77(neq,t,u,ml,mu,pd,
     1      nrowpd)
Cf2py intent(hide) neq,ml,mu,nrowpd
Cf2py intent(out) pd
      integer neq,ml,mu,nrowpd
      double precision t,u,pd
      dimension u(neq),pd(neq,neq)
      pd = ...
      return
      end</pre>
</div>
</td>
</tr>
<tr class="row-even"><td>butcher_tableau</td>
<td>2d-array which contains the butcher table for use
r-supplied Runge-Kutta method. (n,n) array for 1-
level Runge-Kutta methods.(n+1,n) array for 2-lev
el Runge-Kutta methods.</td>
</tr>
<tr class="row-odd"><td>spcrad</td>
<td><dl class="first last docutils">
<dt>Function of (u, t) to estimate spectral radius of</dt>
<dd>Jacobian matrix in the rkc.f solver.</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td>atol</td>
<td>absolute tolerance for solution (default: 1e-08)</td>
</tr>
<tr class="row-odd"><td>adda_lsodi</td>
<td><p class="first">Callable object to add the matrix A = A(u,t) to
another matrix p stored in the same form as A.
addaName(u,t,p)  :   vector * float * 2d-array</p>
<blockquote class="last">
<div>&#8212;-&gt;  2d-array with dimension (neq,neq)</div></blockquote>
</td>
</tr>
<tr class="row-even"><td>nsteps</td>
<td>Max no of internal solver steps per time step (de
fault: 1000)</td>
</tr>
<tr class="row-odd"><td>max_step</td>
<td>Maximum step size for an adaptive algorithm</td>
</tr>
<tr class="row-even"><td>solver</td>
<td>Name of solver class in solvers that need an extr
a solver (e.g., AdaptiveResidual) (default: RK4)</td>
</tr>
<tr class="row-odd"><td>start_method</td>
<td>Method for the first steps in multi-step solvers
(default: RK2)</td>
</tr>
<tr class="row-even"><td>max_ords</td>
<td>Maximum order in stiff methods.</td>
</tr>
<tr class="row-odd"><td>jac_lsoibt</td>
<td><p class="first">Callable object to supply the jth column of
the Jacobian matrix dr/du where r = g - A*s,
stored in block-tridiagonal form.
The argument list should in form of (u,t,s).</p>
<blockquote class="last">
<div><p>jac(u,t,s)   &#8212;&#8211;&gt;   (pa,pb,pc)
vector * float * vector   &#8212;&#8212;&gt;  (mb*mb*nb)</p>
<blockquote>
<div>array * (mb*mb*nb) array * (mb*mb*nb) array</div></blockquote>
<p>pa, pb, and pc are to be loaded with partial
derivatives (elements of the Jacobian matrix)
on output, in terms of the block-tridiagonal
structure assumed. That is, load the diagonal
blocks into pa, the superdiagonal blocks (and
block (nb,nb-2)) into pb, and the subdiagonal
blocks (and block (1,3)) into pc.
The blocks in block-row k of dr/du are to be
loaded into pa(<em>,</em>,k), pb(<em>,</em>,k), and
pc(<em>,</em>,k).
Thus the affect of this function should be:
pa(i,j,k) = ( (i.j) element of k-th diagonal</p>
<blockquote>
<div>block of dr/du)</div></blockquote>
<dl class="docutils">
<dt>pb(i,j,k) = ( (i,j) element of block (k,k+1)</dt>
<dd>of dr/du, or block (nb,nb-2) if
k == nb)</dd>
<dt>pc(i,j,k) = ( (i,j) element of block (k,k-1)</dt>
<dd>of dr/du, or block (1,3) if k==1)</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td>ifactor</td>
<td>Maximum factor for increasing the step size (defa
ult: 2)</td>
</tr>
<tr class="row-odd"><td>eps_iter</td>
<td>Max error measure in nonlinear solver (default: 0
.0001)</td>
</tr>
<tr class="row-even"><td>mu</td>
<td>Upper half-bandwidth of banded jacobian matrix</td>
</tr>
<tr class="row-odd"><td>max_ordn</td>
<td>Maximum order in nonstiff methods.</td>
</tr>
<tr class="row-even"><td>ml</td>
<td>Lower half-bandwidth of banded jacobian matrix</td>
</tr>
<tr class="row-odd"><td>adda_lsodis</td>
<td><p class="first">Callable object to add j-th column of matrix
A = A(u,t) to another matrix stored in sparse
form.
adda(u,t,j,ia,ja,p)  :   &#8211;&gt; p
vector * float * int * int vector * int vector</p>
<blockquote class="last">
<div><ul class="simple">
<li>vector      &#8212;&gt;  vector</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td>strictdt</td>
<td>Uniform time mesh vs exact dt spacings (default:
True)</td>
</tr>
<tr class="row-odd"><td>nonlinear_solver</td>
<td>Newton or Picard nonlinear solver (default: Picar
d)</td>
</tr>
<tr class="row-even"><td>jac_banded_f77</td>
<td><dl class="first docutils">
<dt>Intend to supply a Fortran subroutine as jac_band</dt>
<dd><dl class="first last docutils">
<dt>jac_banded.</dt>
<dd><p class="first">This subroutine should be defined in form:</p>
<div class="last highlight-python"><pre>subroutine jac_banded_f77(neq,t,u</pre>
</div>
</dd>
</dl>
</dd>
</dl>
<p>,ml,             1                          mu,pd
,nrowpd)      Cf2py intent(hide) neq,ml,mu,nrowpd</p>
<blockquote>
<div><dl class="docutils">
<dt>Cf2py intent(out) pd</dt>
<dd><dl class="first last docutils">
<dt>integer neq,ml,mu,nrowpd</dt>
<dd><dl class="first last docutils">
<dt>double precision t,u,pd</dt>
<dd>dimension u(neq),pd(n</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl class="last docutils">
<dt>rowpd,neq)                    pd = ...</dt>
<dd><dl class="first last docutils">
<dt>return</dt>
<dd>end</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td>max_hnil</td>
<td>Maximum no of warning messages to be printed.</td>
</tr>
<tr class="row-even"><td>g_f77</td>
<td><p class="first">Intend to supply a Fortran subroutine as g.
This subroutine should be defined in form:</p>
<div class="last highlight-python"><pre>      subroutine g_f77(neq, t, u, ng, groot)
Cf2py intent(hide) neq
Cf2py optional, intent(hide) ng
Cf2py intent(in) t, u
Cf2py intent(out) groot
      integer neq, ng
      double precision t, u, groot
      dimension u(neq), groot(ng)
      groot = ...
      return
      end</pre>
</div>
</td>
</tr>
<tr class="row-odd"><td>jac_banded_lsodi_f77</td>
<td><p class="first">Intend to supply a Fortran subroutine as
jac_banded_lsodi.
This subroutine should be defined in form:</p>
<div class="last highlight-python"><pre>      subroutine jac_banded_lsodi_f77(neq, t, u,
     1      s, ml, mu, pd, nrowpd)
Cf2py intent(in, hide) neq, ml, mu, nrowpd
Cf2py intent(out) pd
      integer neq, ml, mu, nrowpd
      double precision t, u, pd, s
      dimension u(neq), s(neq), pd(nrowpd, neq)
      pd = ...
      return
      end</pre>
</div>
</td>
</tr>
<tr class="row-even"><td>use_special</td>
<td>Switch for using special times</td>
</tr>
<tr class="row-odd"><td>ia</td>
<td>Integer array with length neq+1 which contains
starting locations in ja of the descriptions
for columns 1...neq, in that order, with ia(1)
== 1. The last element ia[neq+1] should equal
to the total number of nonzero locations assumed.
For each column j = 1...neq, the values of the
row index i in column j, where a nonzero element
may occur, are given by i == ja(k) where ia(j) &lt;=
k &lt; ia(j+1).</td>
</tr>
<tr class="row-even"><td>ic</td>
<td>Array which contains starting locations in jc.</td>
</tr>
<tr class="row-odd"><td>jac_column_f77</td>
<td><p class="first">Intend to supply a Fortran subroutine as
jac_column.
This subroutine should be defined in form:</p>
<div class="last highlight-python"><pre>      subroutine jac_column_f77(neq, t, u, j,
     1       ia, ja, pd)
Cf2py intent(hide) neq, ia, ja
Cf2py intent(out) pd
      integer neq, j, ia, ja
      double precision t, u, pd
      dimension u(neq), pd(neq), ia(neq + 1),
     1       ja(*)
      pd = ...
      return
      end</pre>
</div>
</td>
</tr>
<tr class="row-even"><td>dfactor</td>
<td>Maximum factor for decreasing the step size (defa
ult: 0.5)</td>
</tr>
<tr class="row-odd"><td>res</td>
<td><p class="first">User-supplied function to calculate the residual
vector, defined by r =  g(u,t) - A(u,t) * s.
Used in the linearly implicit solvers: Lsodi,
Lsodis, Lsoibt.
res(u,t,s,ires)   &#8211;&gt;   (r,ires)
vector * float * vector * int &#8211;&gt;  vector * int</p>
<blockquote>
<div>&#8220;ires&#8221; is a flag both for input and output.</div></blockquote>
<p>On input, ires indicates how ODEPACK would use
the returned array &#8220;r&#8221;:
ires == 1: the full residual exactly.
ires == 2: &#8220;r&#8221; is used only to computejacobian</p>
<blockquote>
<div>dr/du by difference quotients.</div></blockquote>
<p class="last">&#8220;res&#8221; should set flag &#8220;ires&#8221; if it encounters a
halt condition or illegal input. Otherwise, it
should not be reset. On output, value 1 or -1
represents a normal return.</p>
</td>
</tr>
<tr class="row-even"><td>nb</td>
<td>Number of blocks in the main diagonal.
In each of the NB block-rows of the matrix P
(each consisting of MB consecutive rows), the
nonzero elements are to lie in three
consecutive MB by MB blocks.  In block-rows 2
through NB - 1, these are centered about the
main diagonal. In block-rows 1 and NB, they
are the diagonal blocks and the two blocks
adjacent to the diagonal block.  (Thus block
positions (1,3) and (NB,NB-2) can be nonzero.)
Require: mb&gt;=1, nb&gt;=4, mb*nb==neq.</td>
</tr>
<tr class="row-odd"><td>ng</td>
<td>No of components in constraint function g.</td>
</tr>
<tr class="row-even"><td>first_step</td>
<td>Suggested first time step size for an adaptive al
gorithm</td>
</tr>
<tr class="row-odd"><td>liw</td>
<td>Length of integer work array, similiar as &lt;lrw&gt;.</td>
</tr>
<tr class="row-even"><td>safety</td>
<td>Safety factor on new step selection (default: 0.9
)</td>
</tr>
<tr class="row-odd"><td>adams_or_bdf</td>
<td>Method in vode or solvers in odepack: &#8220;adams&#8221; or
&#8220;bdf&#8221; (default: adams)</td>
</tr>
<tr class="row-even"><td>theta</td>
<td>Weight in [0,1] used for &#8220;theta-rule&#8221; finite diff
erence approx. (default: 0.5)</td>
</tr>
<tr class="row-odd"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
<tr class="row-even"><td>iter_method</td>
<td>Corrector iteration method choice</td>
</tr>
<tr class="row-odd"><td>min_step</td>
<td>Minimum step size for an adaptive algorithm</td>
</tr>
<tr class="row-even"><td>max_iter</td>
<td>Max no of iterations in nonlinear solver (default
: 25)</td>
</tr>
<tr class="row-odd"><td>f_f77</td>
<td><p class="first">Intend to supply a Fortran subroutine as f.
This subroutine should be defined in form:</p>
<div class="last highlight-python"><pre>      subroutine f_f77(neq,t,u,udot)
Cf2py intent(hide)   neq
Cf2py intent(out)    udot
      integer neq
      double precision t,u(neq),udot(neq)
      udot = ...
      return
      end</pre>
</div>
</td>
</tr>
<tr class="row-even"><td>jac_banded</td>
<td><p class="first">A callable object to define the banded Jacobian
matrix(df/du) of right-hand side function f.
Used in Lsode, Lsoda, Lsodar.</p>
<blockquote class="last">
<div>jac_banded(u,t,ml,mu) returns df/du
vector * float * int * int &#8211;&gt;   2d-array</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td>beta</td>
<td><dl class="first last docutils">
<dt>Beta argument for stabilized step size control in</dt>
<dd>Dormand&amp;Prince methods from scipy</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td>moss</td>
<td>Method to obtain sparse structure of Jacobian.</td>
</tr>
<tr class="row-odd"><td>relaxation</td>
<td>relaxation argument (r): new_solution = r*solutio
n + (1-r)*old_solution (default: 1.0)</td>
</tr>
<tr class="row-even"><td>stiff</td>
<td>Boolean flag to indicate stiffness.</td>
</tr>
<tr class="row-odd"><td>adda_banded_lsodi</td>
<td><p class="first">Callable object to add the banded matrix
A = A(u,t) to another matrix stored P in the
same form as A, i.e. add A(i,j)to P(i-j+MU+1,j)
addaName(u,t,p,ml,mu):
vector * float * 2d-array * int * int</p>
<blockquote class="last">
<div>&#8212;&gt;  2d-array with dimension (<a href="#id1"><span class="problematic" id="id2">*</span></a>,neq)</div></blockquote>
</td>
</tr>
<tr class="row-even"><td>ja</td>
<td>Integer array containing the row indices where
nonzero elements occur, reading in columnwise
order.
Describes the sparsity matrix structure
together with ia.
In Lsodes, ia &amp; ja describe the structure of
Jacobian matrix; while in Lsodis, ia &amp; ja are
used to describe the structure of matrix A.</td>
</tr>
<tr class="row-odd"><td>init_step</td>
<td>Fixed step size for time mesh.</td>
</tr>
<tr class="row-even"><td>jc</td>
<td>Integer array which describes the sparsity
Jacobian structure together with ic, like ia
and ja.
In Lsodis, ia and ja describe the sparse
structure of matrix A, while ic &amp; jc describe
the sparse structure of Jacobian matrix.</td>
</tr>
<tr class="row-odd"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
<tr class="row-even"><td>g</td>
<td><p class="first">Callable object to define constraint functions,
whose roots are desired during the integration.</p>
<blockquote class="last">
<div>g(u, t) &#8211;&gt; values of constraint functions
scalar/vector * float &#8211;&gt; scalar/vector</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td>adda_lsodi_f77</td>
<td><p class="first">Intend to supply a Fortran subroutine as
adda_lsodi.
This subroutine should be defined in form:</p>
<div class="last highlight-python"><pre>      subroutine adda_lsodi_f77(neq, t, u, ml,
     1       mu, pd, nrowpd)
Cf2py intent(in, hide) neq, ml, mu
Cf2py intent(in, hide), depend(pd) nrowpd
Cf2py intent(in, out) pd
      integer neq, ml, mu, nrowpd
      double precision t, u, pd
      dimension u(neq), pd(nrowpd, neq)
      pd = ...
      return
      end</pre>
</div>
</td>
</tr>
<tr class="row-even"><td>seth</td>
<td>Element threshhold for sparsity determination. (d
efault: 0)</td>
</tr>
<tr class="row-odd"><td>order</td>
<td>Maximum order used by the integrator (&lt;= 12 for &#8221;
adams&#8221;, &lt;= 5 for &#8220;bdf&#8221;) (default: 4)</td>
</tr>
<tr class="row-even"><td>jac_column</td>
<td><dl class="first last docutils">
<dt>A callable object to specify a column of Jacobian</dt>
<dd>(df/du) matrix.</dd>
<dt>jac(u,t,j,ia,ja): jth column of Jacobian (df/du)</dt>
<dd>vector * float * integer * integer vector
* integer vector    &#8212;&gt;  vector</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td>jac_args</td>
<td>Extra positional arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span> <span class="pre">*j</span>
<span class="pre">ac_args,**jac_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-even"><td>jac_banded_lsodi</td>
<td><p class="first">Callable object to define the banded Jacobian
matrix dr/du where r = g - A*s.
jac(u,t,s,ml,mu), where ml &amp; mu are lower &amp; upper
half-bandwidth of banded matrix.
vector * float * vector * int * int</p>
<blockquote class="last">
<div>&#8212;&gt;  2d-array with dimension (<a href="#id3"><span class="problematic" id="id4">*</span></a>,neq)</div></blockquote>
</td>
</tr>
<tr class="row-odd"><td>ydoti</td>
<td>Real array for the initial value of dy/dt. (defau
lt: [])</td>
</tr>
<tr class="row-even"><td>specialtimes</td>
<td>List of special times to use during iteration</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.MySolver.advance" title="odesolvers.ODE.MySolver.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td>Setting values of internal attributes to be used in iteration.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra check after all the attributes, (including inputs and internal parameters), have been initialized, e.g.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odesolvers.ODE.MySolver.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.MySolver.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.MySolver.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#MySolver.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.MySolver.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.ODE.Ode_scipy">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">Ode_scipy</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Ode_scipy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Ode_scipy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.ODE.Adaptive" title="odesolvers.ODE.Adaptive"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.Adaptive</span></tt></a></p>
<p>Super class wrapper for scipy.integrate.ode classes.
Existing solvers in subclasses are: Vode, Dopri5, Dop853.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
<tr class="row-odd"><td>jac</td>
<td>Jacobian of right-hand side function f (df/du) (d
efault: None)</td>
</tr>
<tr class="row-even"><td>jac_kwargs</td>
<td>Extra keyword arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span> <span class="pre">*jac_</span>
<span class="pre">args,**jac_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-odd"><td>jac_args</td>
<td>Extra positional arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span> <span class="pre">*j</span>
<span class="pre">ac_args,**jac_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-even"><td>atol</td>
<td>absolute tolerance for solution (default: 1e-08)</td>
</tr>
<tr class="row-odd"><td>rtol</td>
<td>relative tolerance for solution (default: 1e-06)</td>
</tr>
<tr class="row-even"><td>first_step</td>
<td>Suggested first time step size for an adaptive al
gorithm</td>
</tr>
<tr class="row-odd"><td>max_step</td>
<td>Maximum step size for an adaptive algorithm</td>
</tr>
<tr class="row-even"><td>nsteps</td>
<td>Max no of internal solver steps per time step (de
fault: 1000)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.Ode_scipy.advance" title="odesolvers.ODE.Ode_scipy.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.Ode_scipy.initialize" title="odesolvers.ODE.Ode_scipy.initialize"><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.ODE.Ode_scipy.initialize_for_solve" title="odesolvers.ODE.Ode_scipy.initialize_for_solve"><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra check after all the attributes, (including inputs and internal parameters), have been initialized, e.g.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odesolvers.ODE.Ode_scipy.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.Ode_scipy.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Ode_scipy.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Ode_scipy.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Ode_scipy.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Ode_scipy.initialize">
<tt class="descname">initialize</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Ode_scipy.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Ode_scipy.initialize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Ode_scipy.initialize_for_solve">
<tt class="descname">initialize_for_solve</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Ode_scipy.initialize_for_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Ode_scipy.initialize_for_solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.ODE.RK2">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">RK2</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#RK2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.RK2" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.ODE.Solver" title="odesolvers.ODE.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.Solver</span></tt></a></p>
<p>Standard Runge-Kutta 2nd method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])),</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
</pre></div>
</div>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.RK2.advance" title="odesolvers.ODE.RK2.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td>Setting values of internal attributes to be used in iteration.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra check after all the attributes, (including inputs and internal parameters), have been initialized, e.g.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odesolvers.ODE.RK2.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.RK2.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.RK2.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#RK2.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.RK2.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.RK2.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Explicit 2nd-order Runge-Kutta method'</em><a class="headerlink" href="#odesolvers.ODE.RK2.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.ODE.RK3">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">RK3</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#RK3"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.RK3" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.ODE.Solver" title="odesolvers.ODE.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.Solver</span></tt></a></p>
<p>RungeKutta3 method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mf">6.0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">K1</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">K2</span> <span class="o">+</span> <span class="n">K3</span><span class="p">)</span>
</pre></div>
</div>
<p>where:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">K1</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
<span class="n">K2</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">K1</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
<span class="n">K3</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">K1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">K2</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="p">)</span>
</pre></div>
</div>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.RK3.advance" title="odesolvers.ODE.RK3.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td>Setting values of internal attributes to be used in iteration.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra check after all the attributes, (including inputs and internal parameters), have been initialized, e.g.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odesolvers.ODE.RK3.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.RK3.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.RK3.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#RK3.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.RK3.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.RK3.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Explicit 3rd-order Runge-Kutta method'</em><a class="headerlink" href="#odesolvers.ODE.RK3.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.ODE.RK4">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">RK4</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#RK4"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.RK4" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.ODE.Solver" title="odesolvers.ODE.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.Solver</span></tt></a></p>
<p>Standard RK4 method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mf">6.0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">K1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">K2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">K3</span> <span class="o">+</span> <span class="n">K4</span><span class="p">)</span>
</pre></div>
</div>
<p>where:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">K1</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
<span class="n">K2</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">K1</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
<span class="n">K3</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">K2</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
<span class="n">K4</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">K3</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="p">)</span>
</pre></div>
</div>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.RK4.advance" title="odesolvers.ODE.RK4.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td>Setting values of internal attributes to be used in iteration.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra check after all the attributes, (including inputs and internal parameters), have been initialized, e.g.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odesolvers.ODE.RK4.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.RK4.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.RK4.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#RK4.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.RK4.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.RK4.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Explicit 4th-order Runge-Kutta method'</em><a class="headerlink" href="#odesolvers.ODE.RK4.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.ODE.RKFehlberg">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">RKFehlberg</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#RKFehlberg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.RKFehlberg" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.ODE.Adaptive" title="odesolvers.ODE.Adaptive"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.Adaptive</span></tt></a></p>
<p>The classical adaptive Runge-Kutta-Fehlberg method of order 4-5.    
Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
<tr class="row-odd"><td>rtol</td>
<td>relative tolerance for solution (default: 1e-06)</td>
</tr>
<tr class="row-even"><td>atol</td>
<td>absolute tolerance for solution (default: 1e-08)</td>
</tr>
<tr class="row-odd"><td>first_step</td>
<td>Suggested first time step size for an adaptive al
gorithm</td>
</tr>
<tr class="row-even"><td>min_step</td>
<td>Minimum step size for an adaptive algorithm</td>
</tr>
<tr class="row-odd"><td>max_step</td>
<td>Maximum step size for an adaptive algorithm</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.RKFehlberg.advance" title="odesolvers.ODE.RKFehlberg.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.ODE.RKFehlberg.initialize_for_solve" title="odesolvers.ODE.RKFehlberg.initialize_for_solve"><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra check after all the attributes, (including inputs and internal parameters), have been initialized, e.g.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odesolvers.ODE.RKFehlberg.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.RKFehlberg.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.RKFehlberg.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#RKFehlberg.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.RKFehlberg.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.RKFehlberg.initialize_for_solve">
<tt class="descname">initialize_for_solve</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#RKFehlberg.initialize_for_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.RKFehlberg.initialize_for_solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.RKFehlberg.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Adaptive Runge-Kutta-Fehlberg (4,5) method'</em><a class="headerlink" href="#odesolvers.ODE.RKFehlberg.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.ODE.Solver">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">Solver</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Solver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Solver" title="Permalink to this definition">¶</a></dt>
<dd><p>Superclass for numerical methods solving ODE problem</p>
<blockquote>
<div>u&#8217;(t) = f(u, t),  u(0) = U0</div></blockquote>
<p>where u and U0 are scalars (for scalar ODEs) or vectors
(for systems of ODEs).</p>
<p>Attributes stored in this class:</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>u</td>
<td>array of point values of the solution function</td>
</tr>
<tr class="row-odd"><td>t</td>
<td>array of time values: u[i] corresponds to t[i]</td>
</tr>
<tr class="row-even"><td>n</td>
<td>the most recently computed solution is u[n+1]</td>
</tr>
<tr class="row-odd"><td>f</td>
<td>function wrapping the user&#8217;s right-hand side f(u, t),
used in all algorithms</td>
</tr>
<tr class="row-even"><td>users_f</td>
<td>the user&#8217;s original function implementing f(u, t)</td>
</tr>
<tr class="row-odd"><td>PRM</td>
<td>an attribute for each optional and required parameter</td>
</tr>
</tbody>
</table>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.ODE.Solver.adjust_parameters" title="odesolvers.ODE.Solver.adjust_parameters"><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt></a>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.Solver.advance" title="odesolvers.ODE.Solver.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td>Advance solution one time step.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.ODE.Solver.check_conditional_parameters" title="odesolvers.ODE.Solver.check_conditional_parameters"><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt></a>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.Solver.check_extra" title="odesolvers.ODE.Solver.check_extra"><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt></a>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.ODE.Solver.check_input_range" title="odesolvers.ODE.Solver.check_input_range"><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt></a>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.Solver.check_input_types" title="odesolvers.ODE.Solver.check_input_types"><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt></a>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.ODE.Solver.compile_string_functions" title="odesolvers.ODE.Solver.compile_string_functions"><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt></a>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.Solver.constant_time_step" title="odesolvers.ODE.Solver.constant_time_step"><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt></a>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.ODE.Solver.func_wrapper" title="odesolvers.ODE.Solver.func_wrapper"><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt></a>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.Solver.get" title="odesolvers.ODE.Solver.get"><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt></a>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.ODE.Solver.get_parameter_info" title="odesolvers.ODE.Solver.get_parameter_info"><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt></a>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.Solver.initialize" title="odesolvers.ODE.Solver.initialize"><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt></a>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.ODE.Solver.initialize_for_solve" title="odesolvers.ODE.Solver.initialize_for_solve"><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt></a>()</td>
<td>Setting values of internal attributes to be used in iteration.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.Solver.set" title="odesolvers.ODE.Solver.set"><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt></a>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.ODE.Solver.set_initial_condition" title="odesolvers.ODE.Solver.set_initial_condition"><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt></a>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.Solver.solve" title="odesolvers.ODE.Solver.solve"><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt></a>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.ODE.Solver.switch_to" title="odesolvers.ODE.Solver.switch_to"><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt></a>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.Solver.validate_data" title="odesolvers.ODE.Solver.validate_data"><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt></a>()</td>
<td>This function is used for extra check after all the attributes, (including inputs and internal parameters), have been initialized, e.g.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="odesolvers.ODE.Solver.__init__">
<tt class="descname">__init__</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Solver.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Solver.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">f</span></tt> is the right-hand side function of the ODE u&#8217; = f(u,t).
The legal keyword arguments (in <tt class="docutils literal"><span class="pre">kwargs</span></tt>) are documented in
the tables in the doc string of this class. The <tt class="docutils literal"><span class="pre">f</span></tt> function
must return a <tt class="docutils literal"><span class="pre">float</span></tt> or <tt class="docutils literal"><span class="pre">complex</span></tt> object in case of a
scalar ODE and a list or array of <tt class="docutils literal"><span class="pre">float</span></tt> or <tt class="docutils literal"><span class="pre">complex</span></tt> objects
in case of a system of ODEs.</p>
<p>This constructor makes a dictionary <tt class="docutils literal"><span class="pre">self._parameters</span></tt>
holding all the required and optional parameters for this solver
(fetched from the global <tt class="docutils literal"><span class="pre">_parameters</span></tt> dictionary in this module).
The method <tt class="docutils literal"><span class="pre">adjust_parameters</span></tt> (implemented in subclasses)
is called to adjust default parameter settings if needed.
Then all keys in <tt class="docutils literal"><span class="pre">self._parameters</span></tt> become class attributes,
filled with default values. Thereafter, all keyword arguments
(in <tt class="docutils literal"><span class="pre">kwargs</span></tt>) with <tt class="docutils literal"><span class="pre">None</span></tt> as value are removed as keyword
arguments. The next step is to call <tt class="docutils literal"><span class="pre">set(**kwargs)</span></tt>, i.e.,
use the keyword arguments to modify the values of the attributes
that represent the parameters in this solver. Finally, the
constructor calls the method <tt class="docutils literal"><span class="pre">initialize</span></tt> (to be implemeneted
in subclasses, e.g., for importing necessary modules for the solver).</p>
<p>Instead of supplying keyword arguments to this constructor, the
user can at any time call the <tt class="docutils literal"><span class="pre">set</span></tt> method with keyword
arguments in order to specify parameters.</p>
</dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.Solver.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.Solver.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Solver.__repr__">
<tt class="descname">__repr__</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Solver.__repr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Solver.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return solvername(f=..., param1=..., etc.).</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Solver.__str__">
<tt class="descname">__str__</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Solver.__str__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Solver.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return solvername, plus parameters that are different from
the default value.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Solver.adjust_parameters">
<tt class="descname">adjust_parameters</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Solver.adjust_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Solver.adjust_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>This method allows subclasses to adjust (modify or add)
entries in the self._parameters dictionary.
The method is called from the constructor.</p>
<p>Further adjustments of self._parameters can be done in
initialize_for_solve when all data for the solver are available.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Solver.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Solver.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Solver.advance" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance solution one time step.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Solver.check_conditional_parameters">
<tt class="descname">check_conditional_parameters</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Solver.check_conditional_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Solver.check_conditional_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to check whether conditional parameters are
provided when specified condition fulfilled.</p>
<p>This function is not intended for simple solvers.
So it is not called automatically in current ODE.py.
But for some complicated solvers as ones in ODEPACK, they
are very useful and convenient.</p>
<p>Future developers can apply these functions at appropriate
locations with corresponding property-setting in
adjust_parameters().</p>
<p>For example, in Lsode_ODEPACK, when iter_method is set to 4, it
indicates that ODEPACK would apply user-supplied banded Jacoabian
function in corrector iteration. Then we need to confirm either
&#8216;jac_banded&#8217; or &#8216;jac_fortran&#8217; is supplied. Besides, &#8216;ml&#8217; &amp; &#8216;mu&#8217; are
also necessary for iteration with banded Jacobian matrix.
Thus in order to confirm sufficient conditional inputs, we set
parameters[&#8216;iter_method&#8217;][&#8216;condition_list&#8217;] =</p>
<blockquote>
<div>{...,&#8216;4&#8217;: ((&#8216;jac_banded&#8217;,&#8217;jac_fortran&#8217;),ml,mu),...}</div></blockquote>
<p>In this function, we would check all the legal parameters with specified
condition-list, and make sure all the conditional parameters with
current value is supplied.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Solver.check_extra">
<tt class="descname">check_extra</tt><big>(</big><em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Solver.check_extra"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Solver.check_extra" title="Permalink to this definition">¶</a></dt>
<dd><p>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given
functions that performs consistency checks on the parameter.
This method runs the user-given function(s) on the relevant
set of parameters.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Solver.check_input_range">
<tt class="descname">check_input_range</tt><big>(</big><em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Solver.check_input_range"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Solver.check_input_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether all existing inputs are in right specified range.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Solver.check_input_types">
<tt class="descname">check_input_types</tt><big>(</big><em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Solver.check_input_types"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Solver.check_input_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether all existing inputs are of right specified type.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Solver.compile_string_functions">
<tt class="descname">compile_string_functions</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Solver.compile_string_functions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Solver.compile_string_functions" title="Permalink to this definition">¶</a></dt>
<dd><p>Compile functions which are supplied as Fortran strings.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Solver.constant_time_step">
<tt class="descname">constant_time_step</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Solver.constant_time_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Solver.constant_time_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if self.t has a uniform partition.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Solver.func_wrapper">
<tt class="descname">func_wrapper</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Solver.func_wrapper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Solver.func_wrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is defined to wrap user-defined functions with new
forms of parameter-list, or wrap the returned values as numpy arrays.</p>
<p>Firstly, in odesolvers, all the user-supplied functions should have a
parameter list starts with &#8220;u,t,...&#8221;. But in some special subclasses,
(like solvers in ODEPACK), all the parameter lists of user-defined
functions start with &#8220;t,u,...&#8221;. So we need this general function to
wrap all these user-defined functions.</p>
<p>Secondly, in some user-defined functions, according to the different
start indices in Fortran and Python, we need to make special wrapping
for these uncompability. For an example, in user-defined function
&#8220;jac_column&#8221;, column index is an internally valued parameter in
Fortran code. In Python, it starts from 0 instead of 1 in Fortran.
So we need to wrap the parameter list of user-defined &#8220;jac_column&#8221; from
&#8220;u,t,j&#8221; to &#8220;t,u,j+1&#8221;. That is, define the jacobian function as
lambda t,u,j: jac_column(u,t,j-1).</p>
<p>Furthermore, the return value of user-defined functions need to be
wrapped to Numpy arrays with great numerical features, e.g.
vectorization and array slicing. In order to avoid unnecessary array
copy by F2PY, it is always recommended to explicitly transform all
Numpy arrays to Fortran order in Python code.</p>
<p>This functions is not intended for simple solvers. So it is not called
automatically in current version. But for some complicated solvers as
ones in ODEPACK, it is very useful and convenient.</p>
<p>Future developers can call this functions with appropriate locations
and corresponding property-setting in adjust_parameters().</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Solver.get">
<tt class="descname">get</tt><big>(</big><em>parameter_name=None</em>, <em>print_info=False</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Solver.get"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Solver.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Return value of specified input parameters.
If parameter_name is None, return dict of all inputs.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Solver.get_parameter_info">
<tt class="descname">get_parameter_info</tt><big>(</big><em>print_info=False</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Solver.get_parameter_info"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Solver.get_parameter_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary containing all properties of all
legal parameters in current subclass (i.e., the parameters
in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</p>
<p>If <em>print_info</em> is <em>True</em>, the <tt class="docutils literal"><span class="pre">self._parameters</span></tt> dict
is pretty printed, otherwise it is returned.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Solver.initialize">
<tt class="descname">initialize</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Solver.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Solver.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Subclass-specific initialization. Called from constructor.
Typical use: import modules needed in methods in the class
and provide error messages if modules are not installed.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Solver.initialize_for_solve">
<tt class="descname">initialize_for_solve</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Solver.initialize_for_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Solver.initialize_for_solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Setting values of internal attributes to be used in iteration.</p>
<p>These internal attributes are ususally dependent on the values of
other attributes. For example, for Rkc, self.itol should be
initialized here as a flag to indicate whether self.atol is
supplied as scalar or sequence.</p>
<p>In subclasses, this function can be extended when required.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Solver.set">
<tt class="descname">set</tt><big>(</big><em>strict=False</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Solver.set"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Solver.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign values to one or more parameters, specified as keyword
arguments.</p>
<p>The legal parameters that can be set are contained in the dict
self._parameters.</p>
<p>If strict is true, only registered parameter names are accepted,
otherwise unregistered parameters are ignored.</p>
<p>The provided parameters (keyword arguments in kwargs) are
first checked for legal type and legal range.</p>
<p>Types and ranges of attributes are defined in self._parameters,
which is initialized with default settings and optionally
modified in the adjust_parameters method.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Solver.set_initial_condition">
<tt class="descname">set_initial_condition</tt><big>(</big><em>U0</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Solver.set_initial_condition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Solver.set_initial_condition" title="Permalink to this definition">¶</a></dt>
<dd><p>Function set_initial_condition() is used to set initial value of
independent variables.</p>
</dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Solver.solve">
<tt class="descname">solve</tt><big>(</big><em>time_points</em>, <em>terminate=None</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Solver.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Solver.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute discrete solution u of the ODE problem at time points
specified in the array time_points. An optional user-supplied
function <tt class="docutils literal"><span class="pre">terminate(u,</span> <span class="pre">t,</span> <span class="pre">step_no)</span></tt> can be supplied to
terminate the solution process (<tt class="docutils literal"><span class="pre">terminate</span></tt> returns True
or False) at some time earlier than <tt class="docutils literal"><span class="pre">time_points[-1]</span></tt>.</p>
<p>Most classes in this solver hierarchy inherit this <tt class="docutils literal"><span class="pre">solve</span></tt>
method and implement their special <tt class="docutils literal"><span class="pre">advance</span></tt> method to
advance the solution one step.
Some solver classes will implement their own <tt class="docutils literal"><span class="pre">solve</span></tt>
method, for instance if they wrap some underlying software
that has a suitable <tt class="docutils literal"><span class="pre">solve</span></tt> functionality.</p>
<p>The algorithm steps in this <tt class="docutils literal"><span class="pre">solve</span></tt> method goes as follows.
The initialize_for_solve method is called to initialize
various data needed in the solution process (self. u, for instance).
Thereafter, <tt class="docutils literal"><span class="pre">validate_data</span></tt> is called to perform a consistency
check on data. We are then ready for the core of the method:
the time loop.</p>
<dl class="docutils">
<dt>Output:</dt>
<dd>u            : array to hold solution values corresponding to points
t            : array to hold time values.Usually same as time_points</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Solver.switch_to">
<tt class="descname">switch_to</tt><big>(</big><em>solver_target</em>, <em>print_info=False</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Solver.switch_to"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Solver.switch_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new solver instance which switch to another subclass with
same values of common attributes.</p>
<p><cite>solver_target</cite> is either as a string (class name) or
a class, i.e., <tt class="docutils literal"><span class="pre">RK4</span></tt> or <tt class="docutils literal"><span class="pre">'RK4'</span></tt>.
The <cite>kwargs</cite> arguments are optional parameters to
reset/supplement values of argmenters in the solver we switch to.
The instance of the target solver is returned.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">odesolvers</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">,</span><span class="n">t</span><span class="p">:</span> <span class="o">-</span><span class="n">u</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exact_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">time_points</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span> <span class="o">=</span> <span class="n">odesolvers</span><span class="o">.</span><span class="n">RK2</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">time_points</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&#39;Normarized error with RK2 is </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">u1</span> <span class="o">-</span> <span class="n">exact_u</span><span class="p">)</span>
<span class="go">Normarized error with RK2 is 0.0077317</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">switch_to</span><span class="p">(</span><span class="n">odesolvers</span><span class="o">.</span><span class="n">RKFehlberg</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-18</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u2</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">m2</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">time_points</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&#39;Normarized error with RKFehlberg is </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">u2</span> <span class="o">-</span> <span class="n">exact_u</span><span class="p">)</span>
<span class="go">Normarized error with RKFehlberg is 8.55517e-08</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Solver.validate_data">
<tt class="descname">validate_data</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Solver.validate_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Solver.validate_data" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used for extra check after all the attributes,
(including inputs and internal parameters), have been
initialized, e.g. control the specific relations among values of
relative attributes.</p>
<p>In subclasses, this function can be extended when required.
For example, when banded Jacobian matrix is supplied in Lsode,
lower/higher band (&#8216;ml&#8217; &amp; &#8216;mu&#8217;) have to be provided by user.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.ODE.SolverImplicit">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">SolverImplicit</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#SolverImplicit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.SolverImplicit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.ODE.Solver" title="odesolvers.ODE.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.Solver</span></tt></a></p>
<p>Super class for implicit methods for ODEs.
Existing solvers are: BackwardEuler, Backward2Step, ThetaRule</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
<tr class="row-odd"><td>jac</td>
<td>Jacobian of right-hand side function f (df/du) (d
efault: None)</td>
</tr>
<tr class="row-even"><td>jac_args</td>
<td>Extra positional arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span> <span class="pre">*j</span>
<span class="pre">ac_args,**jac_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>jac_kwargs</td>
<td>Extra keyword arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span> <span class="pre">*jac_</span>
<span class="pre">args,**jac_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>h_in_fd_jac</td>
<td>h in finite difference approximation of the Jacob
ian (default: 0.0001)</td>
</tr>
<tr class="row-odd"><td>nonlinear_solver</td>
<td>Newton or Picard nonlinear solver (default: Picar
d)</td>
</tr>
<tr class="row-even"><td>max_iter</td>
<td>Max no of iterations in nonlinear solver (default
: 25)</td>
</tr>
<tr class="row-odd"><td>eps_iter</td>
<td>Max error measure in nonlinear solver (default: 0
.0001)</td>
</tr>
<tr class="row-even"><td>relaxation</td>
<td>relaxation argument (r): new_solution = r*solutio
n + (1-r)*old_solution (default: 1.0)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.SolverImplicit.advance" title="odesolvers.ODE.SolverImplicit.advance"><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.ODE.SolverImplicit.initialize_for_solve" title="odesolvers.ODE.SolverImplicit.initialize_for_solve"><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra check after all the attributes, (including inputs and internal parameters), have been initialized, e.g.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odesolvers.ODE.SolverImplicit.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.SolverImplicit.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.SolverImplicit.advance">
<tt class="descname">advance</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#SolverImplicit.advance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.SolverImplicit.advance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.SolverImplicit.initialize_for_solve">
<tt class="descname">initialize_for_solve</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#SolverImplicit.initialize_for_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.SolverImplicit.initialize_for_solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.ODE.SymPy_odefun">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">SymPy_odefun</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#SymPy_odefun"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.SymPy_odefun" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.ODE.Solver" title="odesolvers.ODE.Solver"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.Solver</span></tt></a></p>
<p>Wrapper for the sympy.mpmath.odefun method, which applies a high-order
Taylor series method to solve ODEs.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td>Advance solution one time step.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.SymPy_odefun.initialize" title="odesolvers.ODE.SymPy_odefun.initialize"><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.ODE.SymPy_odefun.initialize_for_solve" title="odesolvers.ODE.SymPy_odefun.initialize_for_solve"><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.SymPy_odefun.solve" title="odesolvers.ODE.SymPy_odefun.solve"><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt></a>(time_points[,&nbsp;terminate])</td>
<td>The complete solve method must be overridded in this class since sympy.mpmath.odefun is such a solve method.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra check after all the attributes, (including inputs and internal parameters), have been initialized, e.g.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odesolvers.ODE.SymPy_odefun.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.SymPy_odefun.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.SymPy_odefun.initialize">
<tt class="descname">initialize</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#SymPy_odefun.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.SymPy_odefun.initialize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.SymPy_odefun.initialize_for_solve">
<tt class="descname">initialize_for_solve</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#SymPy_odefun.initialize_for_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.SymPy_odefun.initialize_for_solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.SymPy_odefun.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Very accurate high order Taylor method (from SymPy)'</em><a class="headerlink" href="#odesolvers.ODE.SymPy_odefun.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.SymPy_odefun.solve">
<tt class="descname">solve</tt><big>(</big><em>time_points</em>, <em>terminate=None</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#SymPy_odefun.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.SymPy_odefun.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>The complete solve method must be overridded in this class
since sympy.mpmath.odefun is such a solve method.</p>
<p>The class stores an attribute ufunc (return from odefun)
which can be used to evaluate u at any time point (ufunc(t)).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="odesolvers.ODE.ThetaRule">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">ThetaRule</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#ThetaRule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.ThetaRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.ODE.SolverImplicit" title="odesolvers.ODE.SolverImplicit"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.SolverImplicit</span></tt></a></p>
<p>Theta rule method as a typical weighted method with factor theta:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="p">(</span><span class="n">theta</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span>
</pre></div>
</div>
<p>where theta is a float in [0,1].</p>
<p>The nonlinear system is solved by Picard or Newton iteration.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
<tr class="row-odd"><td>jac</td>
<td>Jacobian of right-hand side function f (df/du) (d
efault: None)</td>
</tr>
<tr class="row-even"><td>jac_args</td>
<td>Extra positional arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span> <span class="pre">*j</span>
<span class="pre">ac_args,**jac_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>jac_kwargs</td>
<td>Extra keyword arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span> <span class="pre">*jac_</span>
<span class="pre">args,**jac_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>h_in_fd_jac</td>
<td>h in finite difference approximation of the Jacob
ian (default: 0.0001)</td>
</tr>
<tr class="row-odd"><td>nonlinear_solver</td>
<td>Newton or Picard nonlinear solver (default: Picar
d)</td>
</tr>
<tr class="row-even"><td>max_iter</td>
<td>Max no of iterations in nonlinear solver (default
: 25)</td>
</tr>
<tr class="row-odd"><td>eps_iter</td>
<td>Max error measure in nonlinear solver (default: 0
.0001)</td>
</tr>
<tr class="row-even"><td>relaxation</td>
<td>relaxation argument (r): new_solution = r*solutio
n + (1-r)*old_solution (default: 1.0)</td>
</tr>
<tr class="row-odd"><td>theta</td>
<td>Weight in [0,1] used for &#8220;theta-rule&#8221; finite diff
erence approx. (default: 0.5)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.ODE.ThetaRule.Newton_system" title="odesolvers.ODE.ThetaRule.Newton_system"><tt class="xref py py-obj docutils literal"><span class="pre">Newton_system</span></tt></a>(ukp1)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#odesolvers.ODE.ThetaRule.Picard_update" title="odesolvers.ODE.ThetaRule.Picard_update"><tt class="xref py py-obj docutils literal"><span class="pre">Picard_update</span></tt></a>(ukp1)</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td>Subclass-specific initialization.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra check after all the attributes, (including inputs and internal parameters), have been initialized, e.g.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="odesolvers.ODE.ThetaRule.Newton_system">
<tt class="descname">Newton_system</tt><big>(</big><em>ukp1</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#ThetaRule.Newton_system"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.ThetaRule.Newton_system" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.ThetaRule.Picard_update">
<tt class="descname">Picard_update</tt><big>(</big><em>ukp1</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#ThetaRule.Picard_update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.ThetaRule.Picard_update" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.ThetaRule.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.ThetaRule.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.ThetaRule.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Unified Forward/Backward Euler and Midpoint methods'</em><a class="headerlink" href="#odesolvers.ODE.ThetaRule.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.Trapezoidal">
<tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">Trapezoidal</tt><a class="headerlink" href="#odesolvers.ODE.Trapezoidal" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#odesolvers.ODE.Heun" title="odesolvers.ODE.Heun"><tt class="xref py py-class docutils literal"><span class="pre">Heun</span></tt></a></p>
</dd></dl>

<dl class="class">
<dt id="odesolvers.ODE.Vode">
<em class="property">class </em><tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">Vode</tt><big>(</big><em>f</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Vode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Vode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#odesolvers.ODE.Ode_scipy" title="odesolvers.ODE.Ode_scipy"><tt class="xref py py-class docutils literal"><span class="pre">odesolvers.ODE.Ode_scipy</span></tt></a></p>
<p>Wrapper for scipy.integrate.ode.vode, which is a wrapper for vode.f,
which intends to solve initial value problems of stiff or nonstiff
type. The well-known vode.f solver applies backward differential
formulae for iteration.</p>
<p>Required input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f</td>
<td>Right-hand side <tt class="docutils literal"><span class="pre">f(u,t)</span></tt> defining the ODE</td>
</tr>
</tbody>
</table>
<p>Optional input arguments:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>f_args</td>
<td>Extra positional arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_arg</span>
<span class="pre">s,</span> <span class="pre">**f_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-odd"><td>f_kwargs</td>
<td>Extra keyword arguments to f: <tt class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">*f_args,</span>
<span class="pre">**f_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-even"><td>complex_valued</td>
<td>True if f is complex valued (default: False)</td>
</tr>
<tr class="row-odd"><td>jac</td>
<td>Jacobian of right-hand side function f (df/du) (d
efault: None)</td>
</tr>
<tr class="row-even"><td>jac_kwargs</td>
<td>Extra keyword arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span> <span class="pre">*jac_</span>
<span class="pre">args,**jac_kwargs)</span></tt> (default: {})</td>
</tr>
<tr class="row-odd"><td>jac_args</td>
<td>Extra positional arguments to jac: <tt class="docutils literal"><span class="pre">jac(u,</span> <span class="pre">t,</span> <span class="pre">*j</span>
<span class="pre">ac_args,**jac_kwargs)</span></tt> (default: ())</td>
</tr>
<tr class="row-even"><td>atol</td>
<td>absolute tolerance for solution (default: 1e-08)</td>
</tr>
<tr class="row-odd"><td>rtol</td>
<td>relative tolerance for solution (default: 1e-06)</td>
</tr>
<tr class="row-even"><td>first_step</td>
<td>Suggested first time step size for an adaptive al
gorithm</td>
</tr>
<tr class="row-odd"><td>max_step</td>
<td>Maximum step size for an adaptive algorithm</td>
</tr>
<tr class="row-even"><td>nsteps</td>
<td>Max no of internal solver steps per time step (de
fault: 1000)</td>
</tr>
<tr class="row-odd"><td>adams_or_bdf</td>
<td>Method in vode or solvers in odepack: &#8220;adams&#8221; or
&#8220;bdf&#8221; (default: adams)</td>
</tr>
<tr class="row-even"><td>min_step</td>
<td>Minimum step size for an adaptive algorithm</td>
</tr>
<tr class="row-odd"><td>order</td>
<td>Maximum order used by the integrator (&lt;= 12 for &#8221;
adams&#8221;, &lt;= 5 for &#8220;bdf&#8221;) (default: 4)</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">adjust_parameters</span></tt>()</td>
<td>This method allows subclasses to adjust (modify or add) entries in the self._parameters dictionary.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">advance</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_conditional_parameters</span></tt>()</td>
<td>This function is used to check whether conditional parameters are provided when specified condition fulfilled.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_extra</span></tt>(**kwargs)</td>
<td>A parameter may have a keyword <tt class="docutils literal"><span class="pre">extra_check</span></tt> for user-given functions that performs consistency checks on the parameter.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_range</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are in right specified range.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">check_input_types</span></tt>(**kwargs)</td>
<td>Check whether all existing inputs are of right specified type.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">compile_string_functions</span></tt>(f,&nbsp;**kwargs)</td>
<td>Compile functions which are supplied as Fortran strings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">constant_time_step</span></tt>()</td>
<td>Check if self.t has a uniform partition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">func_wrapper</span></tt>()</td>
<td>This function is defined to wrap user-defined functions with new forms of parameter-list, or wrap the returned values as numpy arrays.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>([parameter_name,&nbsp;print_info])</td>
<td>Return value of specified input parameters.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_parameter_info</span></tt>([print_info])</td>
<td>Return a dictionary containing all properties of all legal parameters in current subclass (i.e., the parameters in <tt class="docutils literal"><span class="pre">self._parameters</span></tt>).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">initialize</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#odesolvers.ODE.Vode.initialize_for_solve" title="odesolvers.ODE.Vode.initialize_for_solve"><tt class="xref py py-obj docutils literal"><span class="pre">initialize_for_solve</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set</span></tt>([strict])</td>
<td>Assign values to one or more parameters, specified as keyword arguments.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_condition</span></tt>(U0)</td>
<td>Function set_initial_condition() is used to set initial value of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">solve</span></tt>(time_points[,&nbsp;terminate])</td>
<td>Compute discrete solution u of the ODE problem at time points</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">switch_to</span></tt>(solver_target[,&nbsp;print_info])</td>
<td>Create a new solver instance which switch to another subclass with same values of common attributes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">validate_data</span></tt>()</td>
<td>This function is used for extra check after all the attributes, (including inputs and internal parameters), have been initialized, e.g.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="odesolvers.ODE.Vode.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'odesolvers.ODE'</em><a class="headerlink" href="#odesolvers.ODE.Vode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="odesolvers.ODE.Vode.initialize_for_solve">
<tt class="descname">initialize_for_solve</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#Vode.initialize_for_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.Vode.initialize_for_solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="odesolvers.ODE.Vode.quick_description">
<tt class="descname">quick_description</tt><em class="property"> = 'Adams/BDF Vode adaptive method (vode.f wrapper)'</em><a class="headerlink" href="#odesolvers.ODE.Vode.quick_description" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="odesolvers.ODE.approximate_Jacobian">
<tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">approximate_Jacobian</tt><big>(</big><em>f</em>, <em>u0</em>, <em>t0</em>, <em>h</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#approximate_Jacobian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.approximate_Jacobian" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute approximate Jacobian of fucntion f at current point (u0,t0).
Method: forward finite difference approximation with step
size h.
Output: a two-dimensional array holding the Jacobian matrix.</p>
</dd></dl>

<dl class="function">
<dt id="odesolvers.ODE.list_all_solvers">
<tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">list_all_solvers</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#list_all_solvers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.list_all_solvers" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all solver classes in this package, excluding superclasses.</p>
</dd></dl>

<dl class="function">
<dt id="odesolvers.ODE.list_available_solvers">
<tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">list_available_solvers</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#list_available_solvers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.list_available_solvers" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all available solver classes in this package.</p>
</dd></dl>

<dl class="function">
<dt id="odesolvers.ODE.table_of_parameters">
<tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">table_of_parameters</tt><big>(</big><em>classname</em>, <em>fixed_width=None</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#table_of_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.table_of_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a table (in reST format) of the required parameters
in a class and a table of the optional parameters.
The returned string is typially appended to the doc string of
a solver class so that the user can easily see which parameters
that must and can be provided.</p>
</dd></dl>

<dl class="function">
<dt id="odesolvers.ODE.typeset_toc">
<tt class="descclassname">odesolvers.ODE.</tt><tt class="descname">typeset_toc</tt><big>(</big><em>toc</em><big>)</big><a class="reference internal" href="_modules/odesolvers/ODE.html#typeset_toc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#odesolvers.ODE.typeset_toc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><tt class="docutils literal"><span class="pre">odesolvers.ODE</span></tt></a><ul>
<li><a class="reference internal" href="#how-to-implement-a-new-solver">How to implement a new solver</a><ul>
<li><a class="reference internal" href="#dependency-preparation">Dependency preparation</a></li>
<li><a class="reference internal" href="#definition-of-legal-parameters-and-their-properties">Definition of legal parameters and their properties</a></li>
<li><a class="reference internal" href="#special-check-in-validate-data">Special check in validate_data()</a></li>
<li><a class="reference internal" href="#internal-settings-in-initialize-for-solve">Internal settings in initialize_for_solve()</a></li>
<li><a class="reference internal" href="#step-forward-in-advance">Step forward in advance()</a><ul>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/ODE.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">odesolver API 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Liwei Wang and Hans Petter Langtangen.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>